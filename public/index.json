[{"categories":["碎碎念"],"content":"🤔 每天都像开盲盒，今天开到的是什么呢？ ","date":"2023-03-02","objectID":"/month/:0:0","tags":["碎碎念"],"title":"蠢 Q 碎碎念","uri":"/month/"},{"categories":["碎碎念"],"content":"2023 ","date":"2023-03-02","objectID":"/month/:1:0","tags":["碎碎念"],"title":"蠢 Q 碎碎念","uri":"/month/"},{"categories":["碎碎念"],"content":"2023-03 03-02 以前厌恶章鱼哥。 后来理解章鱼哥。 现在变成章鱼哥。 03-01 吸~~~ Nice。浓浓的阿里味儿，这一张 PPT吹了半小时还意犹未尽。。。 ","date":"2023-03-02","objectID":"/month/:1:1","tags":["碎碎念"],"title":"蠢 Q 碎碎念","uri":"/month/"},{"categories":["碎碎念"],"content":"2023-02 02-28 02-27 一款 AI 玩具。 Scribble Diffusion 02-26 被安利了《初恋 First Love》，终于赶在这周的最后一天追完了 😌。 “🙄 成年男主抛弃七年未婚妻，在未分手情况下与女主搞暧昧，女主告白后，却转而去国外实现梦想”。 “🙃 你们小日子出走半生，归来学小西八搞车祸失忆是吧”。 —— 开个玩笑，哈哈。 1997年前往北见的雪中列车车厢，男主在无可救药的不良少年时期迎来了自己的白月光，在她的书页悄悄夹上车票，为她发疯似地学习考上北海道北见高校并与女主再次相见。 同样女主对男主的一见钟情也是在这趟列车上，她在车站等了他很久想留下方式结果没有等到。 那不勒斯意面、半空经过的飞机、手语、缆车星空、玉米浓汤饮料、滚落楼梯的紧抱、那些被烧的信、那张 CD… “两个有共同点的人能够相遇的几率，据说是二十万分之一。然后能认识某个人的几率是两百万分之一。之后能够越来越亲近的几率，是两千万分之一。人们彼此能够成为朋友的几率，是两亿分之一。能够成为挚友的几率是二十亿分之一。说到遇见你的灵魂伴侣，几率是…六十亿分之一”。 命运指引和冥冥相遇真爱保佑，即使漫长错过和阻碍也最终会重逢。相互喜欢的人再次见面时也还是会喜欢吧，不管隔了多久的时间和经历。 女二看起来是有些可怜的，但就像剧里女主载着乘客错过高速路口那一段，“简直就是地狱，明知道是个错误还继续往前开”。对于一个不爱自己的人，及时止损，坦然放手才是最好的决定。她自己是一颗恒星，会照亮自己，我坚信这样的女生最终也会迎来爱自己的人。 最让人泪目的是旺太郎的告白：“我还是相信命中注定，有一天在垃圾场一样的办公室里，出现了一个特别的人，她就像一只外国品种的猫，如梦似幻、晶莹剔透，多亏这个人的出现，我终于能满怀期待地去上班，我甚至学会了吃虾。你也许会觉得，我把这叫做命中注定是夸大其词，但如果有朝一日，我在外国当上了一个事业有成的虾农，如果我挣了一大笔钱，还娶了一位美丽可爱的妻子，到那时，人们会说，是野口也英改变了占部旺太郎的人生”。 “最好的爱情是势均力敌，你很好，我也不差”。 “一生最重要的两件事，一是找对事业，二是找对爱人。当太阳升起时要投身于事业，当夕阳西下时要与爱人相拥”。 我自己是很相信命运和缘分的，缘起则聚、缘尽则散。但无所如何，请你一定要鼓足勇气，拼尽全力，负重前行。好好爱自己，经营好自己的小生活 🥰。 02-25 迅速买了蒙脱石散和奥司他韦，舒坦了 😌。 02-24 面试官：请说一下 git revert 和 git reset 的区别? 😓 02-23 冲啊！ 02-22 终于把《Breaking Bad》系列追完了 😌。 沃尔特·怀特: 希望通过制毒实现自己的人生价值，逐渐走上不归路，人生最后一刻轻轻抚摸着自己心爱的化学仪器，眼角含泪，慢慢死去。 杰西·平克曼: 内心善良纯洁，但双商低下，猪队友，自作孽，最后回来找到钱，换了身份去了阿拉斯加州开始了新的生活，也算比较圆满吧。 斯凯勒: 前期一系列行为还可以理解，后面逐渐变味，大着肚子勾引老板、偷钱给情人填坑…通过老白给的证据得到了赦免权，也算比较好的归宿。 古斯·弗林: 一个完美的领导者，人格魅力爆表，把自己的商业帝国打理的井井有条，死之前还扯了扯自己的领带保持自己的优雅，着实被惊讶到了。 汉克·施拉德: 超凡的单人作战能力，有勇有谋，咬住了一件事情绝不松嘴，但感觉过于自负、轻视对手的错误，最后搭上了自己的性命。 简: 全剧颜值最高的角色，简单、快活、孤独、叛逆、缺爱，小粉的真爱，两个灵魂伴侣最后阴阳两隔的命运也让人无限伤感。 以上纯属个人观点，不接受反驳 🤪。 02-21 哥哥的朋友（一个开着奔驰，在成都月租 4k 只为天天陪儿子上下学的大佬）给算命，基本跟去年自己花钱算命的那个人说的差不多，一个学校出来的嘛 🤣。 02-20 又老一岁 🎂。 02-19 是故胜兵先胜而后求战，败兵先战而后求胜。 – 孙子 02-18 前一天开开心心地做好周六计划，第二天一觉醒来中午 12 点了 🥲。 02-17 🎉🎉🎉!!! 新技能 √，完成了 Nextjs + Strapi 的相关学习。 晚上去看个《蚁人与黄蜂女》 奖励下自己。 02-16 🤨 今天上线，今天才开始测试，梁静茹给的勇气嘛。 Breaking Bad S4 最后三集，🤣 02-15 🥲 小猫咪的迷惑行为。 02-14 ps1: 上午开开心心地 coding 中，被 call 了好几次的诈骗电话，挂断就打，挂断就打，🤷🏻‍♀️接听了，熟悉的声音，还是那个人，“你是 xx 是吧，我是廊坊公安局的，xxxx 地址，拿上你的身份证来公安局一趟”。 我：“哥，去年我就接到过你的电话了，真的挺无聊的，干点正八经的事情吧，别再骗人了”。 挂断了，没有再打来，周围同事爆笑 😳。 ps2: 有那么一种人真的是挺无语的，就活该找不到工作，自己的事自己都不上心，简历写的稀烂，你不想找工作就不要去麻烦别人给你内推，给你推了，又开始嫌弃这嫌弃那，嫌弃公司，嫌弃工资高不高，嫌弃加不加班，对自己当下所在的公司又怨声怨气，真的是 🤡。你这么 🐂，自己去找吧，大家都挺忙的，多管一分钟都是浪费生命 🤨 (：😠 也骂给我自己听，谨记！。 总结：今天真是 emo 的一天 🤦🏻‍♀️。 02-13 🤣 02-12 “When you have children, you always have family. They will always be your priority, your responsibility. And a man, a man provides. And he does it even when he’s not appreciated or respected or even loved. He simply bears up and he does it. Because he’s a man.” 🤯 02-11 大半年没做饭，心血来潮想整个小炒肉，咸哭了😭。。。。 02-10 Nacos？ 🤔 02-09 02-08 什么是开会？ 一种成年人以合法领取工资为目的，既能占用工时又能降低劳动强度的集体活动。 — Mr 高源 02-07 🎉🎉🎉!!! 新技能 √，完成了 Electron + Vue3 的相关学习。 Github Profile 换了新的样子。 🤔 搞点什么奖励下自己呢？ 02-06 He deserved it. 02-05 😜 轻断食前的最后一顿大餐。 02-04 😠 无知和过度的商业宣传形成了健康问题必然危机生命的大众认知，从维持生命的人性底层上滋生了心理层面的恐慌，驱动了盲目的就医行动。 02-03 node.js 还是挺有意思的。 02-02 Damn cool!!! 02-01 ","date":"2023-03-02","objectID":"/month/:1:2","tags":["碎碎念"],"title":"蠢 Q 碎碎念","uri":"/month/"},{"categories":["碎碎念"],"content":"2023-01 01-31 被公司的 UI 折磨惨了😭。 01-30 一本书，可以折射一个小世界，也可以成为一部分人的朋友。 01-29 😠。 01-28 上班第一天，😴。 01-27 在🚄上读《解忧杂货店》，要是世界上真的有一家这样的店就好了。 01-26 I am sorry MJ… it’s 2023 and the world is still cruel. 01-25 01-24 4个人一起喝🍺，吐了1个，晕了2个。 01-23 飞扬的👖。 01-22 🥰的一天，老弟给买了烤鸡和🧋，陪爸爸妈妈一起看📺。 01-21 新年快乐鸭🎆。 01-20 🤔发现一个挺有意思的事情，因为要回老家过年，给🐱准备了两个猫砂盆，这家伙竟然自己主动分类了，一个专门用来💧，一个专门用来💩。 01-19 彩妆的尽头是裸妆 烫发的尽头是黑长直 美甲的尽头是肉粉色 医美的尽头是养生 消费主义的尽头是断舍离 道理的尽头是大道至简 万事的尽头是尽人事听天命 人生的尽头是一个人面对孤独 01-18 重温《德鲁纳酒店》，每个人看似理智又冷静，但其实内心也有着最脆弱的一面，没有了依靠时，只能用坚强来掩盖自己的脆弱。 01-17 世界上怎么会有IU这么可爱的👧🏻。 01-16 打扫卫生。 01-15 😴😴😴 01-14 直发回来的那一刻，如释重负😊。 01-13 塔勒布说过：“21世纪有三大毒品：海洛因、碳水化合物、每月发一次的工资。” 01-12 原来妈妈也喜欢听你给她讲在外面遇到的新鲜事儿😊。 01-11 闺蜜失恋了，被迫听了3个小时的她和她前男友的爱情故事🤕。 01-10 公司产品总监为了拍老板🐴屁，东西还没做完就着急给老板👁，然后白屏了，🦷都笑掉了。 01-09 犹豫了很久很久，终于下定决心入手 AJ 扣碎篮板😍。 钱不花就是一张纸，花了才是钱😳。 01-08 在飞机上看了《一条狗的使命2》，哭得稀里哗啦的😭。 多希望饼干🐱也可以一直历经生死轮回找到我并陪伴着我，直到我走到生命的终点。 01-07 不好好看文档系列😭。。包子都吃完了，才看到要按照顺序吃，可惜肚子吃不下了，不然再来一笼。 好想知道如果这样吃，会不会让灵魂得到升华🤔。 01-06 或许曾经我们都想自己是齐天大圣，可长大后才发现，其实我们都只是一只努力生存的小猪妖。 01-05 做前端死路一条，后端也是。 01-04 读文学经典以来最大的感受是：慢慢看淡生与死。 01-03 01-02 乔妹的演技还是可以，一口气追完了，期待第二季😄 01-01 去成都SKP逛一圈，才能知道自己有多穷😭 ","date":"2023-03-02","objectID":"/month/:1:3","tags":["碎碎念"],"title":"蠢 Q 碎碎念","uri":"/month/"},{"categories":["碎碎念"],"content":"2022 ","date":"2023-03-02","objectID":"/month/:2:0","tags":["碎碎念"],"title":"蠢 Q 碎碎念","uri":"/month/"},{"categories":["碎碎念"],"content":"2022-12 12-31 2022 年的最后一天，这一年，浑浑噩噩，基本什么都没有干成。希望明年可以多做些有意义的事情。 2023 年的目标： 减重到 47 公斤左右 提升第一技能，react、vue3、typescript 等 开始第二技能，STEAM32、C、C++ 等 学一门乐器，例如尤克里里 保证参与开源项目，github争取每天都有贡献 每天学英语 微信读书读完 20 本书籍 买一套属于自己的房子 考 MBA 护肤、淡妆、健康、搞钱 多回家看看、多爱惜自己 12-30 和家里人保持联系，他们是这个世界上最爱你的人。 12-29 烤无双，很好吃呦😄 12-28 少年去游荡，中年想掘藏，老年做和尚。 12-27 IoTSharp官网新鲜出炉。 12-26 这本书很有意思。 12-25 Merry Christmas🎄 12-24 🍎 12-23 熬夜看完了《星期三》，喜欢这种暗黑👧🏻。 12-22 感谢瑞幸咖啡和同事的草莓糖，味觉和嗅觉回来了😄 12-21 分享最近很火的一段僵尸舞，来自《星期三》 12-20 12-19 🔥。 12-18 和饼干一起晒☀️，地上铺上新毯子，🐱在地上趴着就不会🥶了。 12-17 发烧中。 12-16 发烧中。 12-15 发烧中。 12-14 🐑了。 12-13 嗓子冒烟了。 12-12 🥶🥶🥶 12-11 《纸房子·第二季》 “纸房子是人民的！” 小红猪里裂开的都是💰啊。。 12-10 公司后端写的烂接口，一个都不能用，就混吧 12-09 神🐱压中了🇭🇷 12-08 公司有人🐑了。。。 12-07 你知道养劳工为什么不能让他们不愁吃穿吗？因为他们会以为自己才是主人。 12-06 不到最后一刻，都不算真正结束。 12-05 这支球队就像一个平凡努力的普通人的一生。他不是最强最出彩的，但你想赢他也不容易，因为他有强大的定力和拼劲，打不倒压不垮，还能绝处逢生。 12-04 被欲望蒙蔽双眼的人，往往分不清眼前的是食物还是诱饵。 12-03 人可以平庸，但不能踩着人往上，也不能通过贬低和否定他人，来实现自己的价值。 12-02 坚持每周中强度运动150分钟/高强度运动70分钟，可以获得一个漂亮的大海马体。 12-01 钱都起床了，你还不起。 ","date":"2023-03-02","objectID":"/month/:2:1","tags":["碎碎念"],"title":"蠢 Q 碎碎念","uri":"/month/"},{"categories":["读书"],"content":"🧐 书中自有黄金屋，书中自有颜如玉。 ","date":"2023-03-02","objectID":"/books/:0:0","tags":["读书"],"title":"那些年读过的书随手记","uri":"/books/"},{"categories":["读书"],"content":"2023 ","date":"2023-03-02","objectID":"/books/:1:0","tags":["读书"],"title":"那些年读过的书随手记","uri":"/books/"},{"categories":["读书"],"content":"女性主义·上野千鹤子 两位已到暮年的优秀女性的碎碎念，唯一提醒我的就是多赚钱、多攒钱为养老做准备。 (ps: 少年当有鲲鹏之志、中年当有妻儿之乐、老年当有囊中之财)。 ","date":"2023-03-02","objectID":"/books/:1:1","tags":["读书"],"title":"那些年读过的书随手记","uri":"/books/"},{"categories":["读书"],"content":"世界尽头的咖啡馆 你存在的意义是什么？ 你害怕死亡吗？ 你满足吗？ ","date":"2023-03-02","objectID":"/books/:1:2","tags":["读书"],"title":"那些年读过的书随手记","uri":"/books/"},{"categories":["读书"],"content":"微习惯·瘦身篇 天下难事必做于易，天下大事必做于细，微习惯就像滚雪球，长年累月必有惊人效果。 ","date":"2023-03-02","objectID":"/books/:1:3","tags":["读书"],"title":"那些年读过的书随手记","uri":"/books/"},{"categories":["读书"],"content":"微习惯 2023 年读完的第五本书，🤔 好像打开了新世界的大门。 彻底改变只需八步： step1: 选择适合你的微习惯和计划。 step2: 挖掘每个微习惯的内在价值。 step3: 明确习惯依据，将其纳入日程。 step4: 建立回报机制，以奖励提升成就感。 step5: 记录与追踪完成情况。 step6: 微量开始，超额完成。 step7: 服从计划安排，摆脱高期待值。 step8: 留意微习惯养成的标志。 八大规则： 绝不要自欺欺人。 满意每一个进步。 经常回报自己，尤其在完成微习惯之后。 保持头脑清醒。 感到强烈抵触时，后退并缩小目标。 提醒自己这件事很轻松。 绝不要小看微步骤。 用多余精力超额完成任务，而不是制定更大目标。 ","date":"2023-03-02","objectID":"/books/:1:4","tags":["读书"],"title":"那些年读过的书随手记","uri":"/books/"},{"categories":["读书"],"content":"李诞脱口秀工作手册 2023 年读完的第四本书，很薄，2 个小时不到就看完了，以下是我有收获的地方： 工作的本质是交易，我们在用自己的时间和才能，通过一家公司，与市场交换金钱。（：🤔 被动收入 \u003e 工资时，就可以离开公司了。 根据诺贝尔经济学奖得主科斯的著名理论，公司会产生的原因，就是人们自己直接与市场交易成本太高，公司会给大家省点劲。那也就是说，当你跟公司交易，比你直接跟市场交易还费劲时，你就可以离开这家公司过更好的生活了。 这是一份工作，拿了钱就先办事，办好事再说别的，不想再办事，也要想好，去哪可以继续拿钱，拿更多钱。 选择了这个行业，想要做得好，请尽早放弃分开工作和生活这种有害的想法，请尽早学会在工作中享受生活，在享受生活中工作的办法。 好的工作节奏，就包含了学习，包含了养分。不能实践，就等于没有学。最好的学习，也是在实践中学。 大家都很懒，只能靠外部压力的话，那就没事多给自己找一些 Deadline。Deadline 永远是创作做好的朋友。 无论如何，先行动起来，写起来，写不好你还写不坏吗？有了坏的，才能有好的。（：狠狠地 👍🏻 了。 我们必须习惯用发展的眼光看问题，人生不是几把牌，赢了就赢了，人生是个棋局，想散都散不了的那种，输赢不在一把两把。 每天睡觉前唯一要考察的只有一件事：你有没有持续地变好？今天是否获得了一点昨天没有的东西？这是查理·芒格的建议。 做一个真诚的人，尽可能善良，不掩藏痛苦，也不羞涩于快乐，放心地把自己交给舞台，交给同伴，交给世界。 我们绝不搞一团和气，不好就是不好，但否定他的同时，也请伸手救救他。 保持专业，时时刻刻都做到专业，这样跟你接触的人才不会轻看你，才愿意信任你。 福尔摩斯说，看和观察是不一样的。越早丧失看剧的乐趣，越早发现观察剧的乐趣，越早成为一个合格的以创作为生的人。 取法其上得其中。(: 🤔 如果你对自己的要求是中，那可能得到的是下。 心灵鸡汤很多说的都是对的，它是鸡汤的原因是很少有人去实践。(: 🤔 好像有那么点道理。 面对一个大脑，想要影响它，最好是从情绪进入，再去说服理性。在提出一个看法之前，先讲一个故事，先在情绪上拉近彼此，唤醒你对某些困境的情绪记忆，再小心翼翼地说出我的观点，视图把它放进你那武装完整的新皮层。(: 🤔 N + 1 循序渐进。 产品经理俞军关于用户的定义我们可以好好借鉴：用户不是自然人，而是需求的集合。比如：假设使用微信的自然人有 11 亿，其中通信需求 11 亿，朋友圈需求 9 亿，收付款需求 5 亿，那么微信的用户实际上是 25亿。(: 😮 学到了。 ","date":"2023-03-02","objectID":"/books/:1:5","tags":["读书"],"title":"那些年读过的书随手记","uri":"/books/"},{"categories":["读书"],"content":"长期主义 ","date":"2023-03-02","objectID":"/books/:1:6","tags":["读书"],"title":"那些年读过的书随手记","uri":"/books/"},{"categories":["读书"],"content":"解忧杂货店 ","date":"2023-03-02","objectID":"/books/:1:7","tags":["读书"],"title":"那些年读过的书随手记","uri":"/books/"},{"categories":["读书"],"content":"生活蒙太奇 ","date":"2023-03-02","objectID":"/books/:1:8","tags":["读书"],"title":"那些年读过的书随手记","uri":"/books/"},{"categories":["第一技能"],"content":"项目地址： TSHandbook ","date":"2023-03-01","objectID":"/ts/:0:0","tags":["第一技能"],"title":"Typescript 使用手册","uri":"/ts/"},{"categories":["第一技能"],"content":"类型世界 ","date":"2023-03-01","objectID":"/ts/:1:0","tags":["第一技能"],"title":"Typescript 使用手册","uri":"/ts/"},{"categories":["第一技能"],"content":"原始类型 number / string / boolean / null / undefined / symbol / bigint const name: string = 'wangxiaobia'; const age: number = 18; const male: boolean = false; const undef: undefined = undefined; const nul: null = null; const bigIntVar1: bigint = 9007199254740991n; const symbolVar: symbol = Symbol('unique'); null 和 undefined null 与 undefined 都是有具体意义的类型。在没有开启 strictNullChecks 检查的情况下，会被视作其他类型的子类型，比如 string 类型会被认为包含了 null 与 undefined 类型： const temp1: null = null; const temp2: undefined = undefined; const temp3: string = null; const temp4: string = undefined; void 描述一个内部没有 return，或没有显示 return 一个值的函数的返回值。 function func1 () {}; function func2 () { return }; function func3 () { return undefined; } func1 与 func2 的返回值类型会被隐式推导为 void，显式返回了 undefined 值的 func3 其返回值类型被推导为了 undefined。但在实际的代码执行中，func1 与 func2 的返回值均是 undefined。 虽然 func3 的返回值类型会被推导为 undefined，但仍可以使用 void 类型进行标注，因为在类型层面 func1、func2、func3 都表示“没有返回一个有意义的值”。 void 表示一个空类型，而 null 与 undefined 都是一个具有意义的实际类型。而 undefined（null） 能够被赋值给 void 类型的变量，但需要在关闭 strictNullChecks 配置的情况下才能成立。 const voidVar1: void = null; const voidVar2: void = undefined; ","date":"2023-03-01","objectID":"/ts/:1:1","tags":["第一技能"],"title":"Typescript 使用手册","uri":"/ts/"},{"categories":["第一技能"],"content":"数组类型 有两种方式来声明一个数组类型： const arr1: string[] = []; const arr2: Array\u003cstring\u003e = []; 这两种方式是完全等价的，更多的以前者为主。 ","date":"2023-03-01","objectID":"/ts/:1:2","tags":["第一技能"],"title":"Typescript 使用手册","uri":"/ts/"},{"categories":["第一技能"],"content":"元组类型 用来代替数组，已知数组长度和成员类型，在越界访问时（数组不会给出）可以给出类型报错。 const arr3: [string, string, string] = ['wang', 'xiao', 'bai']; arr3[18]; 此时将会产生一个类型错误：长度为“3”的元组类型“[string, string, string]”在索引“18“处没有元素。 元组内部也可以声明多个与其位置强绑定的，不同类型的元素： const arr4: [string, number, boolean] = ['wang', 18, true]; 支持在某一个位置上的可选成员： const arr5: [string, number?, boolean?] = ['wang']; TypeScript 4.0 中的具名元组（Labeled Tuple Elements），支持为元组中的元素打上类似属性的标记： const arr6: [name: string, age: number, male: boolean] = ['wang', 18, false]; 具名元组也支持可选元素的修饰符： const arr7: [name: string, age?: number, male?: boolean] = ['wang']; ","date":"2023-03-01","objectID":"/ts/:1:3","tags":["第一技能"],"title":"Typescript 使用手册","uri":"/ts/"},{"categories":["第一技能"],"content":"对象类型 interface 来描述对象类型，它代表了这个对象对外提供的接口结构。 interface IDescription { name: string; age: number; male: boolean; } const obj1: IDescription = { name: 'wangxiaobai', age: 18, male: false, } 每一个属性的值必须一一对应到接口的属性类型，不能有多的属性，也不能有少的属性。 修饰接口属性 在接口中用 ? 来标记一个属性为可选： interface IDescription { name: string; age: number; male?: boolean; func?: Function; } const obj2: IDescription = { name: 'wangxiaobai', age: 18, } 定义一个可选的布尔类型属性，当你访问 obj2.male 时，它的类型是 boolean | undefined。 定义一个可选的函数类型属性，进行调用：obj2.func() ，此时将会产生一个类型报错：不能调用可能是未定义的方法。 可选属性标记不会影响你对这个属性进行赋值。 obj2.male = false; obj2.func = () =\u003e {}; 在接口中用 readonly 来标记一个属性为只读，防止属性被再次赋值。 interface IDescriptionProps { readonly name: string; age: number; } const obj3: IDescriptionProps = { name: 'wangxiaobai', age: 18, }; obj3.name = 'OweQian'; 此时会抛出错误，无法分配到 “name” ，因为它是只读属性。 ps: 在数组和元组层面也存在着只读的修饰。 只能将整个数组/元组标记为只读，而不能像对象那样标记某个属性为只读。 一旦被标记为只读，那这个只读数组/元组的类型上，将不再具有 push、pop 等方法。 object、Object、 在 TS 中，Object 包含了所有的类型: const temp1: Object = undefined; const temp2: Object = null; const temp3: Object = void 0; const temp4: Object = 'wangxiaobai'; const temp5: Object = 18; const temp6: Object = () =\u003e {}; const temp7: Object = { name: 'wangxiaobai' }; const temp8: Object = []; 对于 undefined、null、void 0 ，需要关闭 strictNullChecks。 和 Object 类似的还有 Boolean、Number、String、Symbol，这几个装箱类型（Boxed Types），同样包含了一些超出预期的类型。 以 String 为例，它同样包括 undefined、null、void，以及代表的拆箱类型（Unboxed Types）string，但并不包括其他装箱类型对应的拆箱类型，如 boolean 与基本对象类型。 const temp9: String = undefined; const temp10: String = null; const temp11: String = void 0; const temp12: String = 'wangxiaobai'; // 以下不成立，因为不是字符串类型的拆箱类型 const temp13: String = 18; // X const temp14: String = { name: 'wangxiaobai' }; // X const temp15: String = () =\u003e {}; // X const temp16: String = []; // X 任何情况下，你都不应该使用这些装箱类型。 object 类型的引入就是为了解决 Object 类型的错误使用，它代表所有非原始类型的类型，即数组、函数、对象类型。 const temp17: object = undefined; const temp18: object = null; const temp19: object = void 0; const temp20: object = 'wangxiaobai'; // X const temp21: object = 18; // X const temp22: object = { name: 'wangxiaobai' }; const temp23: object = () =\u003e {}; const temp24: object = []; {} 是一个对象字面量类型，它代表内部无属性定义的空对象，这类似于 Object。 const temp25: {} = undefined; const temp26: {} = null; const temp27: {} = void 0; const temp28: {} = 'wangxiaobai'; const temp29: {} = 18; const temp30: {} = () =\u003e {}; const temp31: {} = { name: 'wangxiaobai' }; const temp32: {} = []; 无法对变量进行任何赋值操作。 temp31.age = 18; // X 类型“{}”上不存在属性“age” 总结： 在任何时候都不要使用 Object 以及类似的装箱类型。 当你不确定某个变量的具体类型，但能确定不是原始类型，可以使用 object。 可以使用 Record\u003cstring, unknown\u003e 或 Record\u003cstring, any\u003e 表示对象。 可以使用 any[] 或 unknown[] 表示数组。 可以使用 (…args: any[]) =\u003e any 表示函数。 避免使用 {}。 ","date":"2023-03-01","objectID":"/ts/:1:4","tags":["第一技能"],"title":"Typescript 使用手册","uri":"/ts/"},{"categories":["第一技能"],"content":"字面量类型与联合类型 定义一个接口，它描述了响应的消息结构： interface IResponseProps { code: number; status: string; data: any; } 这里的 code 与 status 实际值会来自于一组确定值的集合，比如 code 可能是 10000 / 10001 / 50000，status 可能是 “success” / “failure”。 上面的类型只给出了一个宽泛的 number / string，既不能在访问 code 时获得精确的提示，也失去了 TypeScript 类型即文档的功能。 可以使用字面量类型加上联合类型进行改写： interface IResponseProps { code: 10000 | 10001 | 50000; status: 'success' | 'failure'; data: any; } 这时就能在访问时获得精确地类型推导了。 对于 declare var res: Res，它是快速生成一个符合指定类型，但没有实际值的变量，同时它也不存在于运行时中。 字面量类型 “success” 不是一个值吗？为什么它可以作为类型？在 TypeScript 中，这叫做字面量类型（Literal Types），它代表着比原始类型更精确的类型，同时也是原始类型的子类型。 字面量类型主要包括字符串字面量类型、数字字面量类型、布尔字面量类型和对象字面量类型。 const name: 'wangxiaobai' = 'wangxiaobai'; const age: 18 = 18; const male: false = false; 为什么说字面量类型比原始类型更精确？ // 报错！不能将类型“\"wangxiaobai18\"”分配给类型“\"wangxiaobai\"”。 const str1: 'wangxiaobai' = 'wangxiaobai18'; const str2: string = 'wangxiaobai'; const str3: string = 'wangxiaobai3'; 原始类型的值可以包括任意的同类型值，而字面量类型要求的是值级别的字面量一致。 单独使用字面量类型比较少见，因为单个字面量类型并没有什么实际意义。它通常和联合类型（即这里的 |）一起使用，表达一组字面量类型： interface ITempProps { bool: true | false; num: 1 | 2 | 3; str: 'wang' | 'xiao' | 'bai' } 联合类型 它代表了一组类型的可用集合，只要最终赋值的类型属于联合类型的成员之一，就可以认为符合这个联合类型。 联合类型对其成员并没有任何限制，除了上面这样对同一类型字面量的联合，还可以将各种类型混合到一起。 interface ITempMixedProps { mixed: true | string | 18 | {} | (() =\u003e {}) | (1 | 2) } 这里有几点需要注意： 联合类型中的函数类型需要使用括号 () 包裹起来 函数类型并不存在字面量类型，因此这里的 (() =\u003e {}) 就是一个合法的函数类型 可以在联合类型中进一步嵌套联合类型，但这些嵌套的联合类型最终都会被展平到第一级中 常用场景之一是通过多个对象类型的联合，来实现手动的互斥属性，即这一属性如果有字段 1，那就没有字段 2。 interface ITempProps { user: | { vip: true; expires: string; } | { vip: false; promotion: string; } } declare var temp: ITempProps; if (temp.user.vip) { console.log(temp.user.expires); } user 属性会满足普通用户与 VIP 用户两种类型，这里 vip 属性的类型基于布尔字面量类型声明。 在实际使用时可以通过判断此属性为 true，确保接下来的类型推导都会将其类型收窄到 VIP 用户的类型（即联合类型的第一个分支）。 可以通过类型别名来复用一组字面量联合类型： type Code = 10000 | 10001 | 50000; type Status = 'success' | 'failure'; 除了原始类型的字面量类型以外，对象类型也有着对应的字面量类型。 对象字面量类型 对象字面量类型就是一个对象类型的值，这也就意味着这个对象的值全都为字面量值。 interface ITempProps { obj: { name: 'wangxiaobai'; age: 18 } } const temp: ITempProps = { obj: { name: 'wangxiaobai', age: 18 } } 如果要实现一个对象字面量类型，意味着完全的实现这个类型每一个属性的每一个值。 无论是原始类型还是对象类型的字面量类型，它们的本质都是类型而不是值。在编译时同样会被擦除，同时也是被存储在内存中的类型空间而非值空间。 ","date":"2023-03-01","objectID":"/ts/:1:5","tags":["第一技能"],"title":"Typescript 使用手册","uri":"/ts/"},{"categories":["第一技能"],"content":"枚举类型 enum PageUrl { Home_Page_Url = 'home', Setting_Page_Url = 'setting', Share_Page_Url = 'share', } const home = PageUrl.Home_Page_Url; 使用枚举拥有了更好的类型提示，并且这些常量被真正地约束在一个命名空间下。 如果没有声明枚举的值，它会默认使用数字枚举，并且从 0 开始，以 1 递增。 enum Items { Foo, Bar, Baz, } 在这个例子中，Items.Foo、Items.Bar、Items.Baz 的值依次是 0、1、2。 如果只为某一个成员指定了枚举值，那么之前未赋值成员仍然会使用从 0 递增的方式，之后的成员则会开始从枚举值递增。 enum Items { // 0 Foo, Bar = 18, // 19 Baz, } 在数字型枚举中，可以使用延迟求值的枚举值，比如函数。 const returnNum = () =\u003e 100 + 18; enum Items { Foo = returnNum(), Bar = 18, Baz, } 但要注意，延迟求值的枚举值是有条件的。如果使用了延迟求值，那么没有使用延迟求值的枚举成员必须放在使用常量枚举值声明的成员之后，或者放在第一位。 enum Items { Baz, Foo = returnNum(), Bar = 18, } 也可以同时使用字符串枚举值和数字枚举值。 enum Mixed { Num = 18, Str = 'wangxiaobai' } 枚举和对象的重要差异在于，对象是单向映射的，只能从键映射到键值。而枚举是双向映射的，可以从枚举成员映射到枚举值，也可以从枚举值映射到枚举成员。 enum Items { Foo, Bar, Baz, } const fooValue = Items.Foo; // 0 const fooKey = Items[0]; // 'Foo' 要了解这一现象的本质，需要来看一看枚举的编译产物，如以上的枚举会被编译为以下 JavaScript 代码： \"use strict\"; var Items; (function (Items) { Items[Items[\"Foo\"] = 0] = \"Foo\"; Items[Items[\"Bar\"] = 1] = \"Bar\"; Items[Items[\"Baz\"] = 2] = \"Baz\"; })(Items || (Items = {})); obj[k] = v 的返回值即是 v，因此这里的 obj[obj[k] = v] = k 本质上就是进行了 obj[k] = v 与 obj[v] = k 这样两次赋值。 仅有值为数字的枚举成员才能够进行这样的双向枚举，字符串枚举成员仍然只会进行单次映射： enum Items { Foo, Bar = \"BarValue\", Baz = \"BazValue\" } // 编译结果，只会进行 键-值 的单向映射 \"use strict\"; var Items; (function (Items) { Items[Items[\"Foo\"] = 0] = \"Foo\"; Items[\"Bar\"] = \"BarValue\"; Items[\"Baz\"] = \"BazValue\"; })(Items || (Items = {})); 常量枚举 常量枚举和枚举相似，只是其声明多了一个 const。 const enum Items { Foo, Bar, Baz, } const fooValue = Items.Foo; 它和普通枚举的差异主要在访问性与编译产物。对于常量枚举，只能通过枚举成员访问枚举值（而不能通过值访问成员）。同时，在编译产物中并不会存在一个额外的辅助对象（如上面的 Items 对象），对枚举成员的访问会被直接内联替换为枚举的值。 以上的代码会被编译为如下形式： const fooValue = 0 /* Foo */; // 0 ","date":"2023-03-01","objectID":"/ts/:1:6","tags":["第一技能"],"title":"Typescript 使用手册","uri":"/ts/"},{"categories":["第一技能"],"content":"函数类型 类型签名 函数类型是为了描述了函数入参类型与函数返回值类型，它们同样使用 : 的语法进行类型标注。 function foo(name: string): number { return name.length; } 在函数类型中同样存在类型推导。比如下面这个例子，你可以不写返回值处的类型，它也能被正确推导为 number 类型。 function name () {} 这一声明函数的方式为函数声明（Function Declaration）。除了函数声明以外，还可以通过函数表达式（Function Expression），即 const foo = function(){} 的形式声明一个函数。 在表达式中进行类型声明的方式是这样的： const foo = function (name: string): number { return name.length } 还可以像对变量进行类型标注那样，对 foo 这个变量进行类型声明： const foo: (name: string) =\u003e number = function (name) { return name.length } 这里的 (name: string) =\u003e number 是 TypeScript 中的函数类型签名，有点类似 ES6 中的箭头函数。 而实际的箭头函数的类型标注也是类似的： // 方式一 const foo = (name: string): number =\u003e { return name.length } // 方式二 const foo: (name: string) =\u003e number = (name) =\u003e { return name.length } 在方式二的声明方式中，你会发现函数类型声明混合箭头函数声明时，代码的可读性非常差。 一般不推荐这么使用，要么直接在函数中进行参数和返回值的类型声明，要么使用类型别名将函数声明抽离出来： type FuncFoo = (name: string) =\u003e number const foo: FuncFoo = (name) =\u003e { return name.length } 如果只是为了描述这个函数的类型结构，也可以使用 interface 来进行函数声明： interface FuncFooStruct { (name: string): number } 这时的 interface 被称为 Callable Interface。 void 类型 在 TypeScript 中，一个没有返回值（即没有调用 return 语句）的函数，其返回类型应当被标记为 void 而不是 undefined，即使它实际的值是 undefined。 // 没有调用 return 语句 function foo(): void { } 在 TypeScript 中，undefined 类型是一个实际的、有意义的类型值，而 void 代表着空的、没有意义的类型值。 相比之下，void 类型就像是 JavaScript 中的 null 一样。因此在没有实际返回值时，使用 void 类型能更好地说明这个函数没有进行返回操作。 但当函数中有 return 语句但没有显示返回一个值时，其实更好的方式是使用 undefined： function bar(): undefined { return; } 这个函数进行了返回操作，但没有返回实际的值。 可选参数 函数存在一些可选参数的情况，当不传入参数时函数会使用此参数的默认值。正如在对象类型中使用 ? 描述一个可选属性一样，在函数类型中也使用 ? 描述一个可选参数： // 在函数逻辑中注入可选参数默认值 function foo1(name: string, age?: number): number { const inputAge = age ?? 18; return name.length + inputAge } // 直接为可选参数声明默认值 function foo2(name: string, age: number = 18): number { const inputAge = age || 18; return name.length + inputAge } 可选参数必须位于必选参数之后。这里的可选参数类型也可以省略，如这里原始类型的情况可以直接从提供的默认值类型推导出来。但对于联合类型或对象类型的复杂情况，还是需要老老实实地进行标注。 rest 参数 rest 参数的类型标注也比较简单，由于其实际上是一个数组，这里也应当使用数组类型进行标注： 对于 any 类型，你可以简单理解为它包含了一切可能的类型。 function foo(arg1: string, ...rest: any[]) { } 也可以使用元组类型进行标注： function foo(arg1: string, ...rest: [number, boolean]) { } foo(\"wangxiaobai\", 18, true) 重载 在某些逻辑较复杂的情况下，函数可能有多组入参类型和返回值类型： function func(foo: number, bar?: boolean): string | number { if (bar) { return String(foo); } else { return foo * 18; } } 在这个实例中，函数的返回类型基于其入参 bar 的值，并且从其内部逻辑中知道，当 bar 为 true，返回值为 string 类型，否则为 number 类型。而这里的类型签名完全没有体现这一点，只知道它的返回值是个联合类型。 要想实现与入参关联的返回值类型，可以使用 TypeScript 提供的函数重载签名（Overload Signature），将以上的例子使用重载改写： function func(foo: number, bar: true): string; function func(foo: number, bar?: false): number; function func(foo: number, bar?: boolean): string | number { if (bar) { return String(foo); } else { return foo * 18; } } const res1 = func(18); // number const res2 = func(18, true); // string const res3 = func(18, false); // number 这里的三个 function func 其实具有不同的意义： function func(foo: number, bar: true): string，重载签名一，传入 bar 的值为 true 时，函数返回值为 string 类型。 function func(foo: number, bar?: false): number，重载签名二，不传入 bar，或传入 bar 的值为 false 时，函数返回值为 number 类型。 function func(foo: number, bar?: boolean): string | number，函数的实现签名，会包含重载签名的所有可能情况。 基于重载签名就实现了将入参类型和返回值类型的可能情况进行关联，获得了更精确的类型标注能力。 这里有一个需要注意的地方，拥有多个重载声明的函数在被调用时，是按照重载的声明顺序往下查找的。 因此在第一个重载声明中，为了与逻辑中保持一致，即在 bar 为 true 时返回 string 类型，这里需要将第一个重载声明的 bar 声明为必选的字面量类型。 你可以试着为第一个重载声明的 bar 参数也加上可选符号，然后就会发现第一个函数调用错误地匹配到了第一个重载声明。 异步函数、Generator 函数等类型签名 对于异步函数、Generator 函数、异步 Generator 函数的类型签名，其参数签名基本一致，而返回值类型则稍微有些区别： async function asyncFunc(): Promise\u003cvoid\u003e {} function* genFunc(): Iterable\u003cvoid\u003e {} async function* asyncGenFunc(): AsyncIterable\u003cvoid\u003e {} 对于异步函数（即标记为 async 的函数），其返回值必定为一个 Promise 类型，而 Promise 内部包含的类型则通过泛型的形式书写，即 Promise。 ","date":"2023-03-01","objectID":"/ts/:1:7","tags":["第一技能"],"title":"Typescript 使用手册","uri":"/ts/"},{"categories":["第一技能"],"content":"Class 类与类成员的类型签名 类的主要结构有构造函数、属性、方法和访问符（Accessor）。 属性的类型标注类似于变量，而构造函数、方法、存取器的类型编标注类似于函数： class Foo { prop: string; constructor(inputProps: string) { this.prop = inputProps; } print (addon: string): string { return `${this.prop} and ${addon}`; } get PropA(): string { return `${this.prop}+A`; } set PropA(value: string) { this.prop = `${value}`; } } setter 方法不允许进行返回值的类型标注，可以理解为 setter 的返回值并不会被消费，它是一个只关注过程的函数。类的方法同样可以进行函数那样的重载。 类也可以通过类声明和类表达式的方式创建。上面的写法即是类声明，而使用类表达式的语法则是这样的： const Foo = class { prop: string; constructor(inputProps: string) { this.prop = inputProps; } print (addon: string): string { return `${this.prop} and ${addon}`; } get PropA(): string { return `${this.prop}+A`; } set PropA(value: string) { this.prop = `${value}`; } } 修饰符 在 TypeScript 中能够为 Class 成员添加这些修饰符：public / private / protected / readonly。 除 readonly 以外，其他三位都属于访问性修饰符，而 readonly 属于操作性修饰符（就和 interface 中的 readonly 意义一致）。 这些修饰符应用的位置在成员命名前： class Foo { private prop: string; constructor(inputProps: string) { this.prop = inputProps; } protected print (addon: string): string { return `${this.prop} and ${addon}`; } public get PropA(): string { return `${this.prop}+A`; } public set PropA(value: string) { this.prop = `${value}`; } } 通常不会为构造函数添加修饰符，而是让它保持默认的 public。 public：此类成员在类、类的实例、子类中都能被访问。 private：此类成员仅能在类的内部被访问。 protected：此类成员仅能在类与子类中被访问。 当你不显式使用访问性修饰符，成员的访问性默认会被标记为 public。简单起见，可以在构造函数中对参数应用访问性修饰符： class Foo { constructor(public arg1: string, private arg2: boolean) { } } new Foo('wangxiaobai', false); 此时，参数会被直接作为类的成员（即实例的属性），免去后续的手动赋值。 静态成员 在 TypeScript 中，可以使用 static 关键字来标识一个成员为静态成员： class Foo { static staticHandler () {} public instanceHandler () {} } 不同于实例成员，在类的内部静态成员无法通过 this 来访问，需要通过 Foo.staticHandler 这种形式进行访问。 可以查看编译到 ES5 及以下 target 的 JavaScript 代码（ES6 以上就原生支持静态成员了），来进一步了解它们的区别： var Foo = /** @class */ (function () { function Foo() { } Foo.staticHandler = function () { }; Foo.prototype.instanceHandler = function () { }; return Foo; }()); 从中可以看到，静态成员直接被挂载在函数体上，而实例成员挂载在原型上，这就是二者的最重要差异：静态成员不会被实例继承，它始终只属于当前定义的这个类（以及其子类）。而原型对象上的实例成员则会沿着原型链进行传递，也就是能够被继承。 而对于静态成员和实例成员的使用时机，其实并不需要非常刻意地划分。比如用类 + 静态成员来收敛变量与 utils 方法： class Utils { static identifier = 'wangxiaobai' static studyWithU () { } static makeUHappy () { Utils.studyWithU() } } Utils.makeUHappy() 继承、实现、抽象类 说到 Class，那一定离不开继承。TypeScript 中也使用 extends 关键字来实现继承： class Base {} class Derived extends Base {} 对于这里的两个类，比较严谨的称呼是基类（Base）与派生类（Derived）。当然，如果叫父类与子类也没问题。关于基类与派生类，需要了解的主要是派生类对基类成员的访问与覆盖操作。 基类中的哪些成员能够被派生类访问，完全是由其访问性修饰符决定的。派生类中可以访问到使用 public 或 protected 修饰符的基类成员。 除了访问以外，基类中的方法也可以在派生类中被覆盖，但仍然可以通过 super 访问到基类中的方法： class Base { print () {} } class Derived extends Base { print() { super.print(); // ... } } 在派生类中覆盖基类方法时，并不能确保派生类的这一方法能覆盖基类方法，万一基类中不存在这个方法呢？ 所以，TypeScript 4.3 新增了 override 关键字，来确保派生类尝试覆盖的方法一定在基类中存在定义： class Base { printWithLove() {} } class Derived extends Base { override print() { super.print(); } } 在这里 TypeScript 将会给出错误，因为尝试覆盖的方法并未在基类中声明。通过这一关键字就能确保首先这个方法在基类中存在，同时标识这个方法在派生类中被覆盖了。 除了基类与派生类以外，还有一个比较重要的概念：抽象类。 抽象类是对类结构与方法的抽象，简单来说，一个抽象类描述了一个类中应当有哪些成员（属性、方法等），一个抽象方法描述了这一方法在实际实现中的结构，抽象方法其实描述的就是这个方法的入参类型与返回值类型。 抽象类使用 abstract 关键字声明： abstract class AbsFoo { abstract absProp: string; abstract get absGetter (): string; abstract absMethod (name: string): string; } 注意，抽象类中的成员也需要使用 abstract 关键字才能被视为抽象类成员，如这里的抽象方法。 实现（implements）一个抽象类： class Foo implements AbsFoo { absProp: string = 'wangxiaobai'; get absGetter(): string { return 'wangxiaobai'; } absMethod(name: string): string { return name; } } 此时，必须完全实现这个抽象类的每一个抽象成员。需要注意的是，在 TypeScript 中无法声明静态的抽象成员。 对于抽象类，它的本质就是描述类的结构。interface 不仅可以声明函数结构，也可以声明类的结构： interface IFooStruct { absProp: string; get absGetter (): string; absMethod (name: string): string; } class Foo implements IFooStruct { absProp: string = 'wangxiaobai'; get absGetter(): string { return 'wangxiaobai'; } absMethod(name: string): string { return name; } } 在这里让类去实现了一个接口。这里接口的作用和抽象类一样，都是描述这个类的结构。除此以外，还可以使用 Newable Interface 来描述一个类的结构（类似于描述函数结构的 Callable Interface）： class Foo { } interface FooStruct { new(): ","date":"2023-03-01","objectID":"/ts/:1:8","tags":["第一技能"],"title":"Typescript 使用手册","uri":"/ts/"},{"categories":["第一技能"],"content":"内置类型 any TypeScript 中提供了一个内置类型 any，表示任意类型。 log(message?: any, ...optionalParams: any[]): void 一个被标记为 any 类型的参数可以接受任意类型的值。除了 message 是 any 以外，optionalParams 作为一个 rest 参数，也使用 any[] 进行了标记，这就意味着你可以使用任意类型的任意数量类型来调用这个方法。 除了显式的标记一个变量或参数为 any，在某些情况下你的变量 / 参数也会被隐式地推导为 any。比如使用 let 声明一个变量但不提供初始值，以及不为函数参数提供类型标注： // any let foo; // foo、bar 均为 any function func(foo, bar){} 以上的函数声明在 tsconfig 中启用了 noImplicitAny 时会报错，你可以显式为这两个参数指定 any 类型，或者暂时关闭这一配置（不推荐）。 any 类型的变量几乎无所不能，它可以在声明后再次接受任意类型的值，同时可以被赋值给任意其它类型的变量： // 被标记为 any 类型的变量可以拥有任意类型的值 let anyVar: any = \"wangxiaobai\"; anyVar = false; anyVar = \"wangxiaobai\"; anyVar = { site: \"github.io\" }; anyVar = () =\u003e { } // 标记为具体类型的变量也可以接受任何 any 类型的值 const val1: string = anyVar; const val2: number = anyVar; const val3: () =\u003e {} = anyVar; const val4: {} = anyVar; 可以在 any 类型变量上任意地进行操作，包括赋值、访问、方法调用等等，此时可以认为类型推导与检查是被完全禁用的： let anyVar: any = null; anyVar.foo.bar.baz(); anyVar[0][1][2].prop1; any 类型的主要意义，是为了表示一个无拘无束的“任意类型”，它能兼容所有类型，也能够被所有类型兼容。 无论什么时候，你都可以使用 any 类型跳过类型检查。当然，运行时出了问题就需要你自己负责了。 any 的本质是类型系统中的顶级类型，即 Top Type。 any 类型的万能性也导致经常滥用它，此时的 TypeScript 就变成了令人诟病的 AnyScript。为了避免这一情况，记住以下使用小 tips： 如果是类型不兼容报错导致你使用 any，考虑用类型断言替代。 如果是类型太复杂导致不想全部声明而使用 any，考虑将这一处的类型去断言为你需要的最简类型。 如果你是想表达一个未知类型，更合理的方式是使用 unknown。 unknown 类型和 unknown 类型代表未知类型，这个类型的变量可以再次赋值为任意其它类型，但只能赋值给 any 与 unknown 类型的变量： let unknownVar: unknown = \"wangxiaobai\"; unknownVar = false; unknownVar = \"wangxiaobai\"; unknownVar = { site: \"github.io\" }; unknownVar = () =\u003e { } const val1: string = unknownVar; // Error const val2: number = unknownVar; // Error const val3: () =\u003e {} = unknownVar; // Error const val4: {} = unknownVar; // Error const val5: any = unknownVar; const val6: unknown = unknownVar; unknown 和 any 的一个主要差异在赋值给别的变量时，any 就像是 “我身化万千无处不在”，所有类型都把它当自己人。 而 unknown 就像是 “我虽然身化万千，但我坚信我在未来的某一刻会得到一个确定的类型”，只有 any 和 unknown 自己把它当自己人。 简单地说，any 放弃了所有的类型检查，而 unknown 并没有。这一点也体现在对 unknown 类型的变量进行属性访问时： let unknownVar: unknown; unknownVar.foo(); // 报错：对象类型为 unknown 要对 unknown 类型进行属性访问，需要进行类型断言，即“虽然这是一个未知的类型，但我跟你保证它在这里就是这个类型！”： let unknownVar: unknown; (unknownVar as { foo: () =\u003e {} }).foo(); 在类型未知的情况下，推荐使用 unknown 标注。这相当于你使用额外的心智负担保证了类型在各处的结构，后续重构为具体类型时也可以获得最初始的类型信息，同时还保证了类型检查的存在。 never 类型 type UnionWithNever = \"wangxiaobai\" | 18 | true | void | never; 将鼠标悬浮在类型别名之上，你会发现这里显示的类型是 “wangxiaobai” | 18 | true | void。 never 类型被直接无视掉了，而 void 仍然存在。这是因为，void 作为类型表示一个空类型，就像没有返回值的函数使用 void 来作为返回值类型标注一样，void 类型就像 JS 中的 null 一样代表“这里有类型，但是个空类型”。 而 never 才是一个 “什么都没有” 的类型，它甚至不包括空的类型，严格来说，never 类型不携带任何的类型信息，因此会在联合类型中被直接移除。 void 和 never 的类型兼容性： declare let v1: never; declare let v2: void; v1 = v2; // X 类型 void 不能赋值给类型 never v2 = v1; 在编程语言的类型系统中，never 类型被称为 Bottom Type，是整个类型系统层级中最底层的类型。 和 null、undefined 一样，它是所有类型的子类型，但只有 never 类型的变量能够赋值给另一个 never 类型变量。 它主要被类型检查所使用。但在某些情况下使用 never 确实是符合逻辑的，比如一个只负责抛出错误的函数： function justThrow(): never { throw new Error() } 在类型流的分析中，一旦一个返回值类型为 never 的函数被调用，那么下方的代码都会被视为无效的代码（即无法执行到）： function justThrow(): never { throw new Error() } function foo (input:number){ if(input \u003e 1){ justThrow(); // 等同于 return 语句后的代码，即 Dead Code const name = \"wangxiaobai\"; } } 类型断言 类型断言能够显式告知类型检查程序当前这个变量的类型，可以进行类型分析地修正、类型。 它其实就是一个将变量的已有类型更改为新指定类型的操作，它的基本语法是 as NewType，你可以将 any / unknown 类型断言到一个具体的类型： let unknownVar: unknown; (unknownVar as { foo: () =\u003e {} }).foo(); 还可以 as 到 any 来为所欲为，跳过所有的类型检查： const str: string = \"wangxiaobai\"; (str as any).func().foo().prop; 也可以在联合类型中断言一个具体的分支： function foo(union: string | number) { if ((union as string).includes(\"wangxiaobai\")) { } if ((union as number).toFixed() === '18') { } } 类型断言的正确使用方式是，在 TypeScript 类型分析不正确或不符合预期时，将其断言为此处的正确类型： interface IFoo { name: string; } declare const obj: { foo: IFoo } const { foo = {} as IFoo } = obj 这里从 {} 字面量类型断言为了 IFoo 类型，即为解构赋值默认值进行了预期的类型断言。当然，更严谨的方式应该是定义为 Partial 类型，即 IFoo 的属性均为可选的。 除了使用 as 语法以外，也可以使用 \u003c\u003e 语法。它虽然书写更简洁，但效果一致。可以通过 TypeScript ESLint 提供的 consistent-type-assertions 规则来约束断言风格。 类型断言应当是在迫不得己的情况下使用的。虽然说可以用类型断言纠正不正确的类型分析，但类型分析在大部分场景下还是可以智能地满足需求的。 总的来说，在实际场景中，还是 as any 这一种操作更多。但这也是让你的代码编程 AnyScript 的罪魁祸首之一，","date":"2023-03-01","objectID":"/ts/:1:9","tags":["第一技能"],"title":"Typescript 使用手册","uri":"/ts/"},{"categories":["第一技能"],"content":"类型工具 类型工具就是对类型进行处理的工具，分为类型创建与类型安全保护两类。 ","date":"2023-03-01","objectID":"/ts/:2:0","tags":["第一技能"],"title":"Typescript 使用手册","uri":"/ts/"},{"categories":["第一技能"],"content":"类型创建 基于已有的类型创建新的类型，这些类型工具包括类型别名、交叉类型、索引类型与映射类型。 类型别名 对一组类型或一个特定类型结构进行封装，以便于在其它地方进行复用。 使用 type 关键字进行声明： type A = string; 抽离一组联合类型： type StatusCode = 200 | 301 | 400 | 500 | 502; type PossibleDataTypes = string | number | (() =\u003e unknown); const status: StatusCode = 502; 抽离一个函数类型： type Handler = (e: Event) =\u003e void; const clickHandler: Handler = (e) =\u003e { }; const moveHandler: Handler = (e) =\u003e { }; const dragHandler: Handler = (e) =\u003e { }; 声明一个对象类型，就像接口那样： type ObjType = { name: string; age: number; } 在类型别名中，类型别名还可以声明自己能够接受泛型。一旦接受了泛型，它就叫工具类型： type Factory\u003cT\u003e = T | number | string; 它的基本功能仍然是创建类型，基于传入的泛型进行各种类型操作，得到一个新的类型。 const foo: Factory\u003cboolean\u003e = true; 一般不会直接使用工具类型来做类型标注，而是再度声明一个新的类型别名： type FactoryWithBool = Factory\u003cboolean\u003e; const foo: FactoryWithBool = true; 泛型参数的名称（上面的 T ）也不是固定的。通常使用大写的 T / K / U / V / M / O …这种形式。 声明一个简单、有实际意义的工具类型： type MaybeNull\u003cT\u003e = T | null; 这个工具类型会接受一个类型，并返回一个包括 null 的联合类型。这样一来，在实际使用时就可以确保你处理了可能为空值的属性读取与方法调用： type MaybeNull\u003cT\u003e = T | null; function process(input: MaybeNull\u003c{ handler: () =\u003e {} }\u003e) { input?.handler(); } 类似的还有 MaybePromise、MaybeArray。 type MaybeArray\u003cT\u003e = T | T[]; function ensureArray\u003cT\u003e(input: MaybeArray\u003cT\u003e): T[] { return Array.isArray(input) ? input : [input]; } 另外，类型别名中可以接受任意个泛型，以及为泛型指定约束、默认值等。 交叉类型 它和联合类型的使用位置一样，只不过符号是 \u0026，即按位与运算符。 你需要符合这里的所有类型，才可以说实现了这个交叉类型，即 A \u0026 B，需要同时满足 A 与 B 两个类型才行。 声明一个交叉类型： interface NameStruct { name: string; } interface AgeStruct { age: number; } type ProfileStruct = NameStruct \u0026 AgeStruct; const profile: ProfileStruct = { name: \"wangxiaobai\", age: 18 } ProfileStruct 是一个同时包含 NameStruct 和 AgeStruct 两个接口所有属性的类型。 type StrAndNum = string \u0026 number; // never 原始类型的合并变成了 never。实际上，这也是 never 这一 BottomType 的实际意义之一，描述根本不存在的类型。 对于对象类型的交叉类型，其内部的同名属性类型同样会按照交叉类型进行合并： type Struct1 = { primitiveProp: string; objectProp: { name: string; } } type Struct2 = { primitiveProp: number; objectProp: { age: number; } } type Composed = Struct1 \u0026 Struct2; type PrimitivePropType = Composed['primitiveProp']; // never type ObjectPropType = Composed['objectProp']; // { name: string; age: number; } 两个联合类型组成的交叉类型，各实现两边联合类型中的一个就行了，也就是两边联合类型的交集： type UnionIntersection1 = (1 | 2 | 3) \u0026 (1 | 2); // 1 | 2 type UnionIntersection2 = (string | number | symbol) \u0026 string; // string 索引类型 索引类型包含三个部分：索引签名类型、索引类型查询与索引类型访问。 索引类型签名 指的是在接口或类型别名中，通过以下语法来快速声明一个键值类型一致的类型结构： interface AllStringTypes { [key: string]: string; } type AllStringTypes = { [key: string]: string; } 即使你还没声明具体的属性，对于这些类型结构的属性访问也将全部被视为 string 类型： interface AllStringTypes { [key: string]: string; } type PropType1 = AllStringTypes['wangxiaobai']; // string type PropType2 = AllStringTypes['18']; // string 这也意味着在实现这个类型结构的变量中只能声明字符串类型的键： interface AllStringTypes { [key: string]: string; } const foo: AllStringTypes = { \"wangxiaobai\": \"18\" } 索引签名类型也可以和具体的键值对类型声明并存，但这时这些具体的键值类型也需要符合索引签名类型的声明： interface AllStringTypes { // 类型“number”的属性“propA”不能赋给“string”索引类型“boolean”。 propA: number; [key: string]: boolean; } 这里的符合即指子类型，因此自然也包括联合类型： interface StringOrBooleanTypes { propA: number; propB: boolean; [key: string]: number | boolean; } 索引签名类型的一个常见场景是在重构 JavaScript 代码时，为内部属性较多的对象声明一个 any 的索引签名类型，以此来暂时支持对类型未明确属性的访问，并在后续一点点补全类型： interface AnyTypeHere { [key: string]: any; } const foo: AnyTypeHere['wangxiaobai'] = 'any value'; 索引类型查询 索引类型查询，也就是 keyof 操作符。它可以将对象中的所有键转换为对应字面量类型，然后再组合成联合类型。 interface Foo { wangxiaobai: 1, 18: 2 } type FooKeys = keyof Foo; // \"wangxiaobai\" | '18' 索引类型访问 在 Typescript 中可以通过类似 obj[expression] 的方式来动态访问一个对象属性，只不过这里的 expression 要换成类型。 interface NumberRecord { [key: string]: number; } type PropType = NumberRecord[string]; // number 更直观的例子是通过字面量类型来进行索引类型访问： interface Foo { propA: number; propB: boolean; } type PropAType = Foo['propA']; // number type PropBType = Foo['propB']; // boolean 这里的 ‘propA’ 和 ‘propB’ 都是字符串字面量类型，而不是一个 JavaScript 字符串值。索引类型查询的本质其实就是，通过键的字面量类型（‘propA’）访问这个键对应的键值类型（number）。 interface Foo { propA: number; propB: boolean; propC: string; } type PropTypeUnion = Foo[keyof Foo]; // string | number | boolean 使用字面量联合类型进行索引类型访问时，其结果就","date":"2023-03-01","objectID":"/ts/:2:1","tags":["第一技能"],"title":"Typescript 使用手册","uri":"/ts/"},{"categories":["Soul Dance"],"content":"🚇 上，🏃🏻 ‍时，搬 🧱 中……戴起耳机，就是你一个人的舞台！ 在这里，希望你能找到一首 BGM，来撑起你独一无二的内心戏！ “我们不喜欢做重复的事。但无论戴着头盔或创造一个新角色都把虚构与真实结合在一起，我们所做的非凡的事充满了欢乐。我们很高兴能回馈给群众。” 🤪 欢迎来到疯子的世界~，持续更新中… ","date":"2023-02-28","objectID":"/souldance/:0:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"Daft Punk - Harder, Better, Faster, Stronger 📌 ","date":"2023-02-28","objectID":"/souldance/:1:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"Daft Punk - Giorgio by Moroder 📌 ","date":"2023-02-28","objectID":"/souldance/:2:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"Michael Jackson - Heal The World 📌 ","date":"2023-02-28","objectID":"/souldance/:3:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"Vietsub - One Last Time ","date":"2023-02-28","objectID":"/souldance/:4:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"Jasmine Thompson - Let Her Go ","date":"2023-02-28","objectID":"/souldance/:5:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"BLUEY ROBINSON - SHOWGIRL ","date":"2023-02-28","objectID":"/souldance/:6:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"Outasight - The Wild Life ","date":"2023-02-28","objectID":"/souldance/:7:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"Charlie Wilson - Sugar.Honey.Ice.Tea ","date":"2023-02-28","objectID":"/souldance/:8:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"Elton John, Dua Lipa - Cold Heart ","date":"2023-02-28","objectID":"/souldance/:9:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"Dogg Master - Get Ready ","date":"2023-02-28","objectID":"/souldance/:10:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"Ichon - La Vie | A COLORS SHOW ","date":"2023-02-28","objectID":"/souldance/:11:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"L’Impératrice — Voodoo? ","date":"2023-02-28","objectID":"/souldance/:12:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"L’Impératrice — Hématome ","date":"2023-02-28","objectID":"/souldance/:13:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"L’Impératrice — SONATE PACIFIQUE ","date":"2023-02-28","objectID":"/souldance/:14:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"AURORA - Cure For Me ","date":"2023-02-28","objectID":"/souldance/:15:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"The Jackson 5 - I Want You Back ","date":"2023-02-28","objectID":"/souldance/:16:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"Sean Paul - No Lie ","date":"2023-02-28","objectID":"/souldance/:17:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"Jovan - That Kind Of Love ","date":"2023-02-28","objectID":"/souldance/:18:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"PREP - As It Was ","date":"2023-02-28","objectID":"/souldance/:19:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"Blxst - Chosen ","date":"2023-02-28","objectID":"/souldance/:20:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"GD\u0026TOP - Don’t Go Home ","date":"2023-02-28","objectID":"/souldance/:21:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"Tep No - Long Lost Sunday Morning ","date":"2023-02-28","objectID":"/souldance/:22:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"Cerrone - Move Me ","date":"2023-02-28","objectID":"/souldance/:23:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"DENKI SAMA - Moonlight Romance ","date":"2023-02-28","objectID":"/souldance/:24:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"Lazer Boomerang - Time To Pretend ","date":"2023-02-28","objectID":"/souldance/:25:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"Jessfield Park - The Shanghai Restoration Project ","date":"2023-02-28","objectID":"/souldance/:26:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"Insan3Lik3 - We Are The Robots ","date":"2023-02-28","objectID":"/souldance/:27:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"Emotional Oranges - West Coast Love ","date":"2023-02-28","objectID":"/souldance/:28:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"Claire Ridgely - Busy boy ","date":"2023-02-28","objectID":"/souldance/:29:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"Emotional Oranges - West Coast Love ","date":"2023-02-28","objectID":"/souldance/:30:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"Dabeull - Glitter Fonk ","date":"2023-02-28","objectID":"/souldance/:31:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"Logic - Beggin Lyrics ","date":"2023-02-28","objectID":"/souldance/:32:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"Funk LeBlanc - Toast to Life with Holland Greco ","date":"2023-02-28","objectID":"/souldance/:33:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"BoA - Only One ","date":"2023-02-28","objectID":"/souldance/:34:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"甘草片r - Free Loop ","date":"2023-02-28","objectID":"/souldance/:35:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"Austin Mahone - Better With You ","date":"2023-02-28","objectID":"/souldance/:36:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"펀치(Punch) - Another Day ","date":"2023-02-28","objectID":"/souldance/:37:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"Parcels ~ Overnight ","date":"2023-02-28","objectID":"/souldance/:38:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"DeJ Loaf - No Fear ","date":"2023-02-28","objectID":"/souldance/:39:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"Irma - I know ","date":"2023-02-28","objectID":"/souldance/:40:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"HONNE - no song without you ","date":"2023-02-28","objectID":"/souldance/:41:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"JORDANN - Café Speed ","date":"2023-02-28","objectID":"/souldance/:42:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"Jewelz Feat. Stine Bee – Last Night ","date":"2023-02-28","objectID":"/souldance/:43:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"Next Level Lyrics-A$ton Wyld ","date":"2023-02-28","objectID":"/souldance/:44:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"Bigg Robb - So Delicious ","date":"2023-02-28","objectID":"/souldance/:45:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"BLACKPINK - How You Like That ","date":"2023-02-28","objectID":"/souldance/:46:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"Fat Joe, Remy Ma - All The Way Up ","date":"2023-02-28","objectID":"/souldance/:47:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"Lucky Luke - Cooler Than Me ","date":"2023-02-28","objectID":"/souldance/:48:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"Chago Williams · Wilson Ramos - Im Going ","date":"2023-02-28","objectID":"/souldance/:49:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"SAFIA - Bye Bye ","date":"2023-02-28","objectID":"/souldance/:50:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"DJ Pablo - One B-Boy ","date":"2023-02-28","objectID":"/souldance/:51:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"Lady Gaga - Bloody Mary ","date":"2023-02-28","objectID":"/souldance/:52:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"DGTO - Some People Don’t Fall ","date":"2023-02-28","objectID":"/souldance/:53:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"Thelma Houston - If You Feel It ","date":"2023-02-28","objectID":"/souldance/:54:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"Dan + Shay, Justin Bieber - 10,000 Hours ","date":"2023-02-28","objectID":"/souldance/:55:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"Odyssey - Together 2014 Version ","date":"2023-02-28","objectID":"/souldance/:56:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"Tamia - Officially Missing You ","date":"2023-02-28","objectID":"/souldance/:57:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"安魂曲(Requiem) ","date":"2023-02-28","objectID":"/souldance/:58:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"YOASOBI - 群青 ","date":"2023-02-28","objectID":"/souldance/:59:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"請夏 (CHUNG HA) - 在那尽头的你 ","date":"2023-02-28","objectID":"/souldance/:60:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"赵雷 - 我记得 ","date":"2023-02-28","objectID":"/souldance/:61:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"叶斯淳 - 我曾遇到一束光 ","date":"2023-02-28","objectID":"/souldance/:62:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"郭顶 - 水星记 ","date":"2023-02-28","objectID":"/souldance/:63:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"告五人 - 好不容易 ","date":"2023-02-28","objectID":"/souldance/:64:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["Soul Dance"],"content":"DryJo - 凱迪拉克敞篷電動車 ","date":"2023-02-28","objectID":"/souldance/:65:0","tags":["Soul Dance"],"title":"你需要一首 BGM，来撑起你的内心戏","uri":"/souldance/"},{"categories":["画画"],"content":"这里是 “一个人的绘画馆”，画得不好，纯属娱乐 😝。 ","date":"2023-02-26","objectID":"/draw/:0:0","tags":["画画"],"title":"油画棒画成长之旅","uri":"/draw/"},{"categories":["画画"],"content":"2023年 ","date":"2023-02-26","objectID":"/draw/:1:0","tags":["画画"],"title":"油画棒画成长之旅","uri":"/draw/"},{"categories":["画画"],"content":"海 Jay 与海都给你。 ","date":"2023-02-26","objectID":"/draw/:1:1","tags":["画画"],"title":"油画棒画成长之旅","uri":"/draw/"},{"categories":["画画"],"content":"红尘悠悠 为遇一人而入红尘，人去我亦去，此处不留尘。 ","date":"2023-02-26","objectID":"/draw/:1:2","tags":["画画"],"title":"油画棒画成长之旅","uri":"/draw/"},{"categories":["画画"],"content":"一个人淋 🌧 季如梦，人生如梦，没有一刻想清醒。 ","date":"2023-02-26","objectID":"/draw/:1:3","tags":["画画"],"title":"油画棒画成长之旅","uri":"/draw/"},{"categories":["画画"],"content":"仰望 🌃 我们仰望着同一片星空，你可能在失神，而我努力在星空中寻找你的模样。 ","date":"2023-02-26","objectID":"/draw/:1:4","tags":["画画"],"title":"油画棒画成长之旅","uri":"/draw/"},{"categories":["画画"],"content":"窗台上的 🐱 下辈子做一只猫，翘着尾巴云游天下，跟狗打架。 ","date":"2023-02-26","objectID":"/draw/:1:5","tags":["画画"],"title":"油画棒画成长之旅","uri":"/draw/"},{"categories":["画画"],"content":"🐳 与 ☁️ 热爱漫无边际，生活自有分寸。 ","date":"2023-02-26","objectID":"/draw/:1:6","tags":["画画"],"title":"油画棒画成长之旅","uri":"/draw/"},{"categories":["画画"],"content":"露营 ⛺️ 一起去露营吧，揽星河入怀，拥山野而眠。 ","date":"2023-02-26","objectID":"/draw/:1:7","tags":["画画"],"title":"油画棒画成长之旅","uri":"/draw/"},{"categories":["画画"],"content":"福 🐰 贺春 新年快乐。 ","date":"2023-02-26","objectID":"/draw/:1:8","tags":["画画"],"title":"油画棒画成长之旅","uri":"/draw/"},{"categories":["cook"],"content":"🥰 就算一个人生活也要好好吃饭呀。 ","date":"2023-02-26","objectID":"/cook/:0:0","tags":["cook"],"title":"程序媛烟火气儿","uri":"/cook/"},{"categories":["cook"],"content":"2023年 ","date":"2023-02-26","objectID":"/cook/:1:0","tags":["cook"],"title":"程序媛烟火气儿","uri":"/cook/"},{"categories":["cook"],"content":"蔬菜鸡胸肉饼 ","date":"2023-02-26","objectID":"/cook/:1:1","tags":["cook"],"title":"程序媛烟火气儿","uri":"/cook/"},{"categories":["cook"],"content":"大拌菜 ","date":"2023-02-26","objectID":"/cook/:1:2","tags":["cook"],"title":"程序媛烟火气儿","uri":"/cook/"},{"categories":["cook"],"content":"菌菇乌鸡汤 ","date":"2023-02-26","objectID":"/cook/:1:3","tags":["cook"],"title":"程序媛烟火气儿","uri":"/cook/"},{"categories":["第一技能"],"content":"项目地址： SSR ","date":"2023-02-20","objectID":"/ssr/:0:0","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"搭建 Client 项目 ","date":"2023-02-20","objectID":"/ssr/:1:0","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"项目初始化 先对项目进行初始化，Nextjs 提供了脚手架来帮助初始化项目，执行下面的命令： npx create-next-app@latest --typescript next.config.js 是构建配置，底层是基于 Webpack 去打包的，在默认的配置上加上下面的配置来提供别名的能力： /** @type {import('next').NextConfig} */ const path = require(\"path\"); const nextConfig = { reactStrictMode: true, swcMinify: true, webpack: (config) =\u003e { config.resolve.alias = { ...config.resolve.alias, '@': path.resolve(__dirname), }; return config; }, }; module.exports = nextConfig tsconfig.json 中需要加一下对应的别名解析识别（baseurl , paths）。 { \"compilerOptions\": { \"target\": \"es5\", \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"], \"allowJs\": true, \"skipLibCheck\": true, \"strict\": true, \"forceConsistentCasingInFileNames\": true, \"noEmit\": true, \"esModuleInterop\": true, \"module\": \"esnext\", \"moduleResolution\": \"node\", \"resolveJsonModule\": true, \"isolatedModules\": true, \"jsx\": \"preserve\", \"incremental\": true, \"baseUrl\": \"./\", \"paths\": { \"@/*\": [\"./*\"] } }, \"include\": [\"next-env.d.ts\", \"**/*.ts\", \"**/*.tsx\"], \"exclude\": [\"node_modules\"] } 执行 npm run dev 注：如果出现以下错误，请将你的 node 版本升级到 18+。 打开 http://localhost:3000 就可以看到一个默认服务器端渲染页面: ","date":"2023-02-20","objectID":"/ssr/:1:1","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"代码 Lint Nextjs 内置了开箱的 eslint 能力，不需要自己进行相关配置，可以执行下面的脚本来自动生成对应的 lint。 npm run lint ","date":"2023-02-20","objectID":"/ssr/:1:2","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"模块化代码提示 使用 sass 等超类来替代 css，相比 css，sass 等超类提供了变量定义和函数的能力，可以避免一些重复的 css 代码，使样式的可维护性和复用性更高。 Nextjs 已经提供了对 css 和 sass 的支持，只需要安装一下 sass 的依赖即可: npm install sass --save-dev 针对一个大型项目，需要定义多级嵌套的组件来提高页面复用性，组件之间的样式命名很容易重复，针对非组件库的业务代码，通常会使用 css 模块化来进行相关的样式定义。 模块化会在编译的时候将样式的类名加上对应唯一的哈希值来进行区分，从而解决样式类名重复的问题。 Nextjs 已经内置了这部分能力，只需要将类名定义为 [name].module.scss。 import { FC } from 'react'; import styles from \"./index.module.scss\"; interface IProps {} export const Demo: FC\u003cIProps\u003e = ({}) =\u003e { return ( \u003cdiv className={styles.demo}\u003e \u003ch1 className={styles.title}\u003edemo\u003c/h1\u003e \u003c/div\u003e ) } ","date":"2023-02-20","objectID":"/ssr/:1:3","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"服务端调试能力 服务器渲染一个静态页面，请求会在服务端执行，将数据注入到页面中，意味着这部分逻辑并不在客户端执行，所以在服务端执行时，是不能直接用 Chrome 的 network 来调试，它只能调试直接在客户端执行的脚本。 Nextjs 也有内置相关的调试能力来帮助进行调试，只需要为 dev 命令加一个 –inspect 的 node option 就行。 首先来安装 cross-env 的依赖来支持跨平台的环境变量添加： npm install cross-env --save-dev 然后在 package.json 中，加一条 debugger 的命令： { \"scripts\": { \"dev\": \"next dev\", \"debugger\": \"cross-env NODE_OPTIONS='--inspect' next dev\" } } 执行 npm run debugger 重新打开 http://localhost:3000，可以看到一个绿色的 nodejs 的小图标，点开会打开一个新的 network，这个就是服务器端 server 的 network，服务器端执行的相关代码断点可以在上面进行调试。 ","date":"2023-02-20","objectID":"/ssr/:1:4","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"实现页面链路 主体上分为模板页面渲染、路由匹配和 header 修改三个模块，模板页面渲染是页面渲染的主要部分，包含了静态模板的生成和页面数据的注入，最后形成服务端返回的 HTML 文本。 ","date":"2023-02-20","objectID":"/ssr/:2:0","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"模板页面渲染 通用 layout web 应用的路由页面之间通常会有共同的页面元素，如页首、页尾。 对于这种页面，通常会定义对应的组件在入口文件中引用，这样所有的页面就都可以有相同的页面组件了，不在需要在每个页面中去单独调用。 在写页面之前，先安装类名库 classnames，它可以用函数式的方式来处理一些相对复杂的类场景，后续会有大量应用。 npm install classnames --save 页首组件 client/components/navbar/index.tsx import { FC } from 'react'; import styles from './index.module.scss'; import Image from 'next/image'; import LogoLight from '@/public/logo_light.png'; export interface INavBarProps {} const NavBar: FC\u003cINavBarProps\u003e = ({}) =\u003e { return ( \u003cdiv className={styles.navBar}\u003e \u003ca href=\"http://localhost:3000/\"\u003e \u003cImage src={LogoLight} alt=\"\" width={70} height={20} /\u003e \u003c/a\u003e \u003c/div\u003e ) } export default NavBar; client/components/navbar/index.module.scss .navBar { display: flex; align-items: center; justify-content: space-between; background-color: hsla(0,0%,100%,.5); backdrop-filter: blur(8px); width: 100%; height: 64px; position: sticky; top: 0; left: 0; padding: 20px 32px; z-index: 100; } next/image 内置的 Image 标签，相比平常的 img 标签，会根据导入的图像来确认宽高，从而规避累积布局移位 (CLS) 的问题，可以在布局阶段提前进行相关区域预留位置，而不是加载中再进行移位。 页尾组件 client/components/footer/index.tsx import { FC } from 'react'; import Image from 'next/image'; import PublicLogo from '@/public/public_logo.png'; import styles from './index.module.scss'; import classNames from 'classnames'; interface ILink { label: string; link?: string; } interface ILinkList { title: string; list: ILink[]; } interface IQRCode { image: string; text: string; } export interface IFooterProps { title: string; linkList: ILinkList[]; qrCode: IQRCode; copyRight: string; siteNumber: string; publicNumber: string; } const Footer: FC\u003cIFooterProps\u003e = ({ title, linkList, qrCode, copyRight, siteNumber, publicNumber, }) =\u003e { return ( \u003cdiv className={styles.footer}\u003e \u003cdiv className={styles.topArea}\u003e \u003ch1 className={styles.footerTitle}\u003e{title}\u003c/h1\u003e \u003cdiv className={styles.linkListArea}\u003e { linkList?.map((item, index) =\u003e { return ( \u003cdiv className={styles.linkArea} key={index}\u003e \u003cspan className={styles.title}\u003e{item?.title}\u003c/span\u003e \u003cdiv className={styles.links}\u003e { item?.list?.map((_item, _index) =\u003e { return ( \u003cdiv className={classNames({ [styles.link]: _item?.link, [styles.disabled]: !_item?.link, })} key={_index} onClick={(): void =\u003e { _item?.link \u0026\u0026 window.open( _item?.link, \"blank\", \"noopener=yes,noreferrer=yes\" ); }}\u003e {_item?.label} \u003c/div\u003e ) }) } \u003c/div\u003e \u003c/div\u003e ) }) } \u003c/div\u003e \u003c/div\u003e \u003cdiv className={styles.bottomArea}\u003e \u003cdiv className={styles.codeArea}\u003e \u003cdiv\u003e \u003cImage src={qrCode?.image} alt={qrCode?.text} width={56} height={56} /\u003e \u003c/div\u003e \u003cdiv className={styles.text}\u003e{qrCode?.text}\u003c/div\u003e \u003c/div\u003e \u003cdiv className={styles.numArea}\u003e \u003cspan\u003e{copyRight}\u003c/span\u003e \u003cspan\u003e{siteNumber}\u003c/span\u003e \u003cdiv className={styles.publicLogo}\u003e \u003cdiv className={styles.logo}\u003e \u003cImage src={PublicLogo} alt={publicNumber} width={20} height={20} /\u003e \u003c/div\u003e \u003cspan\u003e{publicNumber}\u003c/span\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e ) } export default Footer; client/components/footer/index.module.scss .footer { padding: 70px 145px; background-color: #f4f5f5; .topArea { display: flex; justify-content: space-between; .footerTitle { font-weight: 500; font-size: 36px; line-height: 36px; color: #333333; margin: 0; } .linkListArea { display: flex; .linkArea { display: flex; flex-direction: column; margin-left: 160px; .title { font-weight: 500; font-size: 14px; line-height: 20px; color: #333333; margin-bottom: 40px; } .links { display: flex; flex-direction: column; font-weight: 400; font-size: 14px; line-height: 20px; .link { color: #333333; cursor: pointer; margin-bottom: 24px; } .disabled { color: #666; cursor: not-allowed; margin-bottom: 24px; } } } } } .bottomArea { display: flex; justify-content: space-between; .codeArea { display: flex; flex-direction: column; .text { color: #666; } } .numArea { color: #666; display: flex; flex-direction: column; align-items: flex-end; font-weight: 400; font-size: 14px; line-height: 20px; span { margin-bottom: 12px; } .publicLogo { display: flex; .logo { margin-right: 4px; } } } } } layout 组件 client/components/layout/index.tsx import { FC } from 'reac","date":"2023-02-20","objectID":"/ssr/:2:1","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"数据注入 在 Nextjs 中实现数据注入的方式分别是 getStaticProps、getServerSideProps 和 getInitialProps。 getStaticProps：多用于静态页面的渲染，只会在生产中执行，不会在运行时再次调用，意味着它只能用于不常编辑的部分，每次调整都需要重新构建部署，官网信息的时效性比较敏感，只会有少部分应用到 getStaticProps，但这并不意味着它没用，在一些特殊的场景下会有奇效。 getServerSideProps：只会执行在服务器端，不会在客户端执行。因为这个特性，所以客户端的脚本打包会较小，相关数据不会有在客户端暴露的问题，相对更隐蔽安全，不过逻辑集中在服务器端处理，会加重服务器的负担，服务器成本也会更高。 getInitialProps(推荐)：初始化时，如果是服务器端路由，数据的注入会在服务器端执行，对 SEO 友好，在实际的页面操作中，相关的逻辑会在客户端 执行，从而减轻了服务器端的负担。 数据的注入都是针对页面的，也就是 pages 目录下，对组件进行数据注入是不支持的，所以应在页面中注入对应数据后再透传给页面组件。 _app.tsx 是所有页面的入口页面，所以其它页面的参数也需要透传下来，可以用内置的 App 对象来获取对应组件本身的 pageProps，不要直接覆盖，对于非入口页面的普通页面，直接加上业务逻辑就可以： import '@/styles/globals.css' import type { AppProps, AppContext } from 'next/app'; import App from 'next/app'; import type { ILayoutProps } from '@/components/layout'; import Layout from '@/components/layout'; import Code from '@/public/code.png'; const MyApp = (data: AppProps \u0026 ILayoutProps) =\u003e { const { Component, pageProps, navbarData, footerData } = data; return ( \u003cdiv\u003e \u003cLayout navbarData={navbarData} footerData={footerData}\u003e \u003cComponent {...pageProps} /\u003e \u003c/Layout\u003e \u003c/div\u003e ) } MyApp.getInitialProps = async (context: AppContext) =\u003e { const pageProps = await App.getInitialProps(context); return { ...pageProps, navbarData: {}, footerData: { title: \"Demo\", linkList: [ { title: \"技术栈\", list: [ { label: \"react\", }, { label: \"typescript\", }, { label: \"ssr\", }, { label: \"nodejs\", }, ], }, { title: \"了解更多\", list: [ { label: \"掘金\", link: \"https://juejin.cn\", }, { label: \"知乎\", link: \"https://www.zhihu.com\", }, { label: \"csdn\", }, ], }, { title: \"联系我\", list: [{ label: \"微信\" }, { label: \"QQ\" }], }, ], qrCode: { image: Code, text: \"王小白学前端\", }, copyRight: \"Copyright © 2023 xxx. 保留所有权利\", siteNumber: \"冀ICP备XXXXXXXX号-X\", publicNumber: \"冀公网安备 xxxxxxxxxxxxxx号\", } } } export default MyApp; ","date":"2023-02-20","objectID":"/ssr/:2:2","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"路由匹配 Nextjs 的路由不同于一般使用的路由，它没有对应的文件去配置对应的路由，会根据相对 pages 的目录路径来生成对应的路由，如： // ./pages/home/index.tsx =\u003e /home // ./pages/demo/[id].tsx =\u003e /demo/:id 创建一个 article 目录来试验一下对应的文件路由，针对文章路由，给它加一个 articleId 参数来区分不同文章： pages/article/[articleId].tsx import type { NextPage } from 'next'; interface IArticleProps { articleId: number; } const Article: NextPage\u003cIArticleProps\u003e = ({ articleId }) =\u003e { return ( \u003cdiv\u003e \u003ch1\u003e文章{articleId}\u003c/h1\u003e \u003c/div\u003e ) } Article.getInitialProps = (context) =\u003e { const { articleId } = context.query; return { articleId: Number(articleId), } } export default Article; 把首页默认的 index.tsx 进行改造一下，把链接指到定义的文章路由: pages/index.tsx import type { NextPage } from 'next'; import styles from '@/styles/Home.module.scss'; interface IHomeProps { title: string; description: string; list: { label: string; info: string; link: string; }[]; } const Home: NextPage\u003cIHomeProps\u003e = ({ title, description, list }) =\u003e { return ( \u003cdiv className={styles.container}\u003e \u003cmain className={styles.main}\u003e \u003ch1 className={styles.title}\u003e{title}\u003c/h1\u003e \u003cp className={styles.description}\u003e{description}\u003c/p\u003e \u003cdiv className={styles.grid}\u003e { list?.map((item, index) =\u003e { return ( \u003cdiv key={index} className={styles.card} onClick={(): void =\u003e { window.open( item?.link, \"blank\", \"noopener=yes,noreferrer=yes\" ); }}\u003e \u003ch2\u003e{item?.label}\u003c/h2\u003e \u003cp\u003e{item?.info}\u003c/p\u003e \u003c/div\u003e ) }) } \u003c/div\u003e \u003c/main\u003e \u003c/div\u003e ) } Home.getInitialProps = (context) =\u003e { return { title: \"Hello SSR!\", description: \"A Demo for 官网开发实战\", list: [ { label: \"文章1\", info: \"A test for article1\", link: \"http://localhost:3000/article/1\", }, { label: \"文章2\", info: \"A test for article2\", link: \"http://localhost:3000/article/2\", }, { label: \"文章3\", info: \"A test for article3\", link: \"http://localhost:3000/article/3\", }, { label: \"文章4\", info: \"A test for article4\", link: \"http://localhost:3000/article/4\", }, { label: \"文章5\", info: \"A test for article5\", link: \"http://localhost:3000/article/5\", }, { label: \"文章6\", info: \"A test for article6\", link: \"http://localhost:3000/article/6\", }, ], }; } export default Home; styles/Home.module.scss // ./pages/index.module.scss .container { padding: 0 2rem; } .main { min-height: 100vh; padding: 4rem 0; flex: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; } .footer { display: flex; flex: 1; padding: 2rem 0; border-top: 1px solid #eaeaea; justify-content: center; align-items: center; } .footer a { display: flex; justify-content: center; align-items: center; flex-grow: 1; } .title a { color: #0070f3; text-decoration: none; } .title a:hover, .title a:focus, .title a:active { text-decoration: underline; } .title { margin: 0; line-height: 1.15; font-size: 4rem; } .title, .description { text-align: center; } .description { margin: 4rem 0; line-height: 1.5; font-size: 1.5rem; } .code { background: #fafafa; border-radius: 5px; padding: 0.75rem; font-size: 1.1rem; font-family: Menlo, Monaco, Lucida Console, Liberation Mono, DejaVu Sans Mono, Bitstream Vera Sans Mono, Courier New, monospace; } .grid { display: flex; align-items: center; justify-content: center; flex-wrap: wrap; max-width: 800px; } .card { margin: 1rem; padding: 1.5rem; text-align: left; color: inherit; text-decoration: none; border: 1px solid #eaeaea; border-radius: 10px; transition: color 0.15s ease, border-color 0.15s ease; max-width: 300px; cursor: pointer; } .card:hover, .card:focus, .card:active { color: #0070f3; border-color: #0070f3; } .card h2 { margin: 0 0 1rem 0; font-size: 1.5rem; } .card p { margin: 0; font-size: 1.25rem; line-height: 1.5; } .logo { height: 1em; margin-left: 0.5rem; } 使用 window.open 打开新页面来指向上文创建的文章页，noopener=yes,noreferrer=yes 是为了跳转的安全性，这个可以隐藏跳转的 window.opener 与 Document.referrer，在跨站点跳转中，通常加这个参数来保证跳转信息的不泄露。 访问 http://localhost:3000/: ","date":"2023-02-20","objectID":"/ssr/:2:3","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"header 修改 Nextjs 提供了用 next/head 暴露出来的标签来修改 header，在 _app.tsx 加一个默认的 title。 import '@/styles/globals.css' import type { AppProps, AppContext } from 'next/app'; import App from 'next/app'; import Head from 'next/head'; import type { ILayoutProps } from '@/components/layout'; import Layout from '@/components/layout'; import Code from '@/public/code.png'; const MyApp = (data: AppProps \u0026 ILayoutProps) =\u003e { const { Component, pageProps, navbarData, footerData } = data; return ( \u003cdiv\u003e \u003cHead\u003e \u003ctitle\u003eA Demo for 官网开发实战\u003c/title\u003e \u003cmeta name=\"description\" content=\"A Demo for 官网开发实战\" /\u003e \u003clink rel=\"icon\" href=\"/favicon.ico\" /\u003e \u003c/Head\u003e \u003cLayout navbarData={navbarData} footerData={footerData}\u003e \u003cComponent {...pageProps} /\u003e \u003c/Layout\u003e \u003c/div\u003e ) } MyApp.getInitialProps = async (context: AppContext) =\u003e { const pageProps = await App.getInitialProps(context); return { ...pageProps, navbarData: {}, footerData: { title: \"Demo\", linkList: [ { title: \"技术栈\", list: [ { label: \"react\", }, { label: \"typescript\", }, { label: \"ssr\", }, { label: \"nodejs\", }, ], }, { title: \"了解更多\", list: [ { label: \"掘金\", link: \"https://juejin.cn\", }, { label: \"知乎\", link: \"https://www.zhihu.com\", }, { label: \"csdn\", }, ], }, { title: \"联系我\", list: [{ label: \"微信\" }, { label: \"QQ\" }], }, ], qrCode: { image: Code, text: \"王小白学前端\", }, copyRight: \"Copyright © 2023 xxx. 保留所有权利\", siteNumber: \"冀ICP备XXXXXXXX号-X\", publicNumber: \"冀公网安备 xxxxxxxxxxxxxx号\", } } } export default MyApp; ","date":"2023-02-20","objectID":"/ssr/:2:4","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"搭建 Server 项目 这里推荐使用 Strapi，这是一个开源无头的 CMS 配置 Api。基于 Strapi ，可以快速针对业务场景搭建一套对应的 CMS，包括增删改查和联表等较复杂场景，都可以通过可视化的配置实现。 对于自定义较高的场景，它也暴露了相关的参数进行自定义，可以使用较少的开发量去实现特殊场景。 ","date":"2023-02-20","objectID":"/ssr/:3:0","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"项目初始化 执行 Strapi 提供的脚手架命令来初始化项目: npx create-strapi-app server --quickstart 它会在当前目录生成名为 server 的项目，并且会自动运行并打开一个登录页，按照指示配置一下账号密码，然后登录。 ","date":"2023-02-20","objectID":"/ssr/:3:1","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"数据可视化配置 结构体定义 完成登录后，进入到 Strapi 的管理页面。 content manager 是 Api 的数据 content-type builder 是 Api 的结构体 以上一章节 layout 下的静态数据举例： footerData: { title: \"Demo\", linkList: [ { title: \"技术栈\", list: [ { label: \"react\", }, { label: \"typescript\", }, { label: \"ssr\", }, { label: \"nodejs\", }, ], }, { title: \"了解更多\", list: [ { label: \"掘金\", link: \"https://juejin.cn\", }, { label: \"知乎\", link: \"https://www.zhihu.com\", }, { label: \"csdn\", }, ], }, { title: \"联系我\", list: [{ label: \"微信\" }, { label: \"QQ\" }], }, ], qrCode: { image: Code, text: \"王小白学前端\", }, copyRight: \"Copyright © 2023 xxx. 保留所有权利\", siteNumber: \"冀ICP备XXXXXXXX号-X\", publicNumber: \"冀公网安备 xxxxxxxxxxxxxx号\", } 针对这样一个结构体，应该如何去定义 Api 呢？ 切到 content-type builder，点击 create new collection type，创建一个新的结构体： 填完 display name 后，对应的单数和复数 id 会自动生成，就是右边的两项，name 填需要的结构体就可以。 然后为结构体创建一些字段，常见的类型包括文本、boolean 值、富文本，这些这里都有，以 title 举例，因为是一个字符串，所以点 text。 直接用短文本就好，然后高级配置选必填和唯一。 对应的字段就加好了，对于别的部分，用相同的方式加进来就可以。 稍微特殊一些的字段是 linkList，可以看到它其实是一个对象数组，先把 footData 的关系按照思维导图梳理一下。 按照数据结构发现，footerData 和 linkList 是一对多的关系，而 linklist 中又包含多个 link，也是一对多的关系。 所以要描述这部分字段，只有 layout 一个结构体是不够的，需要创建 linkList 和 link，然后给它们之间来建立对应的关系。 确定了思路，按照上面的方法来创建 linklist 和 link 的结构体。 linklist 和 link 的关系应该怎么建立呢？在 linklist 结构体中，点新建字段。 点击 relation 属性，这个属性用来联立结构体之间的数据库关系。 点完成，可以发现加上了。 接下来，按照上面的原理配置完所有的结构体即可。 结构体数据写入 定义完结构体后，需要为结构体加入一些数据，通常在开发完后，运营相关的同学配置，就只要进行这一步就可以了，别的部分就不需要再调整了，点击 content manager。 数据的配置需要按照从子到父的原则，因为 layout 有相关的字段依赖于 linklist，linklist 又依赖于 link，所以只有 link 配置完以后，才可以进行 linklist 和 layout 的配置，这里以 link 和 linklist 举例。 切到 link 的部分，点击 create new entry，可以进到下面的页面，输入完内容以后，进行保存，这里保存有两个按钮，一个是 save，一个是 publish，如果点击 publish 会生效到实际 cdn，这里先点击 publish，实际场景下运营配置的时候可以点 save，在 review 没问题后再发布即可。 配置完大致是这样的： 然后配置 linklist 的部分，同样是点 create new entry。 除了基本的字段，右侧还会有对应关联的字段，勾选需要的就可以关联上了。 最后配置 layout 的部分。 权限配置及上线 点击 settings -\u003e Roles，这里是权限配置的部分，包含作者权限和公共权限，因为需要所有的人可以看到接口，所以点 public 右侧的 🖊（如果有特别需求的同学，可以点击 add new role 新增权限角色，再进行后续的步骤。 可以看到之前定义的结构体，左侧对应结构体支持的类型，右侧对应结构体接口的指向 Api 路由。因为要给对应的接口配置全查和单查的能力，所以勾选上 find 和 findOne。 layout 依赖于 link 和 link-list，所以 link 和 link-list 的结构体也需勾选上 find 和 findOne。 访问 http://localhost:1337/api/layouts： 你会发现好像只有基础字段，联表的 linklist 和 link 去哪里了？ 这是因为 Strapi 默认是不会填充联表关系的，可以在路由后加 populate=*，这个入参的意义是为所有的关系填充一级关系。 推荐使用 strapi-plugin-populate-deep，这是基于 Strapi 的一个深度插件，切到项目目录下的终端安装一下。 npm install strapi-plugin-populate-deep --save 重启，访问 http://localhost:1337/api/layouts?populate=deep。 deep 参数的含义为使用默认的最大深度填充请求，即 5 层，如果 5 层不满足需求，需要更多，入参的调整也很方便，比如针对 10 层的场景，只需要传递入参 populate=deep,10就可以。 ","date":"2023-02-20","objectID":"/ssr/:3:2","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"BFF 数据流转 通过访问 http://localhost:1337/api/layouts?populate=deep 可以拿到需要的数据。 不过这样的数据是有一些乱的，有几个可以优化的点： 请求参数 populate=deep 是每次请求都需要带上的，因为需要所有深度的数据。 最终需要的是 data 中的数据，layout 只有一个，不需要分页相关的部分（meta）。 针对每个结构体，Strapi 为它们套上了 attributes 和 id，这个是不利于调用的，因为没有覆盖对应 ts 类型，会增加很多不必要的调试成本。 每个结构体都加上了 createdAt、 publishedAt、updatedAt 三个字段，实际上是不需要这些字段的，随着接口层级的增加，过多不被使用的字段会增加接口的复杂度和可维护性。 ","date":"2023-02-20","objectID":"/ssr/:4:0","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"CMS 接口优化 自定义返回 在 src/api/* 的目录下，存放着结构体接口的定义，其中 controllers 存放着接口的控制器，每当客户端请求路由时，操作都会执行业务逻辑代码并发回响应，可以在其中重写 api 的相关方法（find、findOne、 update 等）。 以 layout 为例，首先为 layout 接口加上默认的 populate=deep 参数，这样每次请求的时候就不用再加了。 src/api/layout/controllers/layout.js const { createCoreController } = require(\"@strapi/strapi\").factories; module.exports = createCoreController(\"api::layout.layout\", ({ strapi }) =\u003e ({ async find(ctx) { ctx.query = { ...ctx.query, populate: \"deep\", }; const { data } = await super.find(ctx); return data; }, })); 访问 http://localhost:1337/api/layouts，可以看到不需要加 populate 参数就可以拿到联表的数据了。 然后针对上面提到的 attributes、id 和时间相关的字段定义两个深度遍历的函数来对应去除。 新建 src/utils/index.js /** * 移除对象中自动创建的时间字段 * @param obj * @returns */ const removeTime = (obj) =\u003e { const { createdAt, publishedAt, updatedAt, ...params } = obj || {}; Object.getOwnPropertyNames(params).forEach((item) =\u003e { if (typeof params[item] === \"object\") { if (Array.isArray(params[item])) { params[item] = params[item].map((item) =\u003e { return removeTime(item); }); } else { params[item] = removeTime(params[item]); } } }); return params; }; /** * 移除属性和id * @param {*} obj * @returns */ const removeAttrsAndId = (obj) =\u003e { const { attributes, id, ...params } = obj || {}; const newObj = { ...attributes, ...params }; Object.getOwnPropertyNames(newObj).forEach((item) =\u003e { if (typeof newObj[item] === \"object\") { if (Array.isArray(newObj[item])) { newObj[item] = newObj[item].map((item) =\u003e { return removeAttrsAndId(item); }); } else { newObj[item] = removeAttrsAndId(newObj[item]); } } }); return newObj; }; module.exports = { removeTime, removeAttrsAndId, }; 然后对 layout 的 find 函数返回的数据调用进行处理。 'use strict'; /** * layout controller */ const { removeTime, removeAttrsAndId } = require('../../../utils/index'); const { createCoreController } = require('@strapi/strapi').factories; module.exports = createCoreController('api::layout.layout', ({ strapi }) =\u003e ({ async find(ctx) { ctx.query = { ...ctx.query, populate: 'deep', }; const { data } = await super.find(ctx); return removeAttrsAndId(removeTime(data[0])); } })); 再访问 http://localhost:1337/api/layouts，可以只包含了需要的数据。 增加跨域限制 Strapi 的接口默认不做跨域限制，这样所有的域名都可以调用，安全性是存在问题的。 在 config/middlewares.js 中加上跨域的限制。 module.exports = [ 'strapi::errors', 'strapi::security', { name: 'strapi::cors', config: { enabled: true, headers: '*', origin: ['http://localhost:3000', 'http://localhost:1337'], }, }, 'strapi::poweredBy', 'strapi::logger', 'strapi::query', 'strapi::body', 'strapi::session', 'strapi::favicon', 'strapi::public', ]; ","date":"2023-02-20","objectID":"/ssr/:4:1","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"BFF 接口定义 接口配置好以后还不能直接在页面中调用，需要配置一层 BFF 层，即服务于前端的数据层。 因为通常配置的数据是站在结构体的角度的，并不一定可以由前端调用，往往还需要复杂的数据处理。 为了提高数据层的复用程度，增加 BFF 层，将接口包一层，进行相关处理后，前端页面只调用定义的 BFF 层接口，不直接与配置的接口产生交互。 在定义接口前，先来了解一下 Nextjs 接口的路由是怎么配置的? 与静态页面类似，Nextjs 接口也采用文件约定式路由的方式进行配置，可以分为预定义路由、动态路由和全捕获路由，如下面的例子： // ./pages/api/home/test.js =\u003e api/home/test 预定义路由 // ./pages/api/home/[testId].js =\u003e api/home/test, api/home/1, api/home/23 动态路由 // ./pages/api/home/[...testId].js =\u003e api/home/test, api/home/test/12 全捕获路由 如果一个相同的路由，比如 api/home/test，按照优先级来匹配三者，会按照预定义路由 \u003e 动态路由 \u003e 全捕获路由的顺序来匹配。 预定义路由是精准匹配，后两者只是模糊匹配，虽然也满足匹配场景，但是只是作为兜底，优先会以预定义路由为准。 下面来开发 BFF 层，首先定义一个接口层 pages/api/layout.ts。 因为会经常用到本地域名 和 CMS 域名，所以拿一个变量来存储它们，后续根据环境区分也很方便。 utils/index.ts export const LOCALDOMAIN = 'http://127.0.0.1:3000'; export const CMSDOMAIN = 'http://127.0.0.1:1337'; 安装 axios 和 lodash。 npm i axios npm i lodash npm i --save-dev @types/lodash 使用过 Express 的人应该知道中间件的概念，Express 是基于路由和中间件的框架，通过链式调用的方式来对接口进行一些统一的处理。 开源社区有开发提供了 next-connect 的依赖来补全这部分的能力，先来安装一下依赖。 npm install next-connect pages/api/layout.ts import axios from 'axios'; import nextConnect from 'next-connect'; import type { NextApiRequest, NextApiResponse } from 'next'; import { ILayoutProps } from '@/components/layout'; import { CMSDOMAIN } from '@/utils'; import { isEmpty } from 'lodash'; const getLayoutData = nextConnect() // .use(any middleware) .get((req: NextApiRequest, res: NextApiResponse\u003cILayoutProps\u003e) =\u003e { axios.get(`${CMSDOMAIN}/api/layouts`).then(result =\u003e { const { copy_right, link_lists, public_number, qr_code, qr_code_image, site_number, title, } = result?.data || {}; res?.status(200).json({ navbarData: {}, footerData: { title, linkList: link_lists?.data?.map((item: any) =\u003e { return { title: item.title, list: item?.links?.data?.map((_item: any) =\u003e { return { label: _item.label, link: isEmpty(_item.link) ? '' : _item.link, }; }), }; }), qrCode: { image: `${CMSDOMAIN}${qr_code_image.data.url}`, text: qr_code, }, copyRight: copy_right, siteNumber: site_number, publicNumber: public_number, }, }) }) }) export default getLayoutData; NextApiResponse 类型是 Nextjs 提供的 response 类型，它提供了一个泛型，来作为整个接口和后续请求的返回，可以把需要的数据类型作为泛型传进去，保证整体代码有 ts 的 lint。 返回数据用的是 json，针对数据的响应，Nextjs 提供下面的响应 Api，可以根据自己的需求选用不同的响应 Api。 res.status(code) - 设置状态码的功能。code 必须是有效的 HTTP 状态码。 res.json(body) - 发送 JSON 响应。body 必须是可序列化的对象。 res.send(body) - 发送 HTTP 响应。body 可以是 a string，an object 或 a Buffer。 res.redirect([status,] path) - 重定向到指定的路径或 URL。status 必须是有效的 HTTP 状态码。如果未指定，status 默认为 “307” “临时重定向”。 res.revalidate(urlPath) - 使用 . 按需重新验证页面 getStaticProps。urlPath 必须是一个 string。 改造 layout 部分的数据注入，换用接口数据。 import type { AppProps, AppContext } from 'next/app'; import App from 'next/app'; import Head from 'next/head'; import axios from 'axios'; import { LOCALDOMAIN } from '@/utils'; import type { ILayoutProps } from '@/components/layout'; import Layout from '@/components/layout'; import '@/styles/globals.css' const MyApp = (data: AppProps \u0026 ILayoutProps) =\u003e { const { Component, pageProps, navbarData, footerData } = data; return ( \u003cdiv\u003e \u003cHead\u003e \u003ctitle\u003eA Demo for 官网开发实战\u003c/title\u003e \u003cmeta name=\"description\" content=\"A Demo for 官网开发实战\" /\u003e \u003clink rel=\"icon\" href=\"/favicon.ico\" /\u003e \u003c/Head\u003e \u003cLayout navbarData={navbarData} footerData={footerData}\u003e \u003cComponent {...pageProps} /\u003e \u003c/Layout\u003e \u003c/div\u003e ) } MyApp.getInitialProps = async (context: AppContext) =\u003e { const pageProps = await App.getInitialProps(context); const { data = {} } = await axios.get(`${LOCALDOMAIN}/api/layout`) return { ...pageProps, ...data, } } export default MyApp; 访问 http://localhost:3000。 ","date":"2023-02-20","objectID":"/ssr/:4:2","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"主题化功能 以 抖音前端技术官网 为例，它的官网有包含默认的样式： 也有暗黑色调的展示： ","date":"2023-02-20","objectID":"/ssr/:5:0","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"基础色调变量抽离 主题化功能对 DOM 的结构变化不大，基本是针对色调进行切换。 顺着这个思路，如果定义两套变量，是不是就完成了对两套主题的配置？根据不同的主题，在 html 标签上来固定两个属性来区分，方案就确定了。 在全局样式中定义两套之前使用到的色调，包括字体和背景等颜色，把之前定义的组件样式抽出来放在这里就可以，保证所有的色调都通过变量的方式来引用。 styles/global.css html[data-theme=\"dark\"] { --primary-color: #ffffff; --primary-background-color: rgba(14, 14, 14, 1); --footer-background-color: rgba(36, 36, 36, 1); --navbar-background-color: rgba(0, 0, 0, 0.5); --secondary-color: rgba(255, 255, 255, 0.5); --link-color: #34a8eb; } html[data-theme=\"light\"] { --primary-color: #333333; --primary-background-color: rgba(255, 255, 255, 1); --footer-background-color: #f4f5f5; --navbar-background-color: rgba(255, 255, 255, 0.5); --secondary-color: #666666; --link-color: #0070f3; } 接下来就是把这些定义的变量去替换原来样式中给的固定色值。 components/footer/index.module.scss .footer { padding: 70px 145px; background-color: var(--footer-background-color); .topArea { display: flex; justify-content: space-between; .footerTitle { font-weight: 500; font-size: 36px; line-height: 36px; color: var(--primary-color); margin: 0; } .linkListArea { display: flex; .linkArea { display: flex; flex-direction: column; margin-left: 160px; .title { font-weight: 500; font-size: 14px; line-height: 20px; color: var(--primary-color); margin-bottom: 40px; } .links { display: flex; flex-direction: column; font-weight: 400; font-size: 14px; line-height: 20px; .link { color: var(--primary-color); cursor: pointer; margin-bottom: 24px; } .disabled { color: var(--secondary-color); cursor: not-allowed; margin-bottom: 24px; } } } } } .bottomArea { display: flex; justify-content: space-between; .codeArea { display: flex; flex-direction: column; .text { color: var(--secondary-color); } } .numArea { color: var(--secondary-color); display: flex; flex-direction: column; align-items: flex-end; font-weight: 400; font-size: 14px; line-height: 20px; span { margin-bottom: 12px; } .publicLogo { display: flex; .logo { margin-right: 4px; } } } } } components/layout/index.module.scss .layout { background-color: var(--primary-background-color); .main { min-height: calc(100vh - 560px); } } components/navbar/index.module.scss .navBar { display: flex; align-items: center; justify-content: space-between; background-color: var(--navbar-background-color); backdrop-filter: blur(8px); width: 100%; height: 64px; position: sticky; top: 0; left: 0; padding: 20px 32px; z-index: 100; .logoIcon { width: 4.375rem; height: 1.25rem; background-image: var(--navbar-icon); background-size: 4.375rem 1.25rem; background-repeat: no-repeat; } .themeIcon { width: 1.25rem; height: 1.25rem; background-image: var(--theme-icon); background-size: 1.25rem 1.25rem; background-repeat: no-repeat; cursor: pointer; } } ","date":"2023-02-20","objectID":"/ssr/:5:1","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"图片主题化配置 对于图片的主题化，有两种方式，一种是针对一般固定不变的图片，采用同样定义的方式。 styles/global.css html[data-theme=\"dark\"] { --primary-color: #ffffff; --primary-background-color: rgba(14, 14, 14, 1); --footer-background-color: rgba(36, 36, 36, 1); --navbar-background-color: rgba(0, 0, 0, 0.5); --secondary-color: rgba(255, 255, 255, 0.5); --link-color: #34a8eb; --navbar-icon: url('../public/logo_dark.png'); --theme-icon: url('../public/theme_dark.png'); } html[data-theme=\"light\"] { --primary-color: #333333; --primary-background-color: rgba(255, 255, 255, 1); --footer-background-color: #f4f5f5; --navbar-background-color: rgba(255, 255, 255, 0.5); --secondary-color: #666666; --link-color: #0070f3; --navbar-icon: url('../public/logo_light.png'); --theme-icon: url('../public/theme_light.png'); } 另一种是配置的图片，可能会频繁变化，这种只需要在 Strapi 中再加一个字段存不同主题的图片，然后在页面逻辑中根据不同的主题去切换就可以。 ","date":"2023-02-20","objectID":"/ssr/:5:2","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"主题数据注入 针对当前的主题，肯定有个地方需要进行缓存，应该使用哪种客户端缓存机制呢？ 主题化功能往往是因为用户更喜欢这种色调，用 localStorage 要更合适，因为相比 sessionStorage 只能保存当前会话的特点，localStorage 可以长期保留，除非用户主动清除，保证下一次访问时也可以保证是之前的主题。 那么应该怎么去注入这个缓存呢，如果随心所欲地去进行缓存注入操作，那页面中可能会分散各种缓存的逻辑，不符合单一职责原则，也不利于统一的维护和相关事件的绑定，所以需要在一处地方聚集主题相关的逻辑，然后再分别注入给每个页面对应的编辑方法。 这里需要用到 React 的 useContext，它具有接受上下文，并将上下文进行注入的能力。 新建 constants/enum export enum Themes { light = 'light', dark = 'dark', } 新建 stores/theme.tsx import {createContext, FC, useEffect, useState} from 'react'; import {Themes} from '@/constants/enum'; interface IThemeContextProps { theme: Themes; setTheme: (theme: Themes) =\u003e void; } interface IThemeContextProviderProps { children: JSX.Element; } export const ThemeContext = createContext\u003cIThemeContextProps\u003e({} as IThemeContextProps); const ThemeContextProvider: FC\u003cIThemeContextProviderProps\u003e = ({children}) =\u003e { const [theme, setTheme] = useState\u003cThemes\u003e(Themes.light); useEffect(() =\u003e { const item = localStorage.getItem('theme') as Themes || Themes.light; setTheme(item); document.getElementsByTagName('html')[0].dataset.theme = item; }, []); return ( \u003cThemeContext.Provider value={{ theme, setTheme: (currentTheme) =\u003e { setTheme(currentTheme); localStorage.setItem('theme', currentTheme); document.getElementsByTagName('html')[0].dataset.theme = currentTheme; } }}\u003e {children} \u003c/ThemeContext.Provider\u003e ) } export default ThemeContextProvider; ThemeContext 是暴露出的变量，在全局注入后，每个路由页面都可以通过它来获取定义的 theme 和 setTheme 进行相关的业务操作。 ThemeContextProvider 则是注入器，用于给需要的 DOM 进行上下文的注入。 在全局页面注入 context。 pages/_app.tsx import type { AppProps, AppContext } from 'next/app'; import App from 'next/app'; import Head from 'next/head'; import axios from 'axios'; import ThemeContextProvider from '@/stores/theme'; import { LOCALDOMAIN } from '@/utils'; import type { ILayoutProps } from '@/components/layout'; import Layout from '@/components/layout'; import '@/styles/globals.css' const MyApp = (data: AppProps \u0026 ILayoutProps) =\u003e { const { Component, pageProps, navbarData, footerData } = data; return ( \u003cdiv\u003e \u003cHead\u003e \u003ctitle\u003eA Demo for 官网开发实战\u003c/title\u003e \u003cmeta name=\"description\" content=\"A Demo for 官网开发实战\" /\u003e \u003clink rel=\"icon\" href=\"/favicon.ico\" /\u003e \u003c/Head\u003e \u003cThemeContextProvider\u003e \u003cLayout navbarData={navbarData} footerData={footerData}\u003e \u003cComponent {...pageProps} /\u003e \u003c/Layout\u003e \u003c/ThemeContextProvider\u003e \u003c/div\u003e ) } MyApp.getInitialProps = async (context: AppContext) =\u003e { const pageProps = await App.getInitialProps(context); const { data = {} } = await axios.get(`${LOCALDOMAIN}/api/layout`) return { ...pageProps, ...data, } } export default MyApp; 在 navbar 加一个主题化切换的入口。 components/navbar/index.tsx import {FC, useContext} from 'react'; import {ThemeContext} from '@/stores/theme'; import {Themes} from '@/constants/enum'; import styles from './index.module.scss'; export interface INavBarProps {} const NavBar: FC\u003cINavBarProps\u003e = ({}) =\u003e { const { setTheme } = useContext(ThemeContext); return ( \u003cdiv className={styles.navBar}\u003e \u003ca href=\"http://localhost:3000/\"\u003e \u003cdiv className={styles.logoIcon} /\u003e \u003c/a\u003e \u003cdiv className={styles.themeIcon} onClick={(): void =\u003e { setTheme(localStorage.getItem('theme') === Themes.light ? Themes.dark : Themes.light); }}/\u003e \u003c/div\u003e ) } export default NavBar; components/navbar/index.module.scss .navBar { display: flex; align-items: center; justify-content: space-between; background-color: var(--navbar-background-color); backdrop-filter: blur(8px); width: 100%; height: 64px; position: sticky; top: 0; left: 0; padding: 20px 32px; z-index: 100; .logoIcon { width: 4.375rem; height: 1.25rem; background-image: var(--navbar-icon); background-size: 4.375rem 1.25rem; background-repeat: no-repeat; } .themeIcon { width: 1.25rem; height: 1.25rem; background-image: var(--theme-icon); background-size: 1.25rem 1.25rem; background-repeat: no-repeat; cursor: pointer; } } 启动项目，可以看到已经可以实现主题化的功能了。 ","date":"2023-02-20","objectID":"/ssr/:5:3","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"多进程场景下主题同步 浏览器是多进程的，每个开启的页面都对应到一个进程，这样可以有效地避免页面之间的数据共享及一个报错页面带崩所有页面的情况。 如果用户开了多个页面来访问站点，其中一个页面的主题切换，另一个页面是感知不到的，这样一个浏览器下会有多个主题的页面，对用户体验上来说是不太好的。 出于追求极致考虑，优化一下这个问题，其实也很简单，只需要监听浏览器的缓存修改事件，然后再次执行初始化的操作就好了。 stores/theme.tsx import {createContext, FC, useEffect, useState} from 'react'; import {Themes} from '@/constants/enum'; interface IThemeContextProps { theme: Themes; setTheme: (theme: Themes) =\u003e void; } interface IThemeContextProviderProps { children: JSX.Element; } export const ThemeContext = createContext\u003cIThemeContextProps\u003e({} as IThemeContextProps); const ThemeContextProvider: FC\u003cIThemeContextProviderProps\u003e = ({children}) =\u003e { const [theme, setTheme] = useState\u003cThemes\u003e(Themes.light); useEffect(() =\u003e { debugger const checkTheme = () =\u003e { const item = localStorage.getItem('theme') as Themes || Themes.light; setTheme(item); document.getElementsByTagName('html')[0].dataset.theme = item; } // 初始化先执行一遍 checkTheme(); // 监听浏览器缓存事件 window.addEventListener('storage', checkTheme); return (): void =\u003e { // 解绑 window.removeEventListener('storage', checkTheme); } }, []); return ( \u003cThemeContext.Provider value={{ theme, setTheme: (currentTheme) =\u003e { setTheme(currentTheme); localStorage.setItem('theme', currentTheme); document.getElementsByTagName('html')[0].dataset.theme = currentTheme; } }}\u003e {children} \u003c/ThemeContext.Provider\u003e ) } export default ThemeContextProvider; 现在尝试打开两个页面，修改其中一个，发现另一个也会同步更新为一样的主题了。 ","date":"2023-02-20","objectID":"/ssr/:5:4","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"闪烁场景优化 还有一个小问题，因为在服务器端是获取不到当前的主题的，通过 useEffect 钩子来获取主题进行样式的渲染，这样其实会有一个主题切换的过程，在低网速或是快速切换场景下会有比较明显的闪烁，可以在钩子处设置断点查看（当前缓存是黑色主题）。 可以看到走到钩子的时候，是还没办法进行对应主题样式渲染的，应该怎么解决这个问题呢？ 只需要在 HTML 中引入对应的 script，确保可以在交互之前进行主题的初始化就行了。 Nextjs 有提供这个能力，修改 _document.tsx，然后引入对应的内部脚本。 import { Html, Head, Main, NextScript } from 'next/document' import Script from 'next/script'; export default function Document() { return ( \u003cHtml lang=\"en\"\u003e \u003cHead /\u003e \u003cbody\u003e \u003cMain /\u003e \u003cNextScript /\u003e \u003cScript id=\"theme-script\" strategy=\"beforeInteractive\"\u003e { `const item = localStorage.getItem('theme') || 'light'; localStorage.setItem('theme', item); document.getElementsByTagName('html')[0].dataset.theme = item; ` } \u003c/Script\u003e \u003c/body\u003e \u003c/Html\u003e ) } id 是用于 Nextjs 检索，beforeInteractive 表明这个脚本的执行策略是在交互之前，会被默认放到 head 中。 现在再来试试效果，发现走到钩子的时候已经可以正常去初始化了。 ","date":"2023-02-20","objectID":"/ssr/:5:5","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"帧动画功能 以 抖音前端技术官网 的首页加载动画为例，看看这个动画下究竟发生了什么？ 首先打开控制台的 network，使用 performance 来录制首页加载的过程，为了能更清晰查看，适当降低 CPU 的性能，调整为 4 x slowdown。 点击控制台左上角的 ⚪，然后刷新页面，可以得到下面的逐帧列表： 从下面的加载图中可以判断出，这个动画总的执行时长为 1.36 s，然后上面的列表中有具体页面加载过程的帧动画变化图，通过按帧查看，可以大概看出这个动画的执行顺序是这样的。 按照从小序列到大序列的顺序，每个元素分别执行了从下往上的平移操作，以及一个透明度从 0 到 1 的过程，加上上面看到每个动画的时长分析都是 1.3s，所以只是对每个元素推迟了不同的动画平移时间，但是它们享有相同的动画时长，针对这个场景应该怎么去实现呢？ 针对现在的首页，把 dom 元素简单拆分为 8 个区域，总动画时长定成 1s，其中 1s 的时间可以分为 9 个时间帧，每个区域从对应序列的时间帧开始执行相同的动画效果，最后把所有的帧连起来就是一个完整的帧动画。 定义对应的样式进行绑定，以 fadeInDown1 举例，@keyframes 指向动画的逐帧状态，其中 0% 和 11 % 都是一样的内容，这时候区域处于 y 轴 40px 的位置，然后末尾状态是无区域状态和 1 透明度，这个动画的效果会使得动画从整体时间的 11% 开始执行，到 100 % 完成最终的变化。 这个 11% 是从哪里来的呢？上面提到为每个动画延迟一个帧频率执行，8 个区域，共 9 帧，所以 1 帧的占比为 11% 的总动画时长，每个动画的起始时间（第二个状态值）都比上一个高出 1 帧的比例，这样就可以将整体帧动画串联起来了。 styles/Home.module.scss .withAnimation { .title { animation: fadeInDown1 1s; } .description { animation: fadeInDown2 1s; } .card:nth-of-type(1) { animation: fadeInDown3 1s; } .card:nth-of-type(2) { animation: fadeInDown4 1s; } .card:nth-of-type(3) { animation: fadeInDown5 1s; } .card:nth-of-type(4) { animation: fadeInDown6 1s; } .card:nth-of-type(5) { animation: fadeInDown7 1s; } .card:nth-of-type(6) { animation: fadeInDown8 1s; } } @keyframes fadeInDown1 { 0% { transform: translate3d(0, 40px, 0); opacity: 0; } 11% { transform: translate3d(0, 40px, 0); opacity: 0; } 100% { -webkit-transform: none; transform: none; opacity: 1; } } @keyframes fadeInDown2 { 0% { transform: translate3d(0, 40px, 0); opacity: 0; } 22% { transform: translate3d(0, 40px, 0); opacity: 0; } 100% { -webkit-transform: none; transform: none; opacity: 1; } } @keyframes fadeInDown3 { 0% { transform: translate3d(0, 40px, 0); opacity: 0; } 33% { transform: translate3d(0, 40px, 0); opacity: 0; } 100% { -webkit-transform: none; transform: none; opacity: 1; } } @keyframes fadeInDown4 { 0% { transform: translate3d(0, 40px, 0); opacity: 0; } 44% { transform: translate3d(0, 40px, 0); opacity: 0; } 100% { -webkit-transform: none; transform: none; opacity: 1; } } @keyframes fadeInDown5 { 0% { transform: translate3d(0, 40px, 0); opacity: 0; } 55% { transform: translate3d(0, 40px, 0); opacity: 0; } 100% { -webkit-transform: none; transform: none; opacity: 1; } } @keyframes fadeInDown6 { 0% { transform: translate3d(0, 40px, 0); opacity: 0; } 66% { transform: translate3d(0, 40px, 0); opacity: 0; } 100% { -webkit-transform: none; transform: none; opacity: 1; } } @keyframes fadeInDown7 { 0% { transform: translate3d(0, 40px, 0); opacity: 0; } 77% { transform: translate3d(0, 40px, 0); opacity: 0; } 100% { -webkit-transform: none; transform: none; opacity: 1; } } @keyframes fadeInDown8 { 0% { transform: translate3d(0, 40px, 0); opacity: 0; } 88% { transform: translate3d(0, 40px, 0); opacity: 0; } 100% { -webkit-transform: none; transform: none; opacity: 1; } } 改造首页 (index.tsx) Dom 类，专门定义一个动画类来存放动画相关的样式，避免对基础样式造成污染。 import {useRef} from 'react'; import type { NextPage } from 'next'; import classNames from 'classnames'; import styles from '@/styles/Home.module.scss'; interface IHomeProps { title: string; description: string; list: { label: string; info: string; link: string; }[]; } const Home: NextPage\u003cIHomeProps\u003e = ({ title, description, list }) =\u003e { const mainRef = useRef\u003cHTMLDivElement\u003e(null); return ( \u003cdiv className={styles.container}\u003e \u003cmain className={classNames([styles.main, styles.withAnimation])} ref={mainRef}\u003e \u003ch1 className={styles.title}\u003e{title}\u003c/h1\u003e \u003cp className={styles.description}\u003e{description}\u003c/p\u003e \u003cdiv className={styles.grid}\u003e { list?.map((item, index) =\u003e { return ( \u003cdiv key={index} className={styles.card} onClick={(): void =\u003e { window.open( item?.link, \"blank\", \"noopener=yes,noreferrer=yes\" ); }}\u003e \u003ch2\u003e{item?.label}\u003c/h2\u003e \u003cp\u003e{item?.info}\u003c/p\u003e \u003c/div\u003e ) }) } \u003c/div\u003e \u003c/main\u003e \u003c/div\u003e ) } Home.getInitialProps = (context) =\u003e { return { title: \"Hello SSR!\", description: \"A Demo for 官网开发实战\", list: [ { label: \"文章1\", info: \"A test for article1\", link: \"http://localhost:3000/article/1\", }, { label: \"文章2\", info: \"A test for article2\", link: \"h","date":"2023-02-20","objectID":"/ssr/:6:0","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"主动触发动画重新播放 在切换主题时，希望能再执行一次加载动画，可以通过 requestAnimationFrame 来实现，它会返回一个回调，强制浏览器在重绘前调用指定的函数来进行动画的更新。 使用这个来改造一下首页，加一个 useEffect 的钩子。 import {useRef, useContext, useEffect} from 'react'; import type { NextPage } from 'next'; import classNames from 'classnames'; import { ThemeContext } from '@/stores/theme'; import styles from '@/styles/Home.module.scss'; interface IHomeProps { title: string; description: string; list: { label: string; info: string; link: string; }[]; } const Home: NextPage\u003cIHomeProps\u003e = ({ title, description, list }) =\u003e { const mainRef = useRef\u003cHTMLDivElement\u003e(null); const { theme } = useContext(ThemeContext); useEffect(() =\u003e { mainRef.current?.classList.remove(styles.withAnimation); window.requestAnimationFrame(() =\u003e { mainRef.current?.classList.add(styles.withAnimation); }); }, [theme]); return ( \u003cdiv className={styles.container}\u003e \u003cmain className={classNames([styles.main, styles.withAnimation])} ref={mainRef}\u003e \u003ch1 className={styles.title}\u003e{title}\u003c/h1\u003e \u003cp className={styles.description}\u003e{description}\u003c/p\u003e \u003cdiv className={styles.grid}\u003e { list?.map((item, index) =\u003e { return ( \u003cdiv key={index} className={styles.card} onClick={(): void =\u003e { window.open( item?.link, \"blank\", \"noopener=yes,noreferrer=yes\" ); }}\u003e \u003ch2\u003e{item?.label}\u003c/h2\u003e \u003cp\u003e{item?.info}\u003c/p\u003e \u003c/div\u003e ) }) } \u003c/div\u003e \u003c/main\u003e \u003c/div\u003e ) } Home.getInitialProps = (context) =\u003e { return { title: \"Hello SSR!\", description: \"A Demo for 官网开发实战\", list: [ { label: \"文章1\", info: \"A test for article1\", link: \"http://localhost:3000/article/1\", }, { label: \"文章2\", info: \"A test for article2\", link: \"http://localhost:3000/article/2\", }, { label: \"文章3\", info: \"A test for article3\", link: \"http://localhost:3000/article/3\", }, { label: \"文章4\", info: \"A test for article4\", link: \"http://localhost:3000/article/4\", }, { label: \"文章5\", info: \"A test for article5\", link: \"http://localhost:3000/article/5\", }, { label: \"文章6\", info: \"A test for article6\", link: \"http://localhost:3000/article/6\", }, ], }; } export default Home; 在每次 theme 发生变化的时候，主动移除对应的动画类，再通过 requestAnimationFrame 对动画类进重新绑定，达到主动触发动画刷新的效果，现在来看一下最终成品。 ","date":"2023-02-20","objectID":"/ssr/:6:1","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"多媒体适配 之前的页面只绘制了 pc 端的样式，通常官网需要支持 pc、 ipad、 移动端等多种设备的访问，现在需要对多媒体设备的样式进行兼容适配。 ","date":"2023-02-20","objectID":"/ssr/:7:0","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"Px 转 Rem 在适配之前，先了解一下 rem 和 px，px 是相对屏幕分辨率的像素单位， rem 是相对 HTML 根元素字体大小而确定的相对单位，对于多媒体的适配，常用 rem 进行开发。 所以需要对之前的样式进行一下替换，将 px 单位替换为 rem，这个过程可以通过 webstorm 的 px2rwd-intellij-plugin 插件来协助完成，可以参照下图安装，默认的的根字体为 16px，根据相关说明扩展配置调整即可。 安装完成后，移步到样式问题，输入 16 px，可以看到会有对应 rem 提示，将所有的 px 单位替换即可。 ","date":"2023-02-20","objectID":"/ssr/:7:1","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"CSS 多媒体设备适配 通过编写不同的媒体设备样式来进行适配，这种常用于 dom 结构变化不大，可以复用 dom 的基础上，调整样式就能适配的场景。为加强复用，可以定义几个常用的设备场景。 pages/media.scss // 极小分辨率移动端设备 @mixin media-mini-mobile { @media screen and (max-width: 25.875rem) { @content; } } // 介于极小分辨率和正常分辨率之间的移动端设备 @mixin media-between-mini-and-normal-mobile { @media screen and (min-width: 25.876rem) and (max-width: 47.9375rem) { @content; } } // 移动端设备 @mixin media-mobile { @media screen and (max-width: 47.9375rem) { @content; } } // ipad @mixin media-ipad { @media screen and (min-width: 47.9375rem) and (max-width: 75rem) { @content; } } 在大部分场景，可以直接引入这些定义进行适配。 @include media-ipad { // ... } 以 footer 组件举例，改造一下它之前的样式。 components/footer/index.module.scss @import \"./pages/media.scss\"; .footer { font-size: 1rem; padding: 4.375rem 9.0625rem; background-color: var(--footer-background-color); .topArea { display: flex; justify-content: space-between; flex-wrap: wrap; .footerTitle { font-weight: 500; font-size: 2.25rem; line-height: 2.25rem; color: var(--primary-color); margin: 0; } .linkListArea { display: flex; .linkArea { display: flex; flex-direction: column; margin-left: 10rem; .title { font-weight: 500; font-size: 0.875rem; line-height: 1.25rem; color: var(--primary-color); margin-bottom: 2.5rem; word-break: keep-all; } .links { display: flex; flex-direction: column; font-weight: 400; font-size: 0.875rem; line-height: 1.25rem; word-break: keep-all; .link { color: var(--primary-color); cursor: pointer; margin-bottom: 1.5rem; } .disabled { color: var(--secondary-color); cursor: not-allowed; margin-bottom: 1.5rem; } } } .linkArea:first-of-type { margin-left: 0; } } } .bottomArea { display: flex; justify-content: space-between; .codeArea { display: flex; flex-direction: column; .text { color: var(--secondary-color); } } .numArea { color: var(--secondary-color); display: flex; flex-direction: column; align-items: flex-end; font-weight: 400; font-size: 0.875rem; line-height: 1.25rem; span { margin-bottom: 0.75rem; } .publicLogo { display: flex; .logo { margin-right: 0.25rem; } } } } } @media screen and (min-width: 48.6875rem) and (max-width: 54.125rem) { .footer { .topArea { .footerTitle { margin-bottom: 1.25rem; } } } } @media screen and (max-width: 48.6875rem) { .footer { .topArea { display: flex; flex-direction: column; align-items: center; .footerTitle { margin-bottom: 2.5rem; } .linkListArea { display: flex; flex-direction: column; text-align: center; .linkArea { margin-left: 0; } } } .bottomArea { display: flex; flex-direction: column; align-items: center; .codeArea { display: flex; flex-direction: column; align-items: center; .text { text-align: center; margin: 1.25rem 0; } } .numArea { align-items: center; text-align: center; } } } } // @include media-ipad { // } 实现效果： ","date":"2023-02-20","objectID":"/ssr/:7:2","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"Context 注入设备信息 对于页面的样式适配，CSS media 已经可以覆盖绝大部分的场景，但小部分的场景仍然无法覆盖，比如在一些媒体设备下，不再采用原本的 dom 结构，换用别的交互形式，就没办法直接用样式覆盖了，而是需要通过在客户端判断当前的设备，选用不同的交互。 应该怎么在客户端判断当前的设备呢？ 可以定义一个 context，用于判断当前的设备，然后注入给每个页面。判断设备的方式其实也很简单，通过页宽来判断就可。 constants/enum.ts export enum Environment { pc = 'pc', ipad = 'ipad', mobile = 'mobile', none = 'none', } stores/userAgent.tsx import React, {createContext, FC, useEffect, useState} from 'react'; import {Environment} from '@/constants/enum'; interface IUserAgentContextProps { userAgent: Environment; } interface IUserAgentProps { children: JSX.Element; } export const UserAgentContext = createContext\u003cIUserAgentContextProps\u003e({} as IUserAgentContextProps); const UserAgentProvider: FC\u003cIUserAgentProps\u003e = ({ children }) =\u003e { const [userAgent, setUserAgent] = useState\u003cEnvironment\u003e(Environment.none); // 监听本地缓存来同步不同页面间的主题（当前页面无法监听到，直接在顶部栏进行了类的切换) useEffect(() =\u003e { const checkUserAgent = (): void =\u003e { const width = document.body.offsetWidth; switch (true) { case width \u003c 768: setUserAgent(Environment.mobile); break; case width \u003e= 768 \u0026\u0026 width \u003c 1200: setUserAgent(Environment.ipad); break; case width \u003e= 1200: setUserAgent(Environment.pc); break; default: setUserAgent(Environment.none); break; } } checkUserAgent(); window.addEventListener('resize', checkUserAgent); return (): void =\u003e { window.removeEventListener('resize', checkUserAgent); } }, [typeof document !== 'undefined' \u0026\u0026 document.body.offsetWidth]); return ( \u003cUserAgentContext.Provider value={{ userAgent }}\u003e {children} \u003c/UserAgentContext.Provider\u003e ) } export default UserAgentProvider; Environment.none：设置一个空态，为了避免未取到页宽时，错误赋值非当前页面的设备分辨率的值，导致可能会出现分辨率样式的短暂切换造成的视觉冲突。 typeof document !== “undefined” \u0026\u0026 document.body.offsetWidth： 除钩子方法里（比如 useEffect）以外的逻辑，都是会在服务器端执行的，在服务器端是没有 BOM 的注入的，所以需要对 BOM 的调用进行判空。 把这个 context 同样注入到入口文件。 pages/_app.tsx \u003cThemeContextProvider\u003e \u003cUserAgentProvider\u003e \u003cLayout navbarData={navbarData} footerData={footerData}\u003e \u003cComponent {...pageProps} /\u003e \u003c/Layout\u003e \u003c/UserAgentProvider\u003e \u003c/ThemeContextProvider\u003e 在 navbar 组件简单调用试试。 components/navbar/index.tsx import { FC, useContext } from \"react\"; import styles from \"./index.module.scss\"; import { ThemeContext } from \"@/stores/theme\"; import { UserAgentContext } from \"@/stores/userAgent\"; import { Themes, Environment } from \"@/constants/enum\"; export interface INavBarProps {} const NavBar: FC\u003cINavBarProps\u003e = ({}) =\u003e { const { setTheme } = useContext(ThemeContext); const { userAgent } = useContext(UserAgentContext); return ( \u003cdiv className={styles.navBar}\u003e \u003ca href=\"http://localhost:3000/\"\u003e \u003cdiv className={styles.logoIcon}\u003e\u003c/div\u003e \u003c/a\u003e \u003cdiv className={styles.themeArea}\u003e {userAgent === Environment.pc \u0026\u0026 ( \u003cspan className={styles.text}\u003e当前是pc端样式\u003c/span\u003e )} {userAgent === Environment.ipad \u0026\u0026 ( \u003cspan className={styles.text}\u003e当前是Ipad端样式\u003c/span\u003e )} {userAgent === Environment.mobile \u0026\u0026 ( \u003cspan className={styles.text}\u003e当前是移动端样式\u003c/span\u003e )} \u003cdiv className={styles.themeIcon} onClick={(): void =\u003e { if (localStorage.getItem(\"theme\") === Themes.light) { setTheme(Themes.dark); } else { setTheme(Themes.light); } }} \u003e\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e ); }; export default NavBar; 实现效果： ","date":"2023-02-20","objectID":"/ssr/:7:3","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"服务端判定设备信息 客户端判定设备存在一个小问题是，因为 HTML 文本的生成是在服务器端生成的，客户端判断设备信息会存在一个初始态到实际设备数据短暂切换的问题，而且如果不同设备展示的内容不同，还有可能会影响到实际的 SEO ，那有没有办法可以在服务器端判断当前的访问设备呢？ 虽然服务器端拿不到当前访问的客户端页宽等数据，但是客户端在服务器端请求的时候，请求头中有一个 user-agent 请求头，可以用来判断当前的设备是 pc 端还是移动端，通过这个来判断，就可以在 HTML 文本返回前，就拿到实际的设备 DOM。 先来定义一下判断设备的通用方法。 utils/index.ts export const getIsMobile = (context: AppContext) =\u003e { const { headers = {} } = context.ctx.req || {}; return /mobile|android|iphone|ipad|phone/i.test( (headers['user-agent'] || '').toLowerCase() ); } 然后在入口文件的注入函数里，额外注入一个设备信息，如果是移动端，就给标题加一个“（移动端）”， 如果是 pc 端，就加一个 “（pc 端）”。 pages/_app.tsx import type { AppProps, AppContext } from 'next/app'; import App from 'next/app'; import Head from 'next/head'; import axios from 'axios'; import ThemeContextProvider from '@/stores/theme'; import UserAgentProvider from '@/stores/userAgent'; import { LOCALDOMAIN, getIsMobile } from '@/utils'; import type { ILayoutProps } from '@/components/layout'; import { appWithTranslation } from 'next-i18next'; import Layout from '@/components/layout'; import '@/styles/globals.css' const MyApp = (data: AppProps \u0026 ILayoutProps \u0026 { isMobile: boolean }) =\u003e { const { Component, pageProps, navbarData, footerData, isMobile } = data; return ( \u003cdiv\u003e \u003cHead\u003e \u003ctitle\u003e{`A Demo for 官网开发实战 (${ isMobile ? \"移动端\" : \"pc端\" })`}\u003c/title\u003e \u003cmeta name=\"description\" content=\"A Demo for 官网开发实战\" /\u003e \u003clink rel=\"icon\" href=\"/favicon.ico\" /\u003e \u003c/Head\u003e \u003cThemeContextProvider\u003e \u003cUserAgentProvider\u003e \u003cLayout navbarData={navbarData} footerData={footerData}\u003e \u003cComponent {...pageProps} /\u003e \u003c/Layout\u003e \u003c/UserAgentProvider\u003e \u003c/ThemeContextProvider\u003e \u003c/div\u003e ) } MyApp.getInitialProps = async (context: AppContext) =\u003e { const pageProps = await App.getInitialProps(context); const { data = {} } = await axios.get(`${LOCALDOMAIN}/api/layout`) return { ...pageProps, ...data, isMobile: getIsMobile(context), } } export default appWithTranslation(MyApp); ","date":"2023-02-20","objectID":"/ssr/:7:4","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"业务功能实现 官网作为一个品牌形象的载体，肯定需要大量的文章或信息，来进行文化价值观的传输，文章的内容一多，自然需要为它实现对应的分页。 ","date":"2023-02-20","objectID":"/ssr/:8:0","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"文章页分页 样式实现 分页的组件使用 semi-design (其它UI框架方法类似) 来实现。 npm install @douyinfe/semi-ui --save 给首页文章块下面加一个分页。 pages/index.tsx import { Pagination } from \"@douyinfe/semi-ui\"; // ... \u003cdiv className={styles.paginationArea}\u003e \u003cPagination total={articles?.total} pageSize={6} /\u003e \u003c/div\u003e Nextjs 希望可以自主导入依赖中的样式，而不是随着依赖直接导入样式，避免对全局样式造成影响。 Semi 的依赖默认是在入口文件统一导入的，针对这种情况，Semi 提供了 semi-next 插件来对入口文件样式进行去除。 npm i @douyinfe/semi-next 安装好 semi-next 后，到 nextjs 的配置文件，用 semi-next 包裹一层配置文件，进行默认导入样式的去除。 next.config.js /** @type {import('next').NextConfig} */ const path = require('path'); const semi = require('@douyinfe/semi-next').default({}); const nextConfig = semi({ reactStrictMode: true, swcMinify: true, images: { domains: ['127.0.0.1'], }, webpack: (config) =\u003e { config.resolve.alias = { ...config.resolve.alias, '@': path.resolve(__dirname), }; return config; } }); module.exports = nextConfig 在全局样式中手动导入 Semi 的样式。 styles/global.css @import \"~@douyinfe/semi-ui/dist/css/semi.min.css\"; 针对分页组件覆盖一下主题化的样式，样式覆盖是通过 global 样式去做。 styles/Home.module.scss @import \"./pages/media.scss\"; @mixin initStatus { transform: translate3d(0, 2.5rem, 0); opacity: 0; } @mixin finalStatus { -webkit-transform: none; transform: none; opacity: 1; } .container { padding: 0 2rem; color: var(--primary-color); .main { min-height: 100vh; padding: 4rem 0; flex: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; .header { background-image: var(--home-background-icon); background-size: 18.75rem 18.75rem; background-repeat: no-repeat; width: 18.75rem; height: 18.75rem; } .headerWebp { background-image: var(--home-background-icon-webp); } .top { display: flex; } .title a { color: var(--link-color); text-decoration: none; } .title a:hover, .title a:focus, .title a:active { text-decoration: underline; } .title { margin: 0; line-height: 1.15; font-size: 4rem; } .title, .description { text-align: center; } .description { margin: 4rem 0; line-height: 1.5; font-size: 1.5rem; } .grid { display: flex; align-items: flex-start; justify-content: flex-start; flex-wrap: wrap; max-width: 62.5rem; transition: 2s; min-height: 36.25rem; .card { margin: 1rem; padding: 1.5rem; text-align: left; color: inherit; text-decoration: none; border: 0.0625rem solid var(--footer-background-color); border-radius: 0.625rem; transition: color 0.15s ease, border-color 0.15s ease; max-width: 18.75rem; cursor: pointer; width: 18.75rem; height: 13.875rem; } .card:hover, .card:focus, .card:active { color: var(--link-color); border-color: var(--link-color); } .card h2 { margin: 0 0 1rem 0; font-size: 1.5rem; } .card p { margin: 0; font-size: 1.25rem; line-height: 1.5; } } .paginationArea { width: 62.5rem; display: flex; justify-content: flex-end; padding: 20px 0; :global { .semi-page-item { color: var(--primary-color); opacity: 0.7; } .semi-page-item:hover { background-color: var(--semi-page-hover-background-color); } .semi-page-item-active { color: var(--semi-page-active-color); background-color: var(--semi-page-active-background-color); } .semi-page-item-active:hover { color: var(--semi-page-active-color); background-color: var(--semi-page-active-background-color); } } } } .withAnimation { .title { animation: fadeInDown1 1s; } .description { animation: fadeInDown2 1s; } .card:nth-of-type(1) { animation: fadeInDown3 1s; } .card:nth-of-type(2) { animation: fadeInDown4 1s; } .card:nth-of-type(3) { animation: fadeInDown5 1s; } .card:nth-of-type(4) { animation: fadeInDown6 1s; } .card:nth-of-type(5) { animation: fadeInDown7 1s; } .card:nth-of-type(6) { animation: fadeInDown8 1s; } } @keyframes fadeInDown1 { 0% { @include initStatus; } 11% { @include initStatus; } 100% { @include finalStatus; } } @keyframes fadeInDown2 { 0% { @include initStatus; } 22% { @include initStatus; } 100% { @include finalStatus; } } @keyframes fadeInDown3 { 0% { @include initStatus; } 33% { @include initStatus; } 100% { @include finalStatus; } } @keyframes fadeInDown4 { 0% { @include initStatus; } 44% { @include initStatus; ","date":"2023-02-20","objectID":"/ssr/:8:1","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"国际化功能 官网不一定是给一个国家的人看的，可能公司或是团队的业务是针对多个地区的，语言不应该成为价值观传输的阻碍，所以如果是多地区业务线的公司，实现多语言也是很必要的。 安装相关依赖包： npm install i18next next-i18next react-i18next next-i18next 包提供了 appWithTranslation一个高阶组件（HOC），需要用这个高阶组件包装整个应用程序。 pages/_app.tsx import type { AppProps, AppContext } from 'next/app'; import App from 'next/app'; import Head from 'next/head'; import axios from 'axios'; import ThemeContextProvider from '@/stores/theme'; import UserAgentProvider from '@/stores/userAgent'; import { LOCALDOMAIN, getIsMobile } from '@/utils'; import type { ILayoutProps } from '@/components/layout'; import { appWithTranslation } from 'next-i18next'; import Layout from '@/components/layout'; import '@/styles/globals.css' const MyApp = (data: AppProps \u0026 ILayoutProps \u0026 { isMobile: boolean }) =\u003e { const { Component, pageProps, navbarData, footerData, isMobile } = data; return ( \u003cdiv\u003e \u003cHead\u003e \u003ctitle\u003e{`A Demo for 官网开发实战 (${ isMobile ? \"移动端\" : \"pc端\" })`}\u003c/title\u003e \u003cmeta name=\"description\" content=\"A Demo for 官网开发实战\" /\u003e \u003clink rel=\"icon\" href=\"/favicon.ico\" /\u003e \u003c/Head\u003e \u003cThemeContextProvider\u003e \u003cUserAgentProvider\u003e \u003cLayout navbarData={navbarData} footerData={footerData}\u003e \u003cComponent {...pageProps} /\u003e \u003c/Layout\u003e \u003c/UserAgentProvider\u003e \u003c/ThemeContextProvider\u003e \u003c/div\u003e ) } MyApp.getInitialProps = async (context: AppContext) =\u003e { const pageProps = await App.getInitialProps(context); const { data = {} } = await axios.get(`${LOCALDOMAIN}/api/layout`) return { ...pageProps, ...data, isMobile: getIsMobile(context), } } export default appWithTranslation(MyApp); 现在为 next-i18next 创建一个配置文件，在项目根目录下创建文件 next-i18next.config.js 并添加如下配置。 module.exports = { i18n: { defaultLocale: 'zh-CN', locales: ['en_US', 'zh-CN'], }, ns: ['header', 'main', 'footer', 'common'] } locales: 包含网站上需要的语言环境的数组。 defaultLocale: 要显示的默认语言环境。 现在将创建的 i18next 配置导入到 next.config.js 中。 /** @type {import('next').NextConfig} */ const path = require('path'); const semi = require('@douyinfe/semi-next').default({}); const { i18n } = require('./next-i18next.config'); const nextConfig = semi({ reactStrictMode: true, swcMinify: true, i18n, images: { domains: ['127.0.0.1'], }, webpack: (config) =\u003e { config.resolve.alias = { ...config.resolve.alias, '@': path.resolve(__dirname), }; return config; } }); module.exports = nextConfig 现在开始在应用程序中添加语言环境，在 public 目录下新建 locales 目录。 public/locales/en_US/main.json { \"IpadStyle\": \"Currently Ipad style\", \"PCStyle\": \"Currently it is PC style\", \"MobileStyle\": \"Currently in mobile style\" } public/locales/zh_CN/main.json { \"IpadStyle\": \"当前是Ipad端样式\", \"PCStyle\": \"当前是pc端样式\", \"MobileStyle\": \"当前是移动端样式\" } 类似于主题化注入，针对语言也先来定义一套注入器（Context)，通过缓存的方式统一管理，然后进行全局的注入。 constants/enum export enum Language { ch = \"zh-CN\", en = \"en_US\", } stores/language.tsx import {createContext, FC, useEffect, useState} from 'react'; import {Language} from '@/constants/enum'; interface ILanguageContextProps { language: Language; setLanguage: (language: Language) =\u003e void; } interface ILanguageContextProviderProps { children: JSX.Element; } export const LanguageContext = createContext\u003cILanguageContextProps\u003e({} as ILanguageContextProps); const LanguageContextProvider: FC\u003cILanguageContextProviderProps\u003e = ({children}) =\u003e { const [language, setLanguage] = useState\u003cLanguage\u003e(Language.ch); useEffect(() =\u003e { const checkLanguage = () =\u003e { const item = localStorage.getItem('language') as Language || Language.ch; setLanguage(item); document.getElementsByTagName('html')[0].lang = item; } // 初始化先执行一遍 checkLanguage(); // 监听浏览器缓存事件 window.addEventListener('storage', checkLanguage); return (): void =\u003e { // 解绑 window.removeEventListener('storage', checkLanguage); } }, []); return ( \u003cLanguageContext.Provider value={{ language, setLanguage: (currentLanguage) =\u003e { setLanguage(currentLanguage); localStorage.setItem('language', currentLanguage); document.getElementsByTagName('html')[0].lang = currentLanguage; } }}\u003e {children} \u003c/LanguageContext.Provider\u003e ) } export default LanguageContextProvider; 导入 serverSideTranslations，在 getServerSideProps 中进行道具传递。 pages/ind","date":"2023-02-20","objectID":"/ssr/:9:0","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"自定义弹窗组件 不同的业务场景可能需要不同的渐入渐出动画，平常组件库的弹窗组件并不容易在原有基础上覆盖自定义动画，所以来开发一个自己的自定义动画弹窗组件。 ","date":"2023-02-20","objectID":"/ssr/:10:0","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"静态样式 与平常组件不同，弹窗组件至少需要暴露一个 open 方法给外部进行调用，这就需要用到 forwardRef，它可以将 ref 中的方法暴露给外部进行相关的调用。 创建一个 popup组件，然后写一下它的静态样式，其中 IPopupRef 是弹窗暴露的 ref 类型，而 IPopupProps 是组件本身的类型，useImperativeHandle 是组件 ref 暴露给外部调用的方法定义，暴露回去的回调方法类型需要和 ref 类型相同。 component/popup/index.tsx import React, {forwardRef, useImperativeHandle, useState,} from 'react'; import styles from './index.module.scss'; import classNames from 'classnames'; export interface IPopupRef { open: () =\u003e void; } interface IPopupProps { children: JSX.Element; } const Popup = forwardRef\u003cIPopupRef, IPopupProps\u003e(({children}, ref) =\u003e { const [visible, setVisible] = useState\u003cboolean\u003e(false); useImperativeHandle(ref, () =\u003e ({ open: (): void =\u003e { setVisible(true); } })); return visible ? (\u003cdiv className={classNames({ [styles.popup]: true, [styles.enter]: enter, [styles.leave]: leave, })}\u003e \u003cdiv className={styles.mask} /\u003e \u003cdiv className={styles.popupContent}\u003e \u003cdiv className={styles.closeBtn} onClick={(): void =\u003e { setVisible(false); }} /\u003e {children} \u003c/div\u003e \u003c/div\u003e) : null; }); export default Popup; 然后写一下静态的样式，相关的全局主题化变量也定义一下。 components/popup/index.module.scss @import \"./pages/media.scss\"; .popup { width: 100%; height: 100vh; display: flex; justify-content: center; align-items: center; position: fixed; top: 0; left: 0; z-index: 10000; .mask { width: inherit; height: inherit; position: fixed; background-color: #000; opacity: 0.5; top: 0; left: 0; z-index: 10; } .popupContent { position: relative; border-radius: 0.25rem; display: flex; flex-direction: column; align-items: center; justify-content: center; background-color: var(--popup-content-background-color); z-index: 20; min-width: 25rem; min-height: 25rem; .closeBtn { width: 2.125rem; height: 2.125rem; background-color: inherit; background-image: var(--popup-close-icon); background-position: center; background-size: 1rem 1rem; background-repeat: no-repeat; position: absolute; top: 1.1875rem; right: 1.1875rem; cursor: pointer; z-index: 100; } .closeBtn:hover { background-color: var(--popup-close-hover-background-color); } } } @include media-mobile { .popup { .dialogContent { .closeBtn { width: 0.6875rem; height: 0.6875rem; top: 1.3125rem; right: 0.875rem; } } } } @include media-ipad { .dialog { .dialogContent { .titleArea { padding: 1.5rem 1.5625rem; } } } } styles/globals.css html[data-theme=\"dark\"] { --primary-color: #ffffff; --primary-background-color: rgba(14, 14, 14, 1); --footer-background-color: rgba(36, 36, 36, 1); --navbar-background-color: rgba(0, 0, 0, 0.5); --secondary-color: rgba(255, 255, 255, 0.5); --link-color: #34a8eb; --navbar-icon: url('../public/logo_dark.png'); --theme-icon: url('../public/theme_dark.png'); --popup-close-icon: url('../public/close.png'); --popup-close-hover-background-color: #353535; --popup-content-background-color: #1f1f1f; } html[data-theme=\"light\"] { --primary-color: #333333; --primary-background-color: rgba(255, 255, 255, 1); --footer-background-color: #f4f5f5; --navbar-background-color: rgba(255, 255, 255, 0.5); --secondary-color: #666666; --link-color: #0070f3; --navbar-icon: url('../public/logo_light.png'); --theme-icon: url('../public/theme_light.png'); --popup-close-icon: url('../public/close_light.png'); --popup-close-hover-background-color: #f5f5f5; --popup-content-background-color: #f4f5f5; } 在 navbar 加一个入口。 component/navbar/index.tsx import {FC, useContext, useEffect, useRef} from 'react'; import Link from \"next/link\"; import Popup from '@/components/popup'; import { IPopupRef } from '@/components/popup'; import {useTranslation} from 'next-i18next'; import {ThemeContext} from '@/stores/theme'; import {UserAgentContext} from '@/stores/userAgent'; import {Environment, Language, Themes} from '@/constants/enum'; import styles from './index.module.scss'; import {LanguageContext} from \"@/stores/language\"; import {useRouter} from \"next/router\"; export interface INavBarProps {} const NavBar: FC\u003cINavBarProps\u003e = ({}) =\u003e { const { t } = useTranslation('main'); const router = useRouter(); const popupRef = useRe","date":"2023-02-20","objectID":"/ssr/:10:1","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"遮罩层滚动穿透 这时候存在一个问题，在有遮罩层的时候，最外层仍然是可以滚动的，这个问题称作为滚动穿透现象，其实也很好理解，最外层的区域（body) 仍然是可以产生滚动的，仅仅是给了 100vh 的遮罩层，所以并不能阻止滚动的产生。 解决方案也很简单，只需要在遮罩层的时候，在 body 手动加上一个类来限制它的高度即可。 components/popup/index.tsx // ... useEffect(() =\u003e { document.body.className = visible ? \"forbidScroll\" : \"\"; }, [visible]); styles/globals.css .forbidScroll { height: 100vh; overflow: hidden; } 现在可以发现已经不会再滚动了。 ","date":"2023-02-20","objectID":"/ssr/:10:2","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"指定渲染位置 打开控制台的 Elements，通过选取元素选中弹窗，可以看到渲染的位置是在对应组件调用的 dom 下的。 这样其实会存在一个问题，因为被嵌套在别的 dom 下，包括样式、事件在内的很多情况，弹窗组件可能都会受到影响，作为一个通用的组件是不希望弹窗的展现因为外界的情况而有所变化的，所以不应该把它渲染在父级区域下。 在 React 16，有提供一个 api，ReactDom.createPortal， 它提供了将子节点渲染到存在于父组件以外的 DOM 节点的能力，通过这个 api 可以将弹窗组件渲染到 body 下，这样就可以有效解决这个问题，因为需要使用到 BOM 的问题，所以需要进行判空。 component/popup/index.tsx import React, {forwardRef, useImperativeHandle, useState} from 'react'; import {createPortal} from 'react-dom'; import styles from './index.module.scss'; import classNames from 'classnames'; export interface IPopupRef { open: () =\u003e void; } interface IPopupProps { children: JSX.Element; } const Popup = forwardRef\u003cIPopupRef, IPopupProps\u003e(({children}, ref) =\u003e { const [visible, setVisible] = useState\u003cboolean\u003e(false); useImperativeHandle(ref, () =\u003e ({ open: (): void =\u003e { setVisible(true); } })); return visible ? ( createPortal((\u003cdiv className={classNames({ [styles.popup]: true, })}\u003e \u003cdiv className={styles.mask} /\u003e \u003cdiv className={styles.popupContent}\u003e \u003cdiv className={styles.closeBtn} onClick={(): void =\u003e { setVisible(false); }} /\u003e {children} \u003c/div\u003e \u003c/div\u003e), document.body) ) : null; }); export default Popup; 再来看一下控制台，可以看到已经渲染到最外层了。 ","date":"2023-02-20","objectID":"/ssr/:10:3","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"动画实现 应该怎么为弹窗实现动画呢？ 渐入渐出的动画关键在于类的切换，在切换过程中需要对下一个状态的类进行异步切换，因为 react state 是对最终结果进行切换的，这样没办法起到类型变化的效果。 现在来实现这个效果，动画的效果就实现一个普通的渐入渐出就可以了。 component/popup/index.tsx import React, {forwardRef, useEffect, useImperativeHandle, useState,} from 'react'; import {createPortal} from 'react-dom'; import styles from './index.module.scss'; import classNames from 'classnames'; export interface IPopupRef { open: () =\u003e void; } interface IPopupProps { children: JSX.Element; } const Popup = forwardRef\u003cIPopupRef, IPopupProps\u003e(({children}, ref) =\u003e { const [visible, setVisible] = useState\u003cboolean\u003e(false); const [enter, setEnter] = useState\u003cboolean\u003e(false); const [leave, setLeave] = useState\u003cboolean\u003e(false); useImperativeHandle(ref, () =\u003e ({ open: (): void =\u003e { setEnter(true); setTimeout((): void =\u003e { setEnter(false); }, 300); setVisible(true); } })); useEffect(() =\u003e { document.body.className = visible ? maskClass : ''; let timer = null; if (visible) { setEnter(true); timer = setTimeout((): void =\u003e { setEnter(false); }, 300); } else { setLeave(true); timer = setTimeout((): void =\u003e { setLeave(false); }, 300); } return (): void =\u003e { timer = null; }; }, [visible]); return visible ? ( createPortal((\u003cdiv className={classNames({ [styles.popup]: true, [styles.enter]: enter, [styles.leave]: leave, })}\u003e \u003cdiv className={styles.mask} /\u003e \u003cdiv className={styles.popupContent}\u003e \u003cdiv className={styles.closeBtn} onClick={(): void =\u003e { setLeave(true); setTimeout((): void =\u003e { setLeave(false); }, 300); setVisible(false); }} /\u003e {children} \u003c/div\u003e \u003c/div\u003e), document.body) ) : null; }); export default Popup; components/popup/index.module.scss @import \"./pages/media.scss\"; .popup { width: 100%; height: 100vh; display: flex; justify-content: center; align-items: center; position: fixed; top: 0; left: 0; z-index: 10000; .mask { width: inherit; height: inherit; position: fixed; background-color: #000; opacity: 0.5; top: 0; left: 0; z-index: 10; } .popupContent { position: relative; border-radius: 0.25rem; display: flex; flex-direction: column; align-items: center; justify-content: center; background-color: var(--popup-content-background-color); z-index: 20; min-width: 25rem; min-height: 25rem; .closeBtn { width: 2.125rem; height: 2.125rem; background-color: inherit; background-image: var(--popup-close-icon); background-position: center; background-size: 1rem 1rem; background-repeat: no-repeat; position: absolute; top: 1.1875rem; right: 1.1875rem; cursor: pointer; z-index: 100; } .closeBtn:hover { background-color: var(--popup-close-hover-background-color); } } } @include media-mobile { .popup { .dialogContent { .closeBtn { width: 0.6875rem; height: 0.6875rem; top: 1.3125rem; right: 0.875rem; } } } } @include media-ipad { .dialog { .dialogContent { .titleArea { padding: 1.5rem 1.5625rem; } } } } @keyframes fadeIn { 0% { transform: scale(0); opacity: 0; } 100% { transform: scale(1); opacity: 1; } } @keyframes fadeOut { 0% { transform: scale(1); opacity: 1; } 100% { transform: scale(0); opacity: 0; } } @keyframes maskFadeIn { 0% { opacity: 0; } 100% { opacity: 0.5; } } @keyframes maskFadeOut { 0% { opacity: 0.5; } 100% { opacity: 0; } } .enter { .mask { animation: maskFadeIn 0.2s; } .popupContent { animation: fadeIn 0.2s; } } .leave { .mask { animation: maskFadeOut 0.2s; opacity: 0; } .popupContent { animation: fadeOut 0.2s; transform: scale(0); } } 实现效果： ","date":"2023-02-20","objectID":"/ssr/:10:4","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"图片优化 官网交互中，通常会有一些高分辨率图片用于展示，这些图片通常体积大、加载时间长，且占页面区域较大，如果在网速较快的情况下可能尚可，但是在低网速，类似 fast 3G，slow 3G 的场景下，几百 kb，甚至几 mb 的图片资源加载是难以忍受的，加上区域大，很可能会出现页面内容已经加载完成，但是图片区域长时间留白的问题。 那么高分辨率图在低网速下加载时，应该如何减少加载时间，达到首屏优化的目的。 ","date":"2023-02-20","objectID":"/ssr/:11:0","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"静态样式 首先切两个大图，加在首页的位置，大小控制在 500kb 上下的清晰度（500px * 500px 2x) 即可，这种在快速 3g 的网速下，通常需要请求几十秒左右可以完全加载，可以用来说明这个场景。 styles/globals.css html[data-theme=\"dark\"] { --home-background-icon: url('../public/home_bg_dark.png'); } html[data-theme=\"light\"] { --home-background-icon: url('../public/home_bg_light.png'); } pages/index.tsx \u003cdiv className={styles.header} /\u003e styles/Home.module.scss .header { background-image: var(--home-background-icon); background-size: 18.75rem 18.75rem; background-repeat: no-repeat; width: 18.75rem; height: 18.75rem; } 图片的大小大致在 700kb， 正常 4g 网络下的加载时长为 12ms 左右。 把网速切换至 fast 3g，看看这个图片的加载时长需要多久。 可以看到需要 4s，远远超过其他静态资源，这意味着页面元素加载出来后，用户需要再等好几秒图片才能缓缓加载出来。 针对这个问题，在实际业务开发中有大概这几个方案。 这是 MDN 2020 年网络信息接口提案中提出的最新 BOM 属性，通过这个 BOM 来获取当前的流量状态，根据不同的流量状态进行图片清晰度的选择。 在较低网速下的场景，选择优先加载 0.5x 或是 1x 的图片，同时也加载 2x 的大图，通过隐藏 DOM 的方式隐性加载，然后监听 2x 资源的 onload 事件，在资源加载完成时，进行类的切换即可。 ","date":"2023-02-20","objectID":"/ssr/:11:1","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"navigator.connection.effectiveType 这种方案在低网速下的效果是所有方案中最好的，用户的感知视角是，只需要等待 0.5x 到 1x 的模糊图加载时长，不会有区域的大面积留白，同时最后也可以体验到高清图的交互。 不过这种方案毕竟还是一个实验性属性，兼容性各方面并不是很好，只有较少的浏览器支持这个属性。 需要注意的有两点： 考虑到兼容性问题，navigator.connection.effectiveType 的使用需要进行判空处理，避免因为 navigator.connection is not defined 的报错阻塞页面渲染，可以写成 navigator?.connection?.effectiveType 来进行调用。 因为是 BOM，模板页面会同时执行在服务器端和客户端，在服务器端是没有 BOM 等属性的注入的，如果是在 hook 以外的地方调用，需要对第一个元素进行判空，采用typeof navigator !== “undefined” \u0026\u0026 navigator?.connection?.effectiveType的方式调用。 ","date":"2023-02-20","objectID":"/ssr/:11:2","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"responsive images / picture 浏览器有提供响应式图片的能力，分别是 img srcset 和 picture，它们都支持根据不同的像素场景自动选取不同的元素来进行适配。 下面是两个 MDN 的使用例子。 \u003cimg srcset=\"elva-fairy-480w.jpg 480w, elva-fairy-800w.jpg 800w\" sizes=\"(max-width: 600px) 480px,800px\" src=\"elva-fairy-800w.jpg\" alt=\"Elva dressed as a fairy\" xmlns=\"http://www.w3.org/1999/html\"\u003e \u003cpicture\u003e \u003csource srcset=\"/media/cc0-images/surfer-240-200.jpg\" media=\"(min-width: 800px)\"\u003e \u003cimg src=\"/media/cc0-images/painted-hand-298-332.jpg\" alt=\"\"/\u003e \u003c/picture\u003e img srcset 根据像素比来选取适合的静态资源加载，而对于 picture， user agent 会检查每个 的 srcset、media 和 type 属性，来选择最匹配页面当前布局、显示设备特征等的兼容图像。 这种方案兼容性很强，不过缺陷也很明显，针对 PC 端的确是需要高清图且低网速的场景，它没办法做任何处理。 如果在低像素场景下，低分辨率的图也没办法满足需求时，这个方案也是束手无策的，它的本质还是根据不同页宽来调整资源的分辨率，没办法改变高分辨率资源加载时间长的现状。 不过这两种方案在 C 端中也有广泛的应用，对于多媒体设备，可以针对不同页宽设备选取不同分辨率的资源，对性能也是有很大提高的。 ","date":"2023-02-20","objectID":"/ssr/:11:3","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"webp(推荐) Webp 是谷歌推出的一种新的格式，它可以通过 jpg、png 等主流资源格式转换，达到无损画质的效果，并且相比正常的图片资源，压缩体积会减少到 40% 以上，大量主流浏览器已经支持了webp，并且最近 IOS14 及以上设备的 safari 浏览器也已经新增对 webp 的支持，只有少部分 IOS 低版本还不兼容。 首先，针对静态样式部分的资源进行 webp 相关的转换，转换的方式很简单，可以在 google 上搜索 png to webp，有很多开源免费的转换器帮助进行资源的转换。 资源压缩后，可以看到 webp 对应的大小为 456kb，相比当初的 700kb 减少了近 40%，接下来把它加到代码中，试验一下 3g 场景下实际加载的时间可以优化多少。 styles/globals.css html[data-theme=\"dark\"] { // ... --home-background-icon-webp: url('../public/home_bg_dark.webp'); } html[data-theme=\"light\"] { // ... --home-background-icon-webp: url('../public/home_bg_light.webp'); } 因为一些浏览器还不支持 webp，所以需要对它的兼容性进行判断，在资源请求的请求头 accept 字段中，包含了当前浏览器所支持的静态资源类型，可以通过这个字段来进行判断。 utils/index.ts export const getIsSupportWebp = (context: AppContext) =\u003e { const { headers = {} } = context.ctx.req || {}; return headers.accept?.includes('image/webp'); } 在 _app.tsx 中对所有的组件进行 isSupportWebp 的注入，这样每个页面模板都可以拿到这个字段。 pages/_app.tsx import type { AppProps, AppContext } from 'next/app'; import App from 'next/app'; import Head from 'next/head'; import axios from 'axios'; import ThemeContextProvider from '@/stores/theme'; import UserAgentProvider from '@/stores/userAgent'; import LanguageContextProvider from '@/stores/language'; import { LOCALDOMAIN, getIsMobile, getIsSupportWebp } from '@/utils'; import type { ILayoutProps } from '@/components/layout'; import { appWithTranslation } from 'next-i18next'; import Layout from '@/components/layout'; import '@/styles/globals.css' export interface IDeviceInfoProps { isMobile: boolean; isSupportWebp: boolean; } const MyApp = (data: AppProps \u0026 ILayoutProps \u0026 IDeviceInfoProps) =\u003e { const { Component, pageProps, navbarData, footerData, isMobile, isSupportWebp } = data; return ( \u003cdiv\u003e \u003cHead\u003e \u003ctitle\u003e{`A Demo for 官网开发实战 (${ isMobile ? \"移动端\" : \"pc端\" })`}\u003c/title\u003e \u003cmeta name=\"description\" content=\"A Demo for 官网开发实战\" /\u003e \u003clink rel=\"icon\" href=\"/favicon.ico\" /\u003e \u003cmeta name=\"viewport\" content=\"user-scalable=no\" /\u003e \u003cmeta name=\"viewport\" content=\"initial-scale=1,maximum-scale=1\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width\" /\u003e \u003c/Head\u003e \u003cLanguageContextProvider\u003e \u003cThemeContextProvider\u003e \u003cUserAgentProvider\u003e \u003cLayout navbarData={navbarData} footerData={footerData}\u003e \u003cComponent {...pageProps} isMobile={isMobile} isSupportWebp={isSupportWebp} /\u003e \u003c/Layout\u003e \u003c/UserAgentProvider\u003e \u003c/ThemeContextProvider\u003e \u003c/LanguageContextProvider\u003e \u003c/div\u003e ) } MyApp.getInitialProps = async (context: AppContext) =\u003e { const pageProps = await App.getInitialProps(context); const { data = {} } = await axios.get(`${LOCALDOMAIN}/api/layout`) return { ...pageProps, ...data, isMobile: getIsMobile(context), isSupportWebp: getIsSupportWebp(context), } } export default appWithTranslation(MyApp); 在 index.tsx 中引入对应的 webp 资源。 pages/index.tsx import {useContext, useEffect, useRef, useState} from 'react'; import axios from 'axios'; import type {NextPage} from 'next'; import {Pagination} from '@douyinfe/semi-ui'; import classNames from 'classnames'; import {ThemeContext} from '@/stores/theme'; import {useTranslation} from 'next-i18next'; import {serverSideTranslations} from 'next-i18next/serverSideTranslations'; import styles from '@/styles/Home.module.scss'; import {LOCALDOMAIN} from \"@/utils\"; import {IDeviceInfoProps} from \"@/pages/_app\"; import {IArticleIntroduction} from \"@/pages/api/articleIntroduction\"; import {LanguageContext} from \"@/stores/language\"; import {useRouter} from \"next/router\"; interface IHomeProps { title: string; description: string; articles: { total: number; list: { label: string; info: string; link: string; }[]; }; } const Home: NextPage\u003cIHomeProps \u0026 IDeviceInfoProps\u003e = ({ title, description, articles, isSupportWebp }) =\u003e { const { i18n } = useTranslation(); const router = useRouter(); const { locale } = router; const [content, setContent] = useState(articles); const mainRef = useRef\u003cHTMLDivElement\u003e(null); const { theme } = useContext(ThemeContext); const { language } = useContext(LanguageContext); useEffect(() =\u003e { mainRef.current?.classList.remove(styles.withAnimation); ","date":"2023-02-20","objectID":"/ssr/:11:4","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"IOS 300ms delay 平时的开发中，事件触发大部分都是立刻响应，但是在 IOS 中，移动端的触摸事件会有 300ms 的延迟。 IOS 浏览器有一个特点，可以通过双击来对屏幕页面进行缩放，这是导致 300ms 延迟的核心原因。 因为当一个用户点击链接后，浏览器没办法判定用户是想双击缩放，还是进行点击事件触发，所以 IOS Safari 会统一等待 300ms，来判断用户是否会再次点击屏幕。 ","date":"2023-02-20","objectID":"/ssr/:12:0","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"Meta 禁用缩放(推荐) 300ms 延迟的初衷是为了解决点击和缩放没办法区分的问题，针对不需要缩放的页面，通过禁用缩放来解决。 事实上，大部分移动端页面都是可以避免缩放的，通过交互等样式的兼容即可。 pages/_app.tsx // ./pages/_app.tsx // head加这两行即可 // ... \u003c meta name=\"viewport\" content=\"user-scalable=no\" \u003e \u003c meta name=\"viewport\" content=\"initial-scale=1,maximum-scale=1\" \u003e ","date":"2023-02-20","objectID":"/ssr/:12:1","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"更改视口尺寸 Chrome 浏览器对包含 width=device-width 或者比 viewport 更小的页面禁用双击缩放，只需要加上下面的 meta 头，就可以在 IOS 中的 chrome 浏览器解决 300ms delay 的问题。 这个方案的好处是，并不会完全禁用缩放。但是 IOS 默认的 Safari 浏览器没有支持这个能力，所以可以加上这个 meta 头来兼容视口尺寸，但并不作为这个的解决方案。 \u003cmeta name=\"viewport\" content=\"width=device-width\"\u003e ","date":"2023-02-20","objectID":"/ssr/:12:2","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"Touch-action 在 W3C 草案中，有提出一个 touch-action css 属性，通过设置 touch-action: none 可以移除目标元素的 300ms delay，如果这个日后可以被主流浏览器支持，更推荐用这种方式针对区域进行灵活的限制。 ","date":"2023-02-20","objectID":"/ssr/:12:3","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"fastclick 这是一个老牌的解决 300ms 延迟的轻量 JS 库，可以通过 npm 安装且使用方式简单。 window.addEventListener('load', () =\u003e { FastClick.attach(document.body); }, false); 不建议使用 fastclick 的方式解决这个问题，有几个原因： 对 TS 兼容性太差，fastclick 基于 JS，虽然有 ts for fastclick 的依赖，但是不被原作者认可，并且类型定义存在问题，直接引入依赖存在问题，需要自行进入模块定义中修改。 包体过大，且包八年没再维护。 不能直接用于 SSR，里面有直接用到 BOM，在服务器端渲染的时候会有相关报错，没找到比较好的插件可以兼容这个问题。 ","date":"2023-02-20","objectID":"/ssr/:12:4","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"橡皮筋问题 IOS上，当页面滚动到顶部或底部仍可向下或向上拖拽，并伴随一个弹性的效果。该效果被称为“rubber band”——橡皮筋。 IOS 和安卓不同，即使页面没有设置滚动，仍然可以拉扯，给人一种橡皮筋的感觉，可以看到下面的效果。 那么，怎么解决这个问题呢？ ","date":"2023-02-20","objectID":"/ssr/:13:0","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"overflow 给定宽高 html, body { width: 100%; height: 100%; overflow: hidden; } ","date":"2023-02-20","objectID":"/ssr/:13:1","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"禁用 touchmove 事件 document.body.addEventListener('touchmove', function (e) { e.preventDefault() }, {passive: false}) ","date":"2023-02-20","objectID":"/ssr/:13:2","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"监听滚动禁止 IOS 橡皮筋的原理还是通过滚动，只不过与安卓不同的是，当到边界状态时，仍允许滚动，如果替 IOS 禁用边界的情况，理论上就可以实现对橡皮筋效果的禁用。 import { useEffect } from 'react'; export const useForbidIosScroll = (): void =\u003e { let startEvent: TouchEvent; const cancelEvent = (e: TouchEvent): void =\u003e { // 有个瑕疵就是，如果是大惯性的那种滚动，浏览器该事件并不接受你禁用当前正在执行的动作 // 导致如果猛地滑动会出页面边界 if (e.cancelable) { e.preventDefault(); } }; const checkScroll = (e: TouchEvent): void =\u003e { const startY = Number(startEvent?.touches[0].pageY); const endY = Number(e?.touches[0].pageY); // 下滑且滑动到底 if (startY \u003e endY \u0026\u0026 window.scrollY + window.innerHeight \u003e= document.body.scrollHeight) { cancelEvent(e); } // 上滑且滑动到顶 if (startY \u003c endY \u0026\u0026 window.scrollY \u003c= 0) { cancelEvent(e); } }; useEffect(() =\u003e { const start = (e: TouchEvent): void =\u003e { startEvent = e; }; const end = (e: TouchEvent): void =\u003e { checkScroll(e); }; window.addEventListener('touchstart', start); window.addEventListener('touchmove', end, { passive: false }); return (): void =\u003e { window.removeEventListener('touchstart', start); window.removeEventListener('touchmove', end); }; }, []); }; 这个效果其实并不是很理想，即使脚本已经走到中断的逻辑，滚动的行为在到达边界的时候仍然不会中止。 到谷歌浏览器开发者文档里可以查看到，浏览器的事件其实分为两种，cancelable（可暂停）和 uncancelable（不可暂停），能够通过阻止默认事件的和阻止冒泡的都是可暂停的事件，滚动事件和鼠标滚轮事件，在触发的瞬间，就已经决定了要滚动到终点再停止，你只能暂停可能会影响滚动的前提的导线事件，这个场景下，滚动事件就已经是起源的操作，不存在间接触发，所以不行。 ","date":"2023-02-20","objectID":"/ssr/:13:3","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"简单方案(推荐) 有一个很简单的方案，并且可以完美解决，给 body 进行隐藏，然后对根节点设置 100 页宽的高度，将外部 body 的滚动移动到页面内，这样外界的滚动相关的问题都会解决，因为页面采用的实际是内部滚动。 styles/globals.css .forbidScroll { height: 100vh; overflow: hidden; } body { overflow: hidden; } #__next { height: 100vh; overflow: auto; } 看看改后的效果，发现橡皮筋的功能已经禁用了，因为现在页面采用的是页面内部 div 的滚动，外部 body 的滚动相关的问题也随之解决。 ","date":"2023-02-20","objectID":"/ssr/:13:4","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"前端压力测试 通常在上线前会对这些小流量环境进行预估流量的压测，来预估目前的小流量集群服务器能否承载对应的流量，进而评估一下使用多少服务器集群部署服务，才能足够承载流量，又不至于浪费服务器资源。 基于本地服务压测，对于实际上线，需要先部署在测试服务器，然后对测试环境内网域名进行压测，进而判断能否承受预估的QPS，从而对服务集群进行扩容等操作。 ","date":"2023-02-20","objectID":"/ssr/:14:0","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"WebBench WebBench 是一个在 Linux 下使用的非常简单的网站压测工具。它使用 fork() 模拟多个客户端同时访问设定的 URL，测试网站在压力下工作的性能，最多可以模拟 3 万个并发连接去测试网站的负载能力。 WebBench 不能支持 Windows，只能在 Linux 等类 UNIX 系统下使用。 首先需要安装一下 brew，这是一个针对 macOS 和 Linux 的包管理工具，安装完在终端里直接输入 brew 看下有没有正常输出即可。 /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" 然后装一下 wget，它是 Linux 下的一个安装文件的工具，对应的安装包可以通过它下载下来。 brew install wget 最后来装一下 WebBench。 wget http://www.ha97.com/code/webbench-1.5.tar.gz tar zxvf webbench-1.5.tar.gz // 解压 cd webbench-1.5 make make install 安装完以后，在终端中输入 WebBench 验证一下。 需要关注的参数有两个： -c: 并发量。 -t: 运行时间。 对服务简单压测试验下看看。 可以看到 200 并发就会出现大规模请求异常的情况，不过这个结果算比较简陋的，加上对环境和安装步骤上相对苛刻一些，所以并不推荐使用这个方案。 ","date":"2023-02-20","objectID":"/ssr/:14:1","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"wrk wrk 是一款针对 HTTP 协议的基准测试工具，它能够在单机多核 CPU 的条件下，使用系统自带的高性能 I/O 机制，如 epoll、kqueue 等，通过多线程和事件模式，对目标机器产生大量的负载。 wrk 支持大多数类 UNIX 系统，不支持 Windows。不同的类 UNIX 系统安装方式也略有差异。 装一下 wrk。 brew install wrk 装完可以在终端执行一下 wrk -v验证一下。 上面执行完以后可以看到它列出了 wrk 相关的参数，其中常用到的有三个参数： -c: 保持打开状态的 HTTP 连接总数。 -d: 测试时长。 -t: 使用线程。 其中连接数（c）会平分给每个线程，比如设置 -c200 -t8，那么将启用 8 个线程，每个线程处理 200/8 个请求，可以对 bing 搜索简单试验一下，具体参数其实大部分都是一样的。 这个方案更多是给后端同学测吞吐率用的，包括线程等参数，具体的值不好衡量，对前端不算那么友好。 ","date":"2023-02-20","objectID":"/ssr/:14:2","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"autocannon 一个用 Node 编写的 HTTP/1.1 基准测试工具，受到 wrk 和 wrk2 的极大启发，支持 HTTP 管道和 HTTPS。autocannon 可以产生比 wrk 和 wrk2 更多的负载。 autocannon 可以同时支持 Windows、Mac 和 Linux 的环境，而且作为一个 npm 包，使用上比较符合前端的开发习惯，安装更为方便，使用方式也很轻量。 npm i autocannon -g 它提供了一些参数来对应不同压测指数，常用的有 3 个： -c: 要使用的并发连接数。默认值：10。 -p: 使用流水线请求的数量。默认值：1。 -d: 运行秒数。默认值：10。 首先测试一下默认值的效果。 autocannon http://127.0.0.1:3000 在这个 10s 的执行过程，如果切回 client 可以看到服务在飞快请求。 最后可以得到这样一个数据。 介绍一下每个指标对应什么，先看每列的指标： 2.5% / 50% / 97.5% / 99%：整个过程百分比所对应的值。 Avg: 平均值。 Stdev: 标准差。 Max: 最大值。 对于每行的指标含义是这样的： Latency: 耗时(毫秒)。 Req/Sec: QPS，吞吐量，每秒请求数。 Bytes/Sec: 每秒请求字节数。 这些指标通常在对具体接口或是页面 case by case 的性能分析中会有使用，服务器资源判定只需要关注请求时间是否过长，或是是否存在大面积报错即可，这里可以看到大部分数值是正常的，也没有报错等信息。 接下来把并发量提高到 200，再来看下效果。 autocannon -c 200 http://127.0.0.1:3000 从数据上看，发现所有的数据都清 0 了，说明在这个并发量下单服务器的计算支撑不下去，最下面的请求数据中也有显示 200 个错误， 200 个超时。 这时候切回 client 的终端可以看到，服务已经崩掉了，没办法承载 200 的并发量，如果业务需要，这时候就需要考虑给服务器集群进行扩容操作了。 ","date":"2023-02-20","objectID":"/ssr/:14:3","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"提高搜索引擎排名 ","date":"2023-02-20","objectID":"/ssr/:15:0","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"技术优化 语义化标签 写 toB 项目时，可能会直接用 div 标签作为块级区域的标签，但是对于 SEO 而言，这样的爬取和关键词检索效果是极差的，搜索引擎的索引器在对站点进行分析的过程中，会根据语义化标签来决定不同信息的重要程度，以此来匹配对应的关键词进行推荐。 其中最需要关注的，也最常用的就是站点的 H 标签，有几个需要着重注意的使用事项： H 标签只针对用户可见内容进行设置，图片、链接、写给 robots 可读文字均不在 H 标签使用范围之内。 H1 是一个页面中权重最高，关键词优先级最高的文案，一个页面只能使用一个。 页面中通常只使用 H1 ~ H3，剩下的标题优先级太低，部分搜索引擎不会进行识别。 H 标签通常不使用在文字 logo、 标签栏、侧边栏等每页固定存在的部分。因为这部分不属于这一页的重点，即不是“与众不同” 的区域。 Meta 影响 SEO 有三个重要元素，通常称 TDK（即 title，description，keywords），除这些部分外，还有一些常用的 meta 标签，这些都需要加到模板页面中。 Title: 就是常用的 title 标签。 Description: 页面描述，SEO 的关键。需要注意的是，PC 端下页面描述不要超过 155 个字符，移动端不要超过 120 个字符，如果过长，页面描述会被截断，反而会影响最终的 SEO。 Keywords: 关键词，这个的设定需要注意几点： 每个页面通常设置比较重要的3、4个关键词，不要堆砌，不要过长，更不要只因为热门，就加完全不相关的内容进来蹭热度。 关键词按照由高到低的顺序来排，用逗号分隔。 每个关键词都要是独特的，不要每个关键词意思都差不多。 \u003cmeta name=\"keywords\" content=\"\"/\u003e robots（重要）: 是否开启搜索引擎抓取，noindex 对应是否开启抓取，nofollow 对应不追踪网页的链接，需要开启。 \u003cmeta name=\"robots\" content=\"index, follow\" /\u003e Applicable-device: 告诉 Google，你这个站点适配了哪些设备，不加就是默认 PC 端，将会影响移动端搜索你站点的推送。 \u003cmeta name=\"applicable-device\" content=\"pc,mobile\" /\u003e Format-detection: 在默认状态下，网页的数字会被认为是电话号码（在不同的系统中，显示的格式可能有所不同，比如在 iphone 手机中会有下划线），点击数字会被当作电话号码拨打或者添加到联系人，所以需要禁用。 \u003cmeta name=\"format-detection\" content=\"telephone=no\" /\u003e Sitemap 站点地图是一种文件，您可以在其中提供与您网站中的网页、视频或其他文件有关的信息，还可以说明这些内容之间的关系。Google 等搜索引擎会读取此文件，以便更高效地抓取您的网站。站点地图会告诉 Google 您认为网站中的哪些网页和文件比较重要，还会提供与这些文件有关的重要信息。更多内容请查阅官方文档。 ","date":"2023-02-20","objectID":"/ssr/:15:1","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"内容优化 内容是 SEO 的核心，没有高质量的内容，只通过蹭热门关键词，只会有适得其反的效果。推荐阅读 Google SEO 开发者文档，其中对于内容的部分有非常详细的说明，涵括如何让你的内容有趣，怎么满足读者的需求，以及如何具备权威性和能解决用户的问题等。 SEM 搜索引擎营销的基本思想是让用户发现信息，并通过（搜索引擎）搜索点击进入网站/网页进一步了解他所需要的信息。简单来说 SEM 所做的就是以最小的投入在搜索引擎中获最大的访问量并产生商业价值。SEM的方法包括SEO、付费排名、精准广告以及付费收录等。 ","date":"2023-02-20","objectID":"/ssr/:15:2","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"网站服务部署 站点应用想要部署外网，需要提前准备资源和流程，大体可以分为以下几个步骤： 云服务器：可以理解为在云端上的一台电脑，把服务挂载到对应的端口下，即可通过云服务器公网 IP + 端口的方式进行访问。 域名：可以理解成是云服务器公网 IP 的一个代号，因为 IP 地址不方便记忆，所以采用注册域名并把服务器 IP 解析到对应域名下进行访问，通常域名和站点的内容也有一定的联系，相当于是品牌标识的一个体现，一个好的域名可以成为内容和文化的良好助力，给用户留下不错的印象。 域名 ICP 备案：ICP 证是指各地通信管理部门核发的《中华人民共和国电信与信息服务业务经营许可证》。没有备案通过这个是不可以上线的，ICP 备案成功后，若域名有网站或落地页，则需要在网站底部悬挂工信部下发的 ICP 备案号，并生成链接指向工信部网站。如果未在网站底部添加 ICP 备案号，被相关部门核查出来将处以五千元以上一万元以下罚款，或注销备案号等处罚。 公安备案：根据《计算机信息网络国际联网安全保护管理办法》规定，网站在工信部备案成功后，需在网站开通之日起 30 日内登录 全国互联网安全管理服务平台 提交公安联网备案申请。公安联网备案审核通过后，需要复制网站公安机关备案号和备案编号 HTML 代码，下载备案编号图标，并编辑网页源代码将公安联网备案信息放置在网页底部。 域名解析：把域名指向我们服务器公网 IP 的过程，经过这个步骤，就可以通过域名访问到我们的服务器了。 服务部署：在完成上面步骤后，需要把服务部署到云服务器的对应端口，并解析到域名上，然后用户就可以通过访问注册的域名访问服务了。 ","date":"2023-02-20","objectID":"/ssr/:16:0","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"服务部署 对于服务部署，推荐使用 pm2 来进行部署，当然直接使用 node 然后执行 npm run start 效果上也是可以的。 pm2 具备日志，重启等一套完整能力，可以更容易定位一些问题，所以是部署 node 服务的主流工具，现在在本地以现在的项目示范一下。 首先打开终端，安装一下 pm2。 npm install pm2 -g 安装完成后在终端输入 pm2 试试。 然后分别切到 client 和 server 的目录下执行一下 npm run build，这个是为了构建线上环境启动所需要的产物。 安装完尝试重新构建一下，并且在对应目录下执行 npm run start，如果没有异常，就可以尝试使用 pm2 来启动服务了。 server: client: 在这之前，先简单介绍一下原理，pm2 可以通过执行 pm2 start ${脚本文件} –name ${服务名} 的方式启动，不过要注意，因为执行路径的不同，所以这里使用 npm 的绝对路径执行确保没有问题。 首先执行下面的命令看一下 npm 的目录位置。 which npm 然后切到对应项目目录下，创建一个 shell 脚本，然后写入 ${npm目录} run start 即可。 vi server.sh 类似这样，然后在对应 shell 脚本根目录分别执行 pm2 start server.sh，为了区分还可以给它们加上 –name 名称的参数，执行完以后，再执行 pm2 list，如果看到服务 online，就可以了。 这时候直接访问 http://127.0.0.1:3000，也是可以打开官网的。 如果想要服务器开机的时候自启动，只需要执行下面的命令，保存当前服务并且生成自启动脚本即可。 pm2 save pm2 startup 至于关闭和重启服务，使用 stop 和 restart 即可，类似下面的例子。 值得一提的是，启动的过程可能并不是一帆风顺的，可能会有一些报错，那这时候服务的 status 就会显示 errored，这时候可以通过输出日志的方式来排查，以 server (client) 的服务举例。 pm2 log server --lines 50 日志默认输出是 15 行，这个一般是不够的，可能错误栈都不足够显示完成，这边加上行数的参数，调整为 50 行。 就可以看到和平时开发一样的终端结果了，这时候如果有一些报错可以通过错误栈的信息来快速定位，并且 pm2 提供了持续监听的能力，类似平时开发中的热更新，只需要在 start 命令后加上 –watch 的参数就可以启动，这样当代码发生变化的时候，部署也会同步自动更新。 不过这时候访问还是使用 3000 端口，这样显得奇怪，比如用户在访问百度的时候不可能访问 www.baidu.com:3000吧。 首先安装一下 nginx，同样可以通过 nginx -v 的方式来判断是否安装成功。 brew install nginx 然后需要修改一下对应的配置。 vi /usr/local/etc/nginx/nginx.conf 改这两个部分就好，listen 是监听的端口号，proxy_pass 是希望转发的目标服务，这样就会将 80 端口的服务都转发到 3000 端口上，用户就可以直接通过域名进行访问了。 修改完成后，执行一下 nginx，没有报错的话就已经启动了。 尝试一下直接访问 http://127.0.0.1/ ，可以看到已经可以了，到这里服务部署的部分就全部完成了。 ","date":"2023-02-20","objectID":"/ssr/:16:1","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"总结 ","date":"2023-02-20","objectID":"/ssr/:17:0","tags":["第一技能"],"title":"基于 Nextjs + Strapi 的官网开发实战","uri":"/ssr/"},{"categories":["第一技能"],"content":"项目地址： ElectronVue3 ","date":"2023-02-07","objectID":"/electron/:0:0","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"构建开发环境 按如下步骤搭建开发环境： ","date":"2023-02-07","objectID":"/electron/:1:0","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"创建项目 首先通过命令行创建一个 Vue 项目： npm create vite@latest electron -- --template vue-ts 安装 electron 依赖： npm i electron -D 调整 package.json 文件： { \"name\": \"electron\", \"private\": true, \"version\": \"0.0.0\", \"scripts\": { \"dev\": \"vite\", \"build\": \"vue-tsc --noEmit \u0026\u0026 vite build\", \"preview\": \"vite preview\" }, \"dependencies\": {}, \"devDependencies\": { \"@vitejs/plugin-vue\": \"^4.0.0\", \"electron\": \"^22.0.3\", \"typescript\": \"^4.9.3\", \"vite\": \"^4.0.0\", \"vue-tsc\": \"^1.0.11\", \"vue\": \"^3.2.45\" } } 将 vue 从 dependencies 移到 devDependencies。 在 Vite 编译项目的时候，Vue 库会被编译到输出目录下，输出目录下的内容是完整的，没必要把 Vue 标记为生产依赖；而且在我们将来制作安装包的时候，还要用到这个 package.json 文件，它的生产依赖里不应该有没用的东西。 去掉 type: module 配置项。 package.json 里的 type 定义了这个项目所有 .js 文件的处理方式。 如果 type 的值为 module，那么所有 .js 文件将被当做 ES Modules 对待。如果 type 的值为 commonjs，那么所有 .js 文件将被当做 CommonJS 模块对待。如果没有设置 type，那么它的默认值为 commonjs。 ","date":"2023-02-07","objectID":"/electron/:1:1","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"创建主进程代码 新建主进程入口文件：src/main/mainEntry.ts import { app, BrowserWindow } from \"electron\"; let mainWindow: BrowserWindow; app.whenReady().then(() =\u003e { mainWindow = new BrowserWindow({}); mainWindow.loadURL(process.argv[2]); }); app 是 Electron 的全局对象，用于控制整个应用程序的生命周期。 Electron 初始化完成后，app 对象的 ready 事件被触发。 app ready 后创建一个 BrowserWindow 对象，mainWindow 被设置为一个全局变量，避免被 JS 垃圾回收机制回收。 窗口加载了一个 Url 路径，这个路径以命令行参数（第三个参数）的方式传递给应用程序。 app 和 BrowserWindow 都是 Electron 的内置模块，这些内置模块是通过 ES Module 的形式导入进来的。 ","date":"2023-02-07","objectID":"/electron/:1:2","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"开发环境 Vite 插件 主进程的代码写好后，需要编译过之后才能被 Electron 加载，通过 Vite 插件的形式来完成编译和加载工作。 import { ViteDevServer } from 'vite'; interface IAddressInfo { address: string; port: string; } export let devPlugin = () =\u003e { return { name: 'dev-plugin', configureServer(server: ViteDevServer) { require('esbuild').buildSync({ entryPoints: ['./src/main/mainEntry.ts'], bundle: true, platform: 'node', outfile: './dist/mainEntry.js', external: ['electron'], }); server?.httpServer?.once('listening', () =\u003e { let { spawn } = require('child_process'); let addressInfo: IAddressInfo = server?.httpServer?.address() as unknown as IAddressInfo; let httpAddress = `http://${addressInfo?.address}:${addressInfo?.port}`; let electronProcess = spawn(require('electron').toString(), ['./dist/mainEntry.js', httpAddress], { cwd: process.cwd(), stdio: 'inherit', }); electronProcess.on('close', () =\u003e { server.close(); process.exit(); }); }); }, }; }; 注册了一个名为 configureServer 的钩子，当 Vite 启动 Http 服务时，configureServer 会执行。 入参为类型为 ViteDevServer 的对象 server，server 持有一个 http.Server 类型的属性 httpServer，这个属性代表调试 Vue 页面的 http 服务，一般情况下地址为：http://127.0.0.1:5173/。 通过监听 server.httpServer 的 listening 事件来判断 httpServer 是否已经成功启动。如果已经成功启动，就启动 Electron 应用，并给它传递两个命令行参数，第一个参数是主进程代码编译后的文件路径，第二个参数是 Vue 页面的 http 地址。 通过 Node.js child_process 模块的 spawn 方法启动 electron 子进程，除了两个命令行参数外，还传递了一个配置对象。 这个对象的 cwd 属性用于设置当前的工作目录，process.cwd() 返回的值就是当前项目的根目录。 stdio 用于设置 electron 进程的控制台输出，这里设置 inherit 可以让 electron 子进程的控制台输出数据同步到主进程的控制台。 在主进程中 console.log 的内容就可以在 VSCode 的控制台上看到了。 当 electron 子进程退出的时候，要关闭 Vite 的 http 服务，并且控制父进程退出，准备下一次启动。 http 服务启动之前，使用 esbuild 模块完成了主进程 TypeScript 代码的编译工作，这个模块是 Vite 自带的，不需要额外安装，可以直接使用。 主进程的入口文件是通过 entryPoints 配置属性设置的，编译完成后的输出文件是通过 outfile 属性配置的。 编译平台 platform 设置为 node，排除的模块 external 设置为 electron，这两个设置使在主进程代码中可以通过 import 的方式导入 electron 内置的模块，非但如此，Node 的内置模块也可以通过 import 的方式引入。 在 vite.config.ts 文件中引入： import { defineConfig } from 'vite'; import vue from '@vitejs/plugin-vue'; import { devPlugin } from './plugins/devPlugin'; // https://vitejs.dev/config/ export default defineConfig({ plugins: [devPlugin(), vue()], }) 在 tsconfig.node.json 中配置 plugins 路径： { \"compilerOptions\": { \"composite\": true, \"module\": \"ESNext\", \"moduleResolution\": \"Node\", \"allowSyntheticDefaultImports\": true }, \"include\": [\"vite.config.ts\", \"./plugins/*.*\"] } 执行命令 npm run dev: ","date":"2023-02-07","objectID":"/electron/:1:3","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"渲染进程集成内置模块 现在主进程内可以自由的使用 Electron 和 Node.js 的内置模块了，但渲染进程还不行。 修改主进程代码，打开渲染进程的一些开关，允许渲染进程使用 Node.js 的内置模块: import { app, BrowserWindow } from 'electron'; process.env.ELECTRON_DISABLE_SECURITY_WARNINGS = 'true'; let mainWindow: BrowserWindow; app.whenReady().then(() =\u003e { let config = { webPreferences: { nodeIntegration: true, webSecurity: false, allowRunningInsecureContent: true, contextIsolation: false, webviewTag: true, spellcheck: false, disableHtmlFullscreenWindowResize: true, }, }; mainWindow = new BrowserWindow(config); mainWindow.webContents.openDevTools({ mode: 'undocked' }); mainWindow.loadURL(process.argv[2]); }); ELECTRON_DISABLE_SECURITY_WARNINGS 用于设置渲染进程开发者调试工具的警告，这里设置为 true 就不会再显示任何警告了。 nodeIntegration配置项的作用是把 Node.js 环境集成到渲染进程中。 contextIsolation配置项的作用是在同一个 JavaScript 上下文中使用 Electron API。 webContents的openDevTools方法用于打开开发者调试工具。 现在可以在开发者调试工具中访问 Node.js 和 Electron 的内置模块了。 ","date":"2023-02-07","objectID":"/electron/:1:4","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"设置模块别名与解析钩子 虽然可以在开发者调试工具中使用 Node.js 和 Electron 的内置模块，但现在还不能在 Vue 的页面内使用这些模块。 因为 Vite 主动屏蔽了这些内置的模块，如果开发者强行引入它们，那么大概率会得到如下报错： Module \"xxxx\" has been externalized for browser compatibility and cannot be accessed in client code. 安装 vite-plugin-optimizer： npm i vite-plugin-optimizer -D 修改 vite.config.ts 的代码，让 Vite 加载这个插件： import { defineConfig } from 'vite'; import vue from '@vitejs/plugin-vue'; import { devPlugin, getReplacer } from './plugins/devPlugin'; import optimizer from 'vite-plugin-optimizer'; // https://vitejs.dev/config/ export default defineConfig({ plugins: [optimizer(getReplacer()), devPlugin(), vue()], }) vite-plugin-optimizer 插件会创建一个临时目录：node_modules.vite-plugin-optimizer。 然后把类似 const fs = require(‘fs’); export { fs as default } 这样的代码写入这个目录下的 fs.js 文件中。 渲染进程执行到：import fs from “fs” 时，就会请求这个目录下的 fs.js 文件，这样就达到了在渲染进程中引入 Node 内置模块的目的。 getReplacer 方法是为 vite-plugin-optimizer 插件提供的内置模块列表: export let getReplacer = () =\u003e { let externalModels = ['os', 'fs', 'path', 'events', 'child_process', 'crypto', 'http', 'buffer', 'url', 'better-sqlite3', 'knex']; let result = {}; for (let item of externalModels) { result[item] = () =\u003e ({ find: new RegExp(`^${item}$`), code: `const ${item} = require('${item}'); export { ${item} as default }`, }); } result['electron'] = () =\u003e { let electronModules = ['clipboard', 'ipcRenderer', 'nativeImage', 'shell', 'webFrame'].join(','); return { find: new RegExp(`^electron$`), code: `const {${electronModules}} = require('electron'); export { ${electronModules} }`, } } return result; } 在这个方法中把一些常用的 Node 模块和 electron 的内置模块提供给了 vite-plugin-optimizer 插件，以后想要增加新的内置模块只要修改这个方法即可。 vite-plugin-optimizer 插件不仅用于开发环境，编译 Vue 项目时，它也会参与工作。 通过如下代码在 Vue 组件中做测试： // src\\App.vue import fs from \"fs\"; import { ipcRenderer } from \"electron\"; import { onMounted } from \"vue\"; onMounted(() =\u003e { console.log(fs.writeFileSync); console.log(ipcRenderer); }); 开发者调试工具将会输出如下内容： ","date":"2023-02-07","objectID":"/electron/:1:5","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"构建生产环境 制作一个 Vite 插件。通过这个新的插件生成安装包，有了安装包就可以把应用分发给用户了。 ","date":"2023-02-07","objectID":"/electron/:2:0","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"编译结束钩子函数 vite.config.ts 增加一个新的配置： import { defineConfig } from 'vite'; import vue from '@vitejs/plugin-vue'; import { devPlugin, getReplacer } from './plugins/devPlugin'; import { buildPlugin } from './plugins/buildPlugin'; import optimizer from 'vite-plugin-optimizer'; // https://vitejs.dev/config/ export default defineConfig({ build: { rollupOptions: { plugins: [buildPlugin()], }, }, plugins: [optimizer(getReplacer()), devPlugin(), vue()], }) ","date":"2023-02-07","objectID":"/electron/:2:1","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"制作应用安装包 vite 编译完成之后，也就是执行 npm run build 指令，将在项目dist目录内会生成一系列的文件（如下图所示），此时 closeBundle 钩子被调用，在这个钩子中把上述生成的文件打包成一个应用程序安装包。 import path from 'path'; import fs from 'fs'; class BuildObj { // 编译主进程代码 buildMain() { require('esbuild').buildSync({ entryPoints: ['./src/main/mainEntry.ts'], bundle: true, platform: 'node', minify: true, outfile: './dist/mainEntry.js', external: ['electron'], }); } // 为生产环境准备package.json preparePackageJson() { let pkgJsonPath = path.join(process.cwd(), 'package.json'); let localPkgJson = JSON.parse(fs.readFileSync(pkgJsonPath, 'utf-8')); let electronConfig = localPkgJson.devDependencies.electron.replace('^', ''); localPkgJson.main = 'mainEntry.js'; delete localPkgJson['scripts']; delete localPkgJson['devDependencies']; localPkgJson.devDependencies = { electron: electronConfig, }; let tarJsonPath = path.join(process.cwd(), 'dist', 'package.json'); fs.writeFileSync(tarJsonPath, JSON.stringify(localPkgJson)); fs.mkdirSync(path.join(process.cwd(), 'dist/node_modules')); } // 使用electron-builder制成安装包 buildInstaller() { let options = { config: { directories: { output: path.join(process.cwd(), 'release'), app: path.join(process.cwd(), 'dist'), }, files: ['**'], extends: null, productName: 'Electron', appId: 'com.xxx.desktop', asar: true, nsis: { oneClick: true, perMachine: true, allowToChangeInstallationDirectory: false, createDesktopShortcut: true, createStartMenuShortcut: true, shortcutName: 'ElectronDesktop', }, publish: [{ provider: 'generic', url: 'http://localhost:5500/', }], }, project: process.cwd(), }; return require('electron-builder').build(options); } } export let buildPlugin = () =\u003e { return { name: 'build-plugin', closeBundle: () =\u003e { let buildObj = new BuildObj(); buildObj?.buildMain(); buildObj?.preparePackageJson(); buildObj?.buildInstaller(); } } } 这个对象通过三个方法提供了三个功能： buildMain。由于 ite 在编译之前会清空 dist 目录，所以在之前生成的 mainEntry.js 文件也被删除了，此处通过 buildMain 方法再次编译主进程代码。不过由于此处是在为生产环境编译代码，所以增加了minify: true 配置，生成压缩后的代码。 preparePackageJson。用户安装产品后，在启动应用程序时，实际上是通过 Electron 启动一个 Node.js 的项目，所以要为这个项目准备一个 package.json 文件，这个文件是以当前项目的 package.json 文件为蓝本制作而成的。里面注明了主进程的入口文件，移除了一些对最终用户没用的配置节。 buildInstaller。这个方法负责调用 electron-builder（npm install electron-builder -D 安装 electron-builder 库） 提供的 API 以生成安装包。最终生成的安装包被放置在 release 目录下，这是通过 config.directories.output 指定的。静态文件所在目录是通过 config.directories.app 配置项指定。其他配置项，请自行查阅官网文档。 生成 package.json 文件之后，还创建了一个 node_modules 目录。此举是为了阻止 electron-builder 的一些默认行为（目前来说它会阻止 electron-builder 创建一些没用的目录或文件）。 这段脚本还明确指定了 Electron 的版本号，如果 Electron 的版本号前面有\"^“符号的话，需把它删掉。这是 electron-builder 的一个 Bug，这个 bug 导致 electron-builder 无法识别带 ^ 或 ~ 符号的版本号。 做好这些配置之后，执行 npm run build 就可以制作安装包了，最终生成的安装文件会被放置到 release 目录下。 ","date":"2023-02-07","objectID":"/electron/:2:2","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"主进程生产环境加载本地文件 虽然成功制作了安装包，而且这个安装包可以正确安装应用程序，但是这个应用程序无法正常启动，这是因为应用程序的主进程还在通过 process.argv[2] 加载首页。显然用户通过安装包安装的应用程序没有这个参数。 接下来就要让应用程序在没有这个参数的时候，也能加载静态页面。 新建 src\\main\\CustomScheme.ts： import { protocol } from 'electron'; import path from 'path'; import fs from 'fs'; // 为自定义app协议提供特权 let schemeConfig = { standard: true, supportFetchAPI: true, bypassCSP: true, corsEnabled: true, stream: true, }; protocol.registerSchemesAsPrivileged([{ scheme: 'app', privileges: schemeConfig, }]); export class CustomScheme { // 根据文件扩展名获取mime-type private static getMimeType(extension: string) { let mineType = ''; switch (extension) { case '.js': mineType = 'text/javascript'; break; case '.html': mineType = 'text/html'; break; case '.css': mineType = 'text/css'; break; case '.svg': mineType = 'image/svg+xml'; break; case '.json': mineType = 'application/json'; break; } return mineType; }; // 注册自定义app协议 static registerScheme() { protocol.registerStreamProtocol('app', (request, callback) =\u003e { let pathName = new URL(request.url).pathname; let extension = path.extname(pathName).toLowerCase(); if (extension === '') { pathName = 'index.html'; extension = '.html'; } let tarFile = path.join(__dirname, pathName); callback({ statusCode: 200, headers: { 'content-type': this.getMimeType(extension), }, data: fs.createReadStream(tarFile), }) }); }; } 在主进程 app ready 前，通过 protocol 对象的 registerSchemesAsPrivileged 方法为名为 app 的 scheme 注册了特权（可以使用 FetchAPI、绕过内容安全策略等）。 在 app ready 之后，通过 protocol 对象的 registerStreamProtocol 方法为名为 app 的 scheme 注册了一个回调函数。当加载类似 app://index.html 这样的路径时，这个回调函数将被执行。 这个函数有两个传入参数 request 和 callback，通过 request.url 获取到请求的文件路径，通过 callback 做出响应。 给出响应时，要指定响应的 statusCode 和 content-type，这个 content-type 是通过文件的扩展名得到的。这里通过 getMimeType 方法确定了文件的 content-type。 响应的 data 属性为目标文件的可读数据流，当你的静态文件比较大时，不必读出整个文件再给出响应。 接下来在 src\\main\\mainEntry.ts 中使用这段代码： import {CustomScheme} from './customScheme'; if (process.argv[2]) { mainWindow.loadURL(process.argv[2]); } else { CustomScheme.registerScheme(); mainWindow.loadURL('app\"//index.html'); } 这样当存在指定的命令行参数时，就认为是开发环境，使用命令行参数加载页面，当不存在命令行参数时，就认为是生产环境，通过 app:// scheme 加载页面。 ","date":"2023-02-07","objectID":"/electron/:2:3","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"设计工程项目结构 在继续引入新的模块或组件之前，先调整一下工程的结构： dist 目录是打包过程的临时产物放置目录。 plugins 目录放置开发环境 vite 插件和打包 vite 插件。 release 目录放置最终生成的安装包。 resource 目录放置一些外部资源，比如应用程序图标、第三方类库等。 src/common 目录放置主进程和渲染进程都会用到的公共代码，比如日期格式化的工具类、数据库访问工具类等，主进程和渲染进程的代码都有可能使用这些类。 src/main 目录放置主进程的代码。 src/model 目录放置应用程序的模型文件，比如消息类、会话类、用户设置类等，主进程和渲染进程的代码都有可能使用这些类。 src/renderer 目录放置渲染进程的代码。 src/renderer/assets 放置字体图标、公共样式、图片等文件。 src/renderer/components 放置公共组件，比如标题栏组件、菜单组件等。 src/renderer/store 目录存放 Vue 项目的数据状态组件，用于在不同的 Vue 组件中共享数据。 src/renderer/router 目录存放 Vue 项目的路由配置信息。 src/renderer/indow 目录存放不同窗口的入口组件，这些组件是通过 vue-router 导航的，这个目录下的子目录存放对应窗口的子组件。 src/renderer/App.vue 是渲染进程的入口组件，这个组件内只有一个用于导航到不同的窗口。 src/renderer/main.ts 是渲染进程的入口脚本。 index.html 是渲染进程的入口页面。 vite.config.ts 是 vite 的配置文件。 调整好工程结构后，要修改一下 index.html 的代码才能让这些调整生效。实际上就是修改一下渲染进程入口脚本的引入路径: \u003cscript type=\"module\" src=\"/src/renderer/main.ts\"\u003e\u003c/script\u003e ","date":"2023-02-07","objectID":"/electron/:3:0","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"引入 vue-router 安装 vue-router 模块： npm install vue-router@4 -D 安装完成后，为 src/renderer/router/index.ts 添加如下代码逻辑： import * as VueRouter from 'vue-router'; // 路由规则数组 const routes = [{ path: '/', redirect: '/WindowMain/Chat', }, { path: '/WindowMain', component: () =\u003e import('../window/WindowMain.vue'), children: [{ path: 'Chat', component: () =\u003e import('../window/WindowMain/Chat.vue'), }, { path: 'Contact', component: () =\u003e import('../window/WindowMain/Contact.vue'), }, { path: 'Collection', component: () =\u003e import('../window/WindowMain/Collection.vue'), },] }, { path: '/WindowSetting', component: () =\u003e import('../window/WindowSetting.vue'), children: [ { path: 'AccountSetting', component: () =\u003e import('../window/WindowSetting/AccountSetting.vue'), } ] }, { path: '/WindowUserInfo', component: () =\u003e import('../window/WindowUserInfo.vue'), }] export let router = VueRouter.createRouter({ history: VueRouter.createWebHistory(), routes, }); 这段代码导出了一个 router 对象，这个 router 对象是基于 WebHistory 模式创建路由的，也就是说页面路径看起来是这样的：http://127.0.0.1:5173/WindowMain/PageChat（开发环境），app://index.html/WindowMain/PageChat（生产环境）。 上述代码中 routes 数组里的内容就是导航的具体配置，在这些配置中使用 import 方法动态引入 Vue 组件，vite 在处理这种动态引入的组件时，会把对应的组件编译到独立的源码文件中，类似 WindowUserInfo.689249b8.js 和 WindowSetting.6354f6d6.js，这种编译策略可以帮助控制最终编译产物的大小，避免应用启动时就加载一个庞大的 JavaScript 文件。 在应用启动时请求的路径是：”/\"，这个路径被重定向到\"/WindowMain/Chat\"，也就是说 WindowMain 组件和 Chat 组件是首页组件（这是在第一个导航配置对象中设置的）。 上述代码完成后，需要在 main.ts 中使用它，代码如下： import { createApp } from 'vue'; import './style.css'; import { router } from './router'; import App from './App.vue'; createApp(App).use(router).mount('#app'); 接下来把 App.vue 的代码修改成如下内容： \u003ctemplate\u003e \u003crouter-view /\u003e \u003c/template\u003e 应用启动时，第一个窗口（主窗口）就会加载 src\\renderer\\window\\WindowMain.vue 组件的代码。 当在主窗口内打开别的子窗口时（弹出一个子窗口），只要加载类似这样的路径/WindowUserInfo，就可以让子窗口加载 src\\renderer\\Window\\WindowUserInfo.vue 这个组件。 ","date":"2023-02-07","objectID":"/electron/:4:0","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"菜单组件及跳转 在 src\\renderer\\components 目录下新建 BarLeft.vue 的组件，这是整个应用的侧边栏组件，里面放置应用程序的菜单： \u003ctemplate\u003e \u003cdiv class=\"BarLeft\"\u003e \u003cdiv class=\"userIcon\"\u003e \u003cimg src=\"../assets/avatar.jpg\" alt=\"\"\u003e \u003c/div\u003e \u003cdiv class=\"menu\"\u003e \u003crouter-link v-for=\"item in mainWindowRoutes\" :to=\"item.path\" :class=\"['menuItem', {'selected': item.isSelected}]\"\u003e \u003ci :class=\"['icon', item.isSelected ? item.iconSelected : item.icon]\"\u003e\u003c/i\u003e \u003c/router-link\u003e \u003c/div\u003e \u003cdiv class=\"setting\"\u003e \u003cdiv class=\"menuItem\"\u003e \u003ci class=\"icon icon-setting\" /\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript setup lang=\"ts\"\u003e import { ref, watch } from 'vue'; import { useRoute } from 'vue-router'; let mainWindowRoutes = ref([ { path: '/WindowMain/Chat', isSelected: true, icon: 'icon-chat', iconSelected: 'icon-chat' }, { path: '/WindowMain/Contact', isSelected: false, icon: 'icon-tongxunlu1', iconSelected: 'icon-tongxunlu' }, { path: '/WindowMain/Collection', isSelected: false, icon: 'icon-shoucang1', iconSelected: 'icon-shoucang' }, ]) let route = useRoute(); watch( () =\u003e route, () =\u003e mainWindowRoutes.value.forEach(v =\u003e v.isSelected = v.path === route.fullPath), { immediate: true, deep: true, }) \u003c/script\u003e \u003cstyle scoped lang=\"scss\"\u003e .BarLeft { width: 54px; height: 100%; display: flex; flex-direction: column; background: rgb(46, 46, 46); -webkit-app-region: drag; } .userIcon { height: 84px; padding-top: 36px; box-sizing: border-box; img { width: 34px; height: 34px; margin-left: 10px; } } .menu { flex: 1; } .menuItem { height: 44px; line-height: 44px; text-align: center; padding-left: 12px; padding-right: 12px; display: block; text-decoration: none; color: rgb(126, 126, 126); cursor: pointer; -webkit-app-region: no-drag; i { font-size: 22px; } \u0026:hover { color: rgb(141, 141, 141); } } .selected { color: rgb(7, 193, 96); \u0026:hover { color: rgb(7, 193, 96); } } .setting { margin-bottom: 5px; } \u003c/style\u003e 样式为 menu 的 div 用于存放主窗口的菜单，通过 mainWindowRoutes 数组里的数据来渲染菜单。 router-link 组件会被渲染成 a 标签，当用户点击菜单时，主窗口的二级路由发生跳转（src\\renderer\\window\\WindowMain.vue）。 通过 watch 方法监控路由跳转的行为，当路由跳转后，遍历 mainWindowRoutes 数组内的对象，取消以前选中的菜单，选中新的菜单。 由于 mainWindowRoutes 是一个 Ref 对象，所以菜单被选中或取消选中之后，相应的菜单样式（和菜单内的字体图标）也会跟着变化。 在 WindowMain.vue 中添加如下代码： \u003cscript setup lang=\"ts\"\u003e import { ipcRenderer } from \"electron\"; import { onMounted } from \"vue\"; import BarLeft from \"../components/BarLeft.vue\"; onMounted(() =\u003e { ipcRenderer.invoke(\"showWindow\"); }); \u003c/script\u003e \u003ctemplate\u003e \u003cBarLeft /\u003e \u003cdiv class=\"pageBox\"\u003e \u003crouter-view /\u003e \u003c/div\u003e \u003c/template\u003e \u003cstyle scoped lang=\"scss\"\u003e .pageBox { flex: 1; height: 100%; border-top: 1px solid #e6e6e6; box-sizing: border-box; display: flex; margin-top: -1px; } \u003c/style\u003e ","date":"2023-02-07","objectID":"/electron/:5:0","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"引入字体图标 在 www.iconfont.cn/ 获得字体图标，Electron 使用 Chromium 核心，一般情况下只使用 iconfont.css 和 iconfont.ttf 这两个文件。把这两个文件放到 src/renderer/assets/icon 下，在 main.ts 导入一下 iconfont.css 就可以全局使用字体图标了。 import { createApp } from 'vue'; import './style.css'; import \"./assets/icon/iconfont.css\"; import { router } from './router'; import App from './App.vue'; createApp(App).use(router).mount('#app'); \u003ci class=\"icon icon-chat\"\u003e\u003c/i\u003e 如果 iconfont.ttf 足够小，那么 vite 会把它转义成 base64 编码的字符串，直接嵌入到样式文件中来达到少请求数量的目的，开发者可以通过在 vite.config.ts 中增加 build.assetsInlineLimit 配置（值设置为 0 即可）来关闭 vite 的这个行为。 运行项目： ","date":"2023-02-07","objectID":"/electron/:6:0","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"管控应用窗口 如何管控应用内的窗口，比如：什么时候显示窗口、如何通过自定义窗口标题栏来管控单个窗口等内容。 ","date":"2023-02-07","objectID":"/electron/:7:0","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"主窗口显示时机 在第一个窗口初始化的瞬间，会有一个黑窗口闪现一下，如下图所示： 按照 Electron 官网的建议，窗口一开始应该是隐藏的，在 ready-to-show 事件触发后再显示窗口，如下代码所示： const { BrowserWindow } = require(\"electron\"); const win = new BrowserWindow({ show: false }); win.once(\"ready-to-show\", () =\u003e { win.show(); }); 但这个事件的触发太早了，因为 Vue 项目的 HTML 加载之后，JavaScript 脚本还需要做很多事情才能把组件渲染出来。况且开发者可能还会在 Vue 组件初始化的早期做很多额外的工作，所以显示窗口不能依赖 ready-to-show 事件，必须手动控制。 主窗口对象 mainWindow 初始化时，把配置属性 show 设置为 false，就可以让主窗口初始化成功后处于隐藏状态。 接下来再在合适的时机让渲染进程控制主窗口显示出来即可。这里在 WindowMain.vue 组件渲染完成之后来完成这项工作，如下代码所示： import { ipcRenderer } from \"electron\"; import { onMounted } from \"vue\"; onMounted(() =\u003e { ipcRenderer.invoke(\"showWindow\"); }); ","date":"2023-02-07","objectID":"/electron/:7:1","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"自定义窗口标题栏 在 src/renderer/components 下新建 BarTop.vue，这是窗口标题栏组件： \u003ctemplate\u003e \u003cdiv class=\"topBar\"\u003e \u003cdiv class=\"winTitle\"\u003e{{ title }}}\u003c/div\u003e \u003cdiv class=\"winTool\"\u003e \u003cdiv @click=\"minimizeMainWindow\"\u003e \u003ci class=\"icon icon-minimize\"/\u003e \u003c/div\u003e \u003cdiv v-if=\"isMaximized\" @click=\"unmaximizeMainWindow\"\u003e \u003ci class=\"icon icon-restore\"/\u003e \u003c/div\u003e \u003cdiv v-else @click=\"maxmizeMainWin\"\u003e \u003ci class=\"icon icon-maximize\"/\u003e \u003c/div\u003e \u003cdiv @click=\"closeWindow\"\u003e \u003ci class=\"icon icon-close\"/\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript lang=\"ts\" setup\u003e \u003c/script\u003e \u003cstyle lang=\"scss\" scoped\u003e .topBar { display: flex; height: 25px; line-height: 25px; -webkit-app-region: drag; /* 可拖拽区域 */ width: 100%; } .winTitle { flex: 1; padding-left: 12px; font-size: 14px; color: #888; } .winTool { height: 100%; display: flex; -webkit-app-region: no-drag; /* 可拖拽区域内的不可拖拽区域 */ } .winTool div { height: 100%; width: 34px; text-align: center; color: #999; cursor: pointer; line-height: 25px; } .winTool .icon { font-size: 10px; color: #666666; font-weight: bold; } .winTool div:hover { background: #efefef; } .winTool div:last-child:hover { background: #ff7875; } .winTool div:last-child:hover i { color: #fff !important; } \u003c/style\u003e 要自定义一个窗口的标题栏必须把窗口默认的标题栏取消掉才行。只需要在初始化 mainWindow 对象时（主进程里的逻辑），把窗口配置对象的 frame 属性设置为 false 就可以使这个窗口成为无边框窗口了。 窗口标题是通过 props 数据传递给标题栏组件的，也就是说标题栏的标题是由其父组件来确定的。 标题栏中可拖拽区域是通过样式 -webkit-app-region: drag 定义的，鼠标在这个样式定义的组件上拖拽可以移动窗口，双击可以放大或者还原窗口，如果这个组件内有子组件不希望拥有该能力，可以通过 -webkit-app-region: no-drag; 来取消此能力。 最大化、最小化、还原、关闭窗口等按钮的点击事件，都是通过 ipcRenderer.invoke 方法来调用主进程 CommonWindowEvent 类提供的消息管道来实现对应的功能的。 由于窗口最大化（或还原）不一定是通过点击最大化按钮（或还原按钮）触发的，有可能是通过双击标题栏可拖拽区域触发的，所以这里只能通过 ipcRenderer.on 来监听窗口的最大化或还原事件，以此来改变对应的最大化或还原按钮的显隐状态。不能在按钮点击事件中来完成这项工作。windowMaximized 消息和 windowUnmaximized 消息也是由主进程的 CommonWindowEvent 类发来的。 由于多个二级路由页面会引用 BarTop.vue，为了避免在切换路由的时候，反复通过 ipcRenderer.on 注册消息监听器，所以在组件的 onUnmounted 事件内注销了消息监听器，避免事件泄漏。 src/main/CommonWindowEvent.ts 的代码如下： import { BrowserWindow, ipcMain, app } from 'electron'; // 主进程公共消息处理逻辑 export class CommonWindowEvent { private static getWin(event: any) { return BrowserWindow.fromWebContents(event.sender); } public static listen() { ipcMain.handle('minimizeWindow', e =\u003e { this.getWin(e)?.minimize(); }); ipcMain.handle('maxmizeWindow', e =\u003e { this.getWin(e)?.maximize(); }); ipcMain.handle('unmaximizeWindow', e =\u003e { this.getWin(e)?.unmaximize(); }); ipcMain.handle('hideWindow', e =\u003e { this.getWin(e)?.hide(); }); ipcMain.handle('showWindow', e =\u003e { this.getWin(e)?.show(); }); ipcMain.handle('closeWindow', e =\u003e { this.getWin(e)?.close(); }); ipcMain.handle('resizable', e =\u003e this.getWin(e)?.isResizable()); ipcMain.handle('getPath', (e, name) =\u003e app.getPath(name)); } // 主进程公共事件处理逻辑 public static regWinEvent(win: BrowserWindow) { win.on('maximize', () =\u003e { win.webContents.send('windowMaximized'); }); win.on('unmaximize', () =\u003e { win.webContents.send('windowUnmaximized'); }) } } 在 listen 方法内部注册了一系列消息管道，方便渲染进程控制主进程的一些行为，标题栏组件的窗口的最大化、最小化、还原等功能都是在这里实现的。在 app ready 之后调用 CommonWindowEvent.listen(); 这个方法即可注册这些消息管道。 regWinEvent 方法负责为窗口对象注册事件，当窗口最大化或还原后，这些事件的处理函数负责把消息发送给渲染进程。标题栏的对应按钮的图标也会发生相应的变化，同样也是在 app ready 之后调用 CommonWindowEvent.regWinEvent(mainWindow); 这个方法即可。 在 src/main/mainEntry.ts 下添加如下代码： import {app, BrowserWindow} from 'electron'; import {CustomScheme} from \"./customScheme\"; import { CommonWindowEvent } from \"./CommonWindowEvent\"; process.env.ELECTRON_DISABLE_SECURITY_WARNINGS = 'true'; let mainWindow: BrowserWindow; // 调用 CommonWindowEvent.regWinEvent(win); app.on(\"browser-window-created\", (e, win) =\u003e { CommonWindowEvent.regWinEvent(win); }); app.whenReady().then(() =\u003e { let config = { webPreferences: { nodeIntegration: true, webSecurity: false, allowRunningInsecureContent: true, contextIsolation: false, webviewTag: true, spellcheck: false, disableHtmlFullscreenWindowResize: true, }, }; mainWindow = new BrowserWindow(config); mainWindow.webContents.openDevTools({mode: 'undocked'}); if (process.argv[2]) { mainWindow.loadURL(process.argv[2]); } else { CustomScheme.regi","date":"2023-02-07","objectID":"/electron/:7:2","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"窗口加载过慢解决方案 Electron 创建一个 BrowserWindow 对象，并让它成功渲染一个页面是非常耗时的，在一个普通配置的电脑上，这大概需要 2~5 秒左右的时间（少量用户反馈没这个问题）。 窗口池解决方案 提前准备 1 个或多个隐藏的窗口，让它们加载一个骨架屏页面，放到一个数组里，当应用程序需要打开一个新窗口时，就从这个数组里取出一个窗口，执行页内跳转，从骨架屏页面跳转到业务页面，然后再把这个窗口显示出来。这就消费掉了一个窗口。 当应用程序消费掉一个窗口之后，马上再创建一个新的加载了骨架屏页面的窗口放入数组，保证有足够的待命隐藏窗口。 当用户关闭某个加载了业务页面的窗口时，就把它从数组中删除掉。避免数组里存在无用的窗口。 这个方案之所以行之有效是因为在没有使用窗口时就提前准备好了窗口，等真正需要使用窗口时，仅仅是完成了一次页面跳转的工作，这个跳转工作可以在很短的时间内就完成。所以给用户的感知就是打开子窗口特别快。 webview 和 BrowserView 创建慢的问题也可以使用类似的方案解决。 然而这个方案有以下三个缺点。 无法优化整个应用的第一个窗口。 系统内部始终会有 1 到 2 个隐藏窗口处于待命状态，这无形中增加了用户的内存消耗。 虽然这个方案看上去逻辑比较简单，但要控制好所有的细节（比如，窗口间的通信、界面代码如何控制窗口的外观、如何实现模态子窗口等）还是非常繁琐的。 window.open 解决方案 Electron 允许使用 window.open 的方式打开一个子窗口，通过这种方式打开的子窗口不会创建新的进程，效率非常高，可以在几百毫秒内就为用户呈现窗口内容。 但对于一些复杂的需求却需要额外的处理才能满足需求，比如：系统设置子窗口，当用户完成某一项设置之后，要通知父窗口做出相应的改变。这是常见的父子窗口通信的需求。 首先需要为主窗口的 webContents 注册 setWindowOpenHandler 方法。 在 src/main/CommonWindowEvent.ts 中添加如下代码： mainWindow.webContents.setWindowOpenHandler((param) =\u003e { return { action: \"allow\", overrideBrowserWindowOptions: yourWindowConfig }; }); 使用 setWindowOpenHandler 方法的回调函数返回一个对象，这个对象中 action: “allow” 代表允许窗口打开，如果你想阻止窗口打开，那么只要返回 {action: “deny”} 即可。 返回对象的 overrideBrowserWindowOptions 属性的值是被打开的新窗口的配置对象。 在渲染进程中打开子窗口的代码如下所示: window.open(`/WindowSetting/AccountSetting`); window.open 打开新窗口之所以速度非常快，是因为用这种方式创建的新窗口不会创建新的进程。这也就意味着一个窗口崩溃会拖累其他窗口跟着崩溃（主窗口不受影响）。 使用 window.open 打开的新窗口还有一个问题，这类窗口在关闭之后虽然会释放掉大部分内存，但有一小部分内存无法释放（无论你打开多少个子窗口，全部关闭之后总会有那么固定的一小块内存无法释放），这与窗口池方案的内存损耗相当。 接下来介绍如何使用这个方案控制子窗口。 子窗口的标题栏消息 自定义主窗口的标题栏 BarTop.vue，标题栏组件需要监听主进程发来的 windowMaximized 消息和 windowUnmaximized 消息，子窗口当然也希望复用这个组件，然而子窗口的窗口对象是在 Electron 内部创建的，不是开发者创建的，没有子窗口的窗口对象，该如何使用 regWinEvent 方法为子窗口注册最大化和还原事件呢？ 这就需要用到 app 对象的 browser-window-created 事件，代码如下： // src/main/mainEntry.ts app.on(\"browser-window-created\", (e, win) =\u003e { CommonWindowEvent.regWinEvent(win); }); 每当有一个窗口被创建成功后，这个事件就会被触发，主窗口和使用 window.open 创建的子窗口都一样，这个事件的第二个参数就是窗口对象。 动态设置子窗口的配置 虽然可以在渲染进程中用 window.open 方法打开一个子窗口，但这个子窗口的配置信息目前还是在主进程中设置的（overrideBrowserWindowOptions），大部分时候要根据渲染进程的要求来改变子窗口的配置，所以最好的办法是由渲染进程来设置这些配置信息。 在 CommonWindowEvent 类的 regWinEvent 方法增加一段逻辑，代码如下： // 注册打开子窗口的回调函数 // @ts-ignore win.webContents.setWindowOpenHandler((param) =\u003e { // 基础窗口配置对象 let config = { frame: false, show: true, parent: null, webPreferences: { nodeIntegration: true, webSecurity: false, allowRunningInsecureContent: true, contextIsolation: false, webviewTag: true, spellcheck: false, disableHtmlFullscreenWindowResize: true, nativeWindowOpen: true, }, }; // 开发者自定义窗口配置对象 let features = JSON.parse(param.features); for (let p in features) { if (p === \"webPreferences\") { for (let p2 in features.webPreferences) { //@ts-ignore config.webPreferences[p2] = features.webPreferences[p2]; } } else { //@ts-ignore config[p] = features[p]; } } // @ts-ignore if (config[\"modal\"] === true) config.parent = win; // 允许打开窗口，并传递窗口配置对象 return {action: \"allow\", overrideBrowserWindowOptions: config}; }); config 对象和主窗口的 config 对象基本上是一样的，所以最好把它抽象出来。 param 参数的 features 属性是由渲染进程传过来的，是一个字符串，这里把它当作一个 JSON 字符串使用，这个字符串里包含着渲染进程提供的窗口配置项，这些配置项与 config 对象提供的基础配置项结合，最终形成了子窗口的配置项。 如果配置项中 modal 属性的值为 true 的话，说明渲染进程希望子窗口为一个模态窗口，这时要为子窗口提供父窗口配置项：parent，这个配置项的值就是当前窗口。 之所以把这段逻辑放置在 CommonWindowEvent 类的 regWinEvent 方法中，就是希望更方便地为应用内的所有窗口提供这项能力，如果不希望这么做，也可以把这段逻辑放置在一个独立的方法中。 在 src/renderer/components/BarLeft.vue 中添加如下代码： const openSettingWindow = () =\u003e { const config = { modal: true, width: 2002, webPreferences: { webviewTag: false } }; window.open(`/WindowSetting/AccountSetting`, \"_blank\", JSON.stringify(config)); }; window.open 方法的第三个参数官方定义为一个逗号分割的 key-value 列表，但这里把它变成了一个 JSON 字符串，这样做主要是为了方便地控制子窗口的配置对象。 使用 window.open 打开新窗口速度非常快，所以这里直接让新窗口显示出来了 config.show = true。如果你需要在新窗口初始化时完成复杂耗时的业务逻辑，那么你也应该手动控制新窗口的显示时机。 封装子窗口加载成功的事件 现在遇到了一个问题：不知道子窗口何时加载成功了，注意这里不能单纯地使用 window 对象的 onload 事件或者 document 对象的 DOMContentLoaded 事件来判断子窗口是否加载成功了。因为这个时候你的业务代码（比如从数据库异步读取数据的逻辑）可能尚未执行完成。 所以，要自己封装一个事件，在业务代码真正执行完成时，手动发射这个事件，告知主窗口：“现在子窗口已经加载成功啦，你可以给我发送消息了！” 在封装这个事件前，先来把 window.open 打开子窗口的逻辑封装到一个 Promise 对象中，如下代码所示： src/renderer/common/Dialog.ts ex","date":"2023-02-07","objectID":"/electron/:7:3","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"Pinia 管理应用状态 相比 Vuex，Pinia 的优势主要是： 没有 mutations，相应的工作都在 actions 中完成，actions 直接支持异步函数。 完美支持 TypeScript，Vuex 在这方面做得不是很好。 对开发工具支持友好，，Pinia 对调试工具（vue-devtools）也支持友好。 不需要再使用名称空间来控制 store，也不需要再考虑 store 的嵌套问题。 性能优于 Vuex。 ","date":"2023-02-07","objectID":"/electron/:8:0","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"安装 Pinia npm i pinia -D 修改渲染进程入口文件，加载 Pinia 插件： src/renderer/main.ts import {createApp} from 'vue'; import {router} from './router'; import { createPinia } from \"pinia\"; import App from './App.vue'; import './style.css'; import \"./assets/icon/iconfont.css\"; createApp(App).use(createPinia()).use(router).mount('#app'); ","date":"2023-02-07","objectID":"/electron/:8:1","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"创建 Store 在 src/renderer/store 目录下新建 index.ts，创建第一个 Store 程序，代码如下： import { defineStore } from 'pinia'; import { Ref, ref } from 'vue'; import { ModelChat } from '../../model/ModelChat'; // mock data const prepareData = () =\u003e { let result = []; for (let i = 0; i \u003c 10; i++) { let model = new ModelChat(); model.fromName = '聊天对象' + i; model.sendTime = '昨天'; model.lastMsg = '这是此会话的最后一条消息' + i; model.avatar = 'https://pic3.zhimg.com/v2-306cd8f07a20cba46873209739c6395d_im.jpg?source=32738c0c'; result.push(model); } return result; }; export const useChatStore = defineStore('chat', () =\u003e { let data: Ref\u003cModelChat[]\u003e = ref(prepareData()); const selectItem = (item: ModelChat) =\u003e { if (item.isSelected) return; data.value.forEach((v) =\u003e (v.isSelected = false)); item.isSelected = true; }; return { data, selectItem }; }); 通过 export 暴露 useChatStore 方法，这个方法通过 Pinia 的 defineStore 方法创建，在 Vue 业务组件中执行这个函数实例才会得到真正的 Store。 使用 defineStore(name, callback) 的形式创建 Store，这种形式的 Store 叫作 Setup Stores。Pinia 还提供了另一种形式的 Store ：Option Stores，具体可以参阅 Pinia 的官方文档。 这个 Store 的状态数据存储在：data 属性中，这是一个被 Ref 对象包裹着的数组，数组里的内容是通过 prepareData 方法模拟的（模拟了十个聊天会话对象）。 这个 Store 还提供了一个 actions 方法：selectItem，这个方法用于选中某个具体的聊天会话。 ","date":"2023-02-07","objectID":"/electron/:8:2","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"数据模型 Model 聊天会话的数据模型是在 src/model 目录下定义的，因为应用的主进程和渲染进程都可能会用到数据模型，所以把它放置在 renderer 和 main 的同级目录下。 新建 src/model/ModelChat.ts，如下所示： import { ModalBase } from './ModalBase'; export class ModelChat extends ModalBase { fromName?: string; sendTime?: string | number; isSelected = false; lastMsg?: string; avatar?: string; // 0 单聊，1 群聊，2 公众号，3 文件传输助手 chatType?: number; } 模型主要用于描述对象携带的信息，由于所有的模型都会拥有一些共同的字段，所以把这些字段放置在模型的基类 ModelBase 中。 新建 src/model/ModelBase.ts，如下所示： import crypto from 'crypto'; export class ModalBase { id: string; constructor() { this.id = crypto.randomUUID(); } } 暂时只提供了一个公共字段：id，凡继承于 ModelBase 的子类都将拥有这个字段，而且这个字段是随模型实例化的时候自动创建的。 只有 new ModelXXXX 时才会创建这个字段，let model = obj as ModelXXXX 时不会创建这个字段。 使用 Node.js crypto 模块的 randomUUID 方法来生成每个聊天会话的 ID。 ","date":"2023-02-07","objectID":"/electron/:8:3","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"使用 Store 首先把模型中模拟的 10 个聊天会话显示在界面上，代码如下所示： src/renderer/window/WindowMain/chat/components/ChatBoard.vue \u003ctemplate\u003e \u003cdiv class=\"ChatList\"\u003e \u003cChatSearch /\u003e \u003cdiv class=\"ListBox\"\u003e \u003cChatItem :data=\"item\" v-for=\"item in store.data\" :key=\"item.id\" /\u003e \u003c/div\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript setup lang=\"ts\"\u003e import ChatItem from './ChatItem.vue'; import ChatSearch from './ChatSearch.vue'; import { onMounted } from 'vue'; import { useChatStore } from '../../../../store/useChatStore'; const store = useChatStore(); onMounted(() =\u003e { store.selectItem(store.data[6]); }); \u003c/script\u003e \u003cstyle scoped lang=\"scss\"\u003e .ChatList { width: 250px; display: flex; flex-direction: column; height: 100%; box-sizing: border-box; } .ListBox { background: rgb(230, 229, 229); background-image: linear-gradient(to bottom right, rgb(235, 234, 233), rgb(240, 240, 240)); flex: 1; overflow-y: auto; box-sizing: border-box; border-right: 1px solid rgb(214, 214, 214); } \u003c/style\u003e 通过 Vue 的 v-for 指令渲染了一个自定义组件列表（ChatItem）。 store 对象是通过 useChatStore 方法获取的，useChatStore 方法就是前面介绍的 useChatStore.ts 导出的方法。得到 store 对象之后，可以直接使用 store.data 获取 Store 对象里的数据。 在当前组件 ChatBoard 渲染完成后，调用了 store 对象的 selectItem 方法，选中了第 7 个会话。 具体每一个聊天会话对象是通过自定义组件的 data 属性传递到组件内部的。 ChatItem 自定义组件的代码如下所示： src/renderer/window/WindowMain/chat/components/ChatItem.vue \u003ctemplate\u003e \u003cdiv @click=\"itemClick(data)\" :class=\"['ChatItem', { 'ChatItemSelected': data.isSelected}]\"\u003e \u003cdiv class=\"avatar\"\u003e \u003cimg :src=\"data.avatar\" alt=\"\" /\u003e \u003c/div\u003e \u003cdiv class=\"ChatInfo\"\u003e \u003cdiv class=\"row\"\u003e \u003cdiv class=\"FromName\"\u003e{{ data.fromName }}\u003c/div\u003e \u003cdiv class=\"TimeName\"\u003e{{ data.sendTime }}\u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"row\"\u003e \u003cdiv class=\"LastMsg\"\u003e{{ data.lastMsg }}\u003c/div\u003e \u003cdiv class=\"subscribe\" /\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript lang=\"ts\" setup\u003e import { ModelChat } from '../../../../../model/ModelChat'; import { useChatStore } from '../../../../store/useChatStore'; defineProps\u003c{data: ModelChat}\u003e(); const store = useChatStore(); const itemClick = (item: ModelChat) =\u003e { store.selectItem(item); }; \u003c/script\u003e \u003cstyle scoped lang=\"scss\"\u003e .ChatItem { display: flex; height: 66px; box-sizing: border-box; cursor: pointer; \u0026:hover { background: rgb(221, 219, 218); } } .ChatItemSelected { background: rgb(196, 196, 196); \u0026:hover { background: rgb(196, 196, 196); } } .avatar { width: 66px; display: flex; align-items: center; justify-content: center; img { width: 46px; height: 46px; } } .ChatInfo { flex: 1; height: 66px; display: flex; flex-direction: column; justify-content: center; } .row { box-sizing: border-box; height: 28px; line-height: 28px; display: flex; } .FromName { flex: 1; } .TimeName { color: rgb(153, 153, 153); padding-right: 12px; font-size: 12px; } .LastMsg { color: rgb(153, 153, 153); flex: 1; font-size: 12px; } \u003c/style\u003e 使用 defineProps 方法接收父组件传来的数据。 聊天会话对象里的数据在这个自定义组件中被展开，渲染给用户。 当用户点击这个自定义组件的时候，程序执行了 Store 对象的 selectItem 方法，这个方法负责选中用户点击的组件，改变了用户点击组件的样式，同时还取消了原来选中的组件。 ","date":"2023-02-07","objectID":"/electron/:8:4","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"订阅 Store 无论是用户点击 ChatItem 组件选中一个聊天会话，还是 ChatBoard 渲染完成后选中一个聊天会话，都应该通知其他组件，选中的聊天会话变更了。 在 MessageBoard 组件中演示这个功能，代码如下所示： src/renderer/window/WindowMain/chat/components/MessageBoard.vue \u003ctemplate\u003e \u003cdiv class=\"MessageBord\"\u003e \u003cBarTop /\u003e \u003cdiv class=\"MessageList\"\u003e{{ logInfo }}\u003c/div\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript lang=\"ts\" setup\u003e import { ref } from 'vue'; import BarTop from '../../../../components/BarTop.vue'; import { useChatStore } from '../../../../store/useChatStore'; let store = useChatStore(); let logInfo = ref(\"\"); let curId = \"\"; //订阅Store内数据的变化 store.$subscribe((mutations, state) =\u003e { let item = state.data.find((v) =\u003e v.isSelected); let id = item?.id as string; if (id != curId) { logInfo.value = `现在应该加载ID为${item?.id}的聊天记录`; curId = id; } }); \u003c/script\u003e \u003cstyle scoped lang=\"scss\"\u003e .MessageBord { height: 100%; display: flex; flex: 1; flex-direction: column; } .MessageList { flex: 1; overflow-y: auto; overflow-x: hidden; background: rgb(245, 245, 245); } \u003c/style\u003e 使用 store 对象的 $subscribe 方法订阅了数据变更事件，无论什么时候 store 内的数据发生了变化，都会执行 $subscribe 方法提供的回调函数。 在订阅回调中，验证选中的会话是否发生了变化（有可能是当前 store 其他数据对象的变化触发了订阅回调），如果是，那么就给出提示。 订阅回调函数有两个参数 ，第一个是 mutations 参数，这个参数的 events 属性携带着变更前的值和变更后的值，但这个属性只有在开发环境下存在，生产环境下不存在。订阅的第二个参数是 state，这个参数包含 store 中的数据。 以这种方式更新 store 里的数据，不利于复用数据更新的逻辑，改用可以复用数据更新逻辑的方案。 ","date":"2023-02-07","objectID":"/electron/:8:5","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"互访 Store 新建一个模型类，代码如下所示： src/model/ModelMessage.ts import { ModalBase } from './ModalBase'; export class ModelMessage extends ModalBase { createTime?: number; receiveTime?: number; messageContent?: string; chatId?: string; fromName?: string; avatar?: string; // 是否为传入消息 isInMsg?: boolean; } 创建 useMessageStore，用于管理消息的状态数据，代码如下： src/renderer/store/useMessageStore.ts import { ModelChat } from '../../model/ModelChat'; import { ModelMessage } from '../../model/ModelMessage'; import { defineStore } from 'pinia'; import { ref, Ref } from 'vue'; export const useMessageStore = defineStore('message', () =\u003e { let data: Ref\u003cModelMessage[]\u003e = ref([]); const msg1 = `醉里挑灯看剑，梦回吹角连营。八百里分麾下灸，五十弦翻塞外声。沙场秋点兵。马作的卢飞快，弓如霹雳弦惊。了却君王天下事，嬴得生前身后名。可怜白发生`; const msg2 = `怒发冲冠，凭栏处，潇潇雨歇。抬望眼，仰天长啸，壮怀激烈。 三十功名尘与土，八千里路云和月。莫等闲，白了少年头，空悲切！ 靖康耻，犹未雪；臣子恨，何时灭?驾长车，踏破贺兰山缺！ 壮志饥餐胡虏肉，笑谈渴饮匈奴血。待从头，收拾旧山河，朝天阙！`; const initData = (chat: ModelChat) =\u003e { let result = []; for (let i = 0; i \u003c 10; i++) { let model = new ModelMessage(); model.createTime = Date.now(); model.isInMsg = i % 2 === 0; model.messageContent = model.isInMsg ? msg1 : msg2; model.fromName = model.isInMsg ? chat.fromName : \"我\"; model.avatar = chat.avatar; model.chatId = chat.id; result.push(model); } data.value = result; }; return { data, initData }; }); 消息数据是模拟出来的，这里模拟了 10 条消息，预期用户切换会话的时候，执行 initData 方法，初始化当前会话的消息。 修改一下 MessageBoard 组件的的代码，如下所示： src/renderer/window/WindowMain/chat/components/MessageBoard.vue \u003ctemplate\u003e \u003cdiv class=\"MessageBord\"\u003e \u003cBarTop /\u003e \u003cdiv class=\"MessageList\"\u003e \u003cMessageItem :data=\"item\" v-for=\"item in messageStore.data\" :key=\"item.id\"\u003e\u003c/MessageItem\u003e \u003c/div\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript lang=\"ts\" setup\u003e import BarTop from '../../../../components/BarTop.vue'; import { ModelChat } from '../../../../../model/ModelChat'; import { useMessageStore } from '../../../../store/useMessageStore'; import { useChatStore } from '../../../../store/useChatStore'; import MessageItem from './MessageItem.vue'; const chatStore = useChatStore(); const messageStore = useMessageStore(); let curId = ''; chatStore.$subscribe((mutations, state) =\u003e { const item = state.data.find(v =\u003e v.isSelected) as ModelChat; if (item?.id !== curId) { messageStore.initData(item); curId = item?.id; } }) \u003c/script\u003e \u003cstyle scoped lang=\"scss\"\u003e .MessageBord { height: 100%; display: flex; flex: 1; flex-direction: column; } .MessageList { flex: 1; overflow-y: auto; overflow-x: hidden; background: rgb(245, 245, 245); } \u003c/style\u003e 当选中的聊天会话切换时，执行 messageStore 对象的 initData 方法，这样就初始化了 messageStore 内部的状态数据。 MessageItem 是新创建的一个 Vue 组件，这个组件用于显示一条消息的具体信息。代码如下所示： src/renderer/window/WindowMain/chat/components/MessageItem.vue \u003ctemplate\u003e \u003ctemplate v-if=\"data.isInMsg\"\u003e \u003cdiv class=\"MessageItem left\"\u003e \u003cdiv class=\"avatar\"\u003e \u003cimg :src=\"data.avatar\" alt=\"\" /\u003e \u003c/div\u003e \u003cdiv class=\"MessageBox\"\u003e \u003cdiv class=\"FromName\"\u003e{{ data.fromName }}\u003c/div\u003e \u003cdiv class=\"MsgContent\"\u003e{{ data.messageContent }}\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/template\u003e \u003ctemplate v-else\u003e \u003cdiv class=\"MessageItem right\"\u003e \u003cdiv class=\"MessageBox\"\u003e \u003cdiv class=\"MessageContent\"\u003e{{ data.messageContent }}\u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"avatar\"\u003e \u003cimg :src=\"data.avatar\" alt=\"\" /\u003e \u003c/div\u003e \u003c/div\u003e \u003c/template\u003e \u003c/template\u003e \u003cscript setup lang=\"ts\"\u003e import { ModelMessage } from '../../../../../model/ModelMessage'; defineProps\u003c{ data: ModelMessage }\u003e(); \u003c/script\u003e \u003cstyle lang=\"scss\" scoped\u003e .MessageItem { display: flex; padding-top: 8px; padding-bottom: 8px; position: relative; } .left { padding-right: 30%; \u0026::after { width: 0; height: 0; border-top: 6px solid transparent; border-bottom: 6px solid transparent; border-right: 6px solid #fff; position: absolute; left: 60px; top: 38px; content: \"\"; } } .right { padding-left: 30%; \u0026::after { width: 0; height: 0; border-top: 6px solid transparent; border-bottom: 6px solid transparent; border-left: 6px solid rgb(149, 236, 105); position: absolute; right: 60px; top: 18px; content: \"\"; } .MessageContent { background: rgb(149, 236, 105) !important; } } .avatar { width: 66px; text-align: center; img { width: 46","date":"2023-02-07","objectID":"/electron/:8:6","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"客户端数据库 如何把应用内的业务数据持久化到用户本地磁盘上。 对于简单的数据类型来说，可以直接把它们存储在 localStorage 中，这些数据是持久化在用户磁盘上的，不会因为用户重启应用或者重装应用而丢失。 对于稍微复杂的数据类型来说，有两个选择，其一是把这类数据存储在 IndexedDB 中，与 localStorage 类似，这也是谷歌浏览器核心提供的数据持久化工具，它以 JSON 对象的方式存储数据，数据较多时，复杂的条件查询效率不佳。 第二个选择就是把数据存储在 SQLite 中，这是一个关系型数据库，天生对复杂条件查询支持良好。 ","date":"2023-02-07","objectID":"/electron/:9:0","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"安装 SQLite npm install better-sqlite3 -D 这个模块安装完成后，大概率是无法使用这个模块的，可能会碰到如下报错信息： Error: The module '...node_modules\\better-sqlite3\\build\\Release\\better_sqlite3.node' was compiled against a different Node.js version using NODE_MODULE_VERSION $XYZ. This version of Node.js requires NODE_MODULE_VERSION $ABC. Please try re-compiling or re-installing the module (for instance, using `npm rebuild` or `npm install`). 这是因为 Electron 内置的 Node.js 的版本可能与你编译原生模块使用的 Node.js 的版本不同导致的。 建议开发者使用 Electron 团队提供的 electron-rebuild 工具来完成此工作，因为 electron-rebuild 会确定 Electron 的版本号、Electron 内置的 Node.js 的版本号、以及 Node.js 使用的 ABI 的版本号，并根据这些版本号下载不同的头文件和类库。 安装 electron-rebuild： npm install electron-rebuild -D 在 package.json 中增加如下配置节（scripts配置节）： \"rebuild\": \"electron-rebuild -f -w better-sqlite3\" 在工程根目录下执行如下指令： npm run rebuild 当你的工程下出现了这个文件 node_modules/better-sqlite3/build/Release/better_sqlite3.node，才证明 better_sqlite3 模块编译成功了，如果上述指令没有帮你完成这项工作，你可以把指令配置到 node_modules/better-sqlite3 模块内部再执行一次，一般就可以编译成功了（如下图所示）。 这样就为 Electron 重新编译了一遍 better-sqlite3，现在就可以在 Electron 应用内使用 better-sqlite3 提供的 API 了。 在应用中试试如下代码（渲染进程和主进程均可，甚至在渲染进程的开发者调试工具中也没问题），看是不是可以正确创建 SQLite 的数据库。 const Database = require(\"better-sqlite3\"); const db = new Database(\"db.db\", { verbose: console.log, nativeBinding: \"./node_modules/better-sqlite3/build/Release/better_sqlite3.node\" }); 不出意外的话，工程根目录下将会创建一个名为 db.db 的 SQLite 数据库文件，说明 better-sqlite3 库已经生效了。 ","date":"2023-02-07","objectID":"/electron/:9:1","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"压缩安装包体积 better-sqlite3 是一个原生模块，原生模块是无法被 vite 编译到 JavaScript 的，那为什么还要把它安装成开发依赖呢？ 把 better-sqlite3 安装成开发依赖，在功能上没有任何问题，electron-builder 在制作安装包时，会自动为安装包附加这个依赖（better-sqlite3 这个库自己的依赖也会被正确附加到安装包内）。 但electron-builder 会把很多无用的文件（很多编译原生模块时的中间产物）也附加到安装包内。无形中增加了安装包的体积（大概 10M），如下图所示： 在 plugins/buildPlugin.ts 中增加一个方法： async prepareSqlite() { // 拷贝 better-sqlite3 const srcDir = path.join(process.cwd(), 'node_modules/better-sqlite3'); const destDir = path.join(process.cwd(), 'dist', 'node_modules/better-sqlite3'); fs.ensureDirSync(destDir); fs.copySync(srcDir, destDir, { filter: (src, dest) =\u003e { if (src.endsWith('better-sqlite3') || src.endsWith('build') || src.endsWith('Release') || src.endsWith('better_sqlite3.node')) { return true; } else return src.includes('node_modules\\\\better-sqlite3\\\\lib'); } }); let pkgJson = '{\"name\": \"better-sqlite3\",\"main\": \"lib/index.js\"}'; let pkgJsonPath = path.join(process.cwd(), 'dist', 'node_modules/better-sqlite3/package.json'); fs.writeFileSync(pkgJsonPath, pkgJson); // 制作bindings模块 const bindingPath = path.join(process.cwd(), 'dist', 'node_modules/bindings/index.js'); fs.ensureDirSync(bindingPath); const bindingsContent = `module.exports = () =\u003e { let addonPath = require(\"path\").join(__dirname, '../better-sqlite3/build/Release/better_sqlite3.node'); return require(addonPath); };`; fs.writeFileSync(bindingPath, bindingsContent); pkgJson = '{\"name\": \"bindings\",\"main\": \"index.js\"}'; pkgJsonPath = path.join(process.cwd(), 'dist', 'node_modules/bindings/package.json'); fs.writeFileSync(pkgJsonPath, pkgJson); } 这段代码主要做了两个工作： 把开发环境的 node_modules/better-sqlite3 目录下有用的文件拷贝到 dist/node_modules/better-sqlite3 目录下，并为这个模块自制了一个简单的 package.json。 完全自己制作了一个 bindings 模块，把这个模块放置在 dist/node_modules/bindings 目录下。 closeBundle 钩子函数中调用这个方法：buildObj.prepareSqlite()。 这里 bindings 模块是 better-sqlite3 模块依赖的一个模块，它的作用仅仅是确定原生模块文件 better_sqlite3.node 的路径。 接下来再修改一下 BuildObj的preparePackageJson 方法，在生成 package.json 文件之前，为其附加两个生产依赖，代码如下： localPkgJson.dependencies['better-sqlite3'] = '*'; localPkgJson.dependencies['bindings'] = '*'; 有了这两个配置，electron-builder 就不会自动安装这些模块了。 完成这些工作后，在 closeBundle 钩子函数中调用这个方法： buildObj.prepareSqlite()，再打包看看，安装包的体积是否变小了呢？ ","date":"2023-02-07","objectID":"/electron/:9:2","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"安装 Knex.js 成功引入 better-sqlite3 并且压缩了 better-sqlite3 模块在安装包的体积后，面临着另一个问题需要解决。 使用 better-sqlite3 读写数据库中的数据时，要书写 SQL 语句，这种语句是专门为数据库准备的指令，下面是为 sqlite 数据库建表和在对应表中完成增删改查的 SQL 语句： create table admin(username text,age integer); insert into admin values('allen',18); select * from admin; update admin set username='allen001',age=88 where username='allen' and age=18; delete from admin where username='allen001'; 使用 Knex.js 可以来完成对应的操作，Knex.js 允许使用 JavaScript 代码来操作数据库里的数据和表结构，它会把 JavaScript 代码转义成具体的 SQL 语句，再把 SQL 语句交给数据库处理，可以把它理解为一种 SQL Builder。 npm install knex -D 打包之前编译这个库，代码如下所示： plugins/buildPlugin.ts prepareKnex() { let pkgJsonPath = path.join(process.cwd(), 'dist', 'node_modules/knex'); fs.ensureDirSync(pkgJsonPath); require('esbuild').buildSync({ entryPoints: ['./node_modules/knex/knex.js'], bundle: true, platform: 'node', format: 'cjs', minify: true, outfile: './dist/node_modules/knex/index.js', external: ['oracledb', 'pg-query-stream', 'pg', 'sqlite3', 'tedious', 'mysql', 'mysql2', 'better-sqlite3'], }); let pkgJson = `{\"name\": \"bindings\",\"main\": \"index.js\"}`; pkgJsonPath = path.join(process.cwd(), 'dist', 'node_modules/knex/package.json'); fs.writeFileSync(pkgJsonPath, pkgJson); } 相对于压缩 better-sqlite3 的体积来说，压缩 Knex.js 包的体积就简单多了，仅仅是通过 esbuild 工具编译了一下这个包的代码就完成了工作。 这段代码有以下几点需要注意。 配置项 external 是为了避免编译过程中 esbuild 去寻找这些模块而导致编译失败，也就是说 Knex.js 中这样的代码会保持原样输出到编译产物中： require(‘better-sqlite3’)。 package.json 增加一个生产依赖：localPkgJson.dependencies[‘knex’] = ‘*’;，以避免 electron-builder 安装 Knex.js 模块。 closeBundle 钩子函数中调用这个方法：buildObj.prepareKnex()。 ","date":"2023-02-07","objectID":"/electron/:9:3","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"访问数据库 新建数据库 db，数据库中有两张表 Message 和 Chat，截图是 Chat 表的列： 数据库设计好之后，创建一个数据库访问类，由于主进程的逻辑和渲染进程的逻辑都有可能会访问数据库，所以把数据库访问类放置在 src/common 目录下，方便两个进程的逻辑代码使用这个类，代码如下： src/common/db.ts import knex, { Knex} from 'knex'; import fs from 'fs'; import path from 'path'; let dbInstance: Knex; // @ts-ignore if (!dbInstance) { let dbPath = process.env.APPDATA || `${process.env.HOME}${process.platform === 'darwin' ? '/Library/Preferences' : '/.local/share'}`; dbPath = path.join(dbPath, 'Electron'); const dbIsExist = fs.existsSync(dbPath); if (!dbIsExist) { console.log(process.execPath) const resourceDbPath = path.join(process.execPath, '../resources/db.db'); fs.copyFileSync(resourceDbPath, dbPath); } dbInstance = knex({ client: 'better-sqlite3', connection: { filename: dbPath }, useNullAsDefault: true, }) } export let db = dbInstance; 导出一个数据库访问对象，只有第一次引入这个数据库访问对象的时候才会执行此对象的初始化逻辑，无论在多少个组件中引入这个数据库访问对象，它只会被初始化一次，但这个约束只局限在一个进程内，也就是说对于整个应用而言，主进程有一个 db 实例，渲染进程也有一个 db 实例，两个实例是完全不同的。 由于渲染进程内的数据库访问对象和主进程内的数据库访问对象不是同一个对象，所以会有并发写入数据的问题，需要控制好你的业务逻辑，避免两个进程在同一时间写入相同的业务数据。 SQLite 不支持并发写入数据，两个或两个以上的写入操作同时执行时，只有一个写操作可以成功执行，其他写操作会失败。并发读取数据没有问题。 第一次初始化数据库链接对象时，会检查 MacintoshHD/用户/[yourOsUserName]/资源库/ApplicationSupport/[yourAppName]/db.db 文件是否存在，如果不存在，就从应用程序安装目录 MacintoshHD/用户/[yourOsUserName]/资源库/ApplicationSupport/[yourAppName]/resources/db.db 拷贝一份到该路径下，所以要提前把数据库设计好，基础数据也要初始化好，制作安装包的时候，把数据库文件打包到安装包里。 通过为 plugins/buildPlugin.ts 增加配置来把数据库文件打包到安装包内的，其中关键的配置代码如下所示： // buildInstaller 方法内 option.config 的一个属性 extraResources: [{ from: `./src/common/db.db`, to: `./` }] extraResources 可以让开发者为安装包指定额外的资源文件，electron-builder 打包应用时会把这些资源文件附加到安装包内，当用户安装应用程序时，这些资源会释放在安装目录的 resources/子目录下。 为什么要把数据库文件拷贝再访问，不直接访问安装目录下的数据库文件呢？ 因为当用户升级应用程序时安装目录下的文件都会被删除，因为可能会在数据库中放置很多用户数据，这样的话每次升级应用用户这些数据就都没了。 假定数据库是整个应用的核心组件，没有它，数据库应用程序无法正常运行，所以初始化数据库的逻辑都是同步操作（fs.copyFileSync），注意这类以 Sync 结尾的方法都是同步操作，它们是会阻塞 JavaScript 的执行线程的，也就是说在它们执行过程中，其他任何操作都会处于阻塞状态。 在应用程序开发调试阶段，开发者可以先把设计好的数据库文件放置在目标路径 MacintoshHD/用户/[yourOsUserName]/资源库/ApplicationSupport/[yourAppName] 下。 db.ts 文件导出的是一个 Knex 类型的对象，初始化这个对象时，传入一个配置对象，配置对象的 client 属性代表着使用什么模块访问数据库，这里要求 Knex 使用 better-sqlite3 访问数据库，Knex 支持很多数据库，比如 MySql、Oracle、SqlServer 等，都有对应的数据库访问模块。 由于 SQLite 是一个客户端数据库，所以只要把数据库的本地路径告知 Knex 即可，这个属性是通过配置对象的 connection 属性提供的。配置对象的 useNullAsDefault 属性告知 Knex 把开发者未明确提供的数据配置为 Null。 接下来尝试使用这个数据库访问对象把 Chat 表的数据检索出来，代码如下所示： src/renderer/main.ts import { db } from \"../common/db\"; db(\"Chat\") .first() .then((obj) =\u003e { console.log(obj); }); 首先创建一个数据库连接对象 db，接着使用这个对象读取 Chat 表里的第一行记录，数据读取成功后把这行数据打印到控制台。 ","date":"2023-02-07","objectID":"/electron/:9:4","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"数据库基本操作 增加数据 增加一条数据： src/renderer/window/WindowMain/Contact.vue const insertData = async () =\u003e { let model = new ModelChat(); model.fromName = \"聊天对象\"; model.sendTime = Date.now(); model.lastMsg = \"这是此会话的最后一条消息\"; model.avatar = `https://pic3.zhimg.com/v2-306cd8f07a20cba46873209739c6395d_im.jpg?source=32738c0c`; await db(\"Chat\").insert(model); }; 如果要在同一张表中增加多行数据，那么可以直接把一个数组提交给数据库： const insertMultiData = async () =\u003e { let result = []; for (let i = 0; i \u003c 10; i++) { let model = new ModelChat(); model.fromName = \"聊天对象\" + i; model.sendTime = Date.now(); model.lastMsg = \"这是此会话的最后一条消息\" + i; model.avatar = `https://pic3.zhimg.com/v2-306cd8f07a20cba46873209739c6395d_im.jpg?source=32738c0c`; result.push(model); } result[5].isSelected = true; await db(\"Chat\").insert(result); }; 查询数据 const selectData = async () =\u003e { let data = await db(\"Chat\").where({ id: `256d6532-fcfe-4b81-a3f8-ee940f2de3e3` }).first(); console.log(data); }; 修改数据 const updateData = async () =\u003e { let data = await db(\"Chat\").update({ fromName: \"三岛由纪夫\", lastMsg: \"就在刀刃猛然刺入腹部的瞬间，一轮红日在眼睑背面粲然升了上来。\" }).where({ id: `256d6532-fcfe-4b81-a3f8-ee940f2de3e3` }); console.log(data); }; 需要使用 where 方法确定更新范围，不然整个表的数据都将被修改 (数据库操作返回的值 data 为受影响的行数) 。 删除数据 let deleteData = async () =\u003e { let data = await db(\"Chat\").where({ id: `256d6532-fcfe-4b81-a3f8-ee940f2de3e3` }).delete(); console.log(data); }; 需要使用 where 方法确定删除范围，不然整个表的数据都将被删除（数据库操作返回的值 data 为受影响的行数）。 事务 数据库的事务是一个操作序列，包含了一组数据库操作指令。 事务把这组指令作为一个整体向数据库提交操作请求，这一组数据库命令要么都执行，要么都不执行，是一个不可分割的工作逻辑单元。 const transaction = async () =\u003e { try { await db.transaction(async (trx) =\u003e { let chat = new ModelChat(); chat.fromName = \"聊天对象aaa\"; chat.sendTime = Date.now(); chat.lastMsg = \"这是此会话的最后一条消息\"; chat.avatar = `https://pic3.zhimg.com/v2-306cd8f07a20cba46873209739c6395d_im.jpg?source=32738c0c`; await trx(\"Chat\").insert(chat); // throw \"throw a error\"; let message = new ModelMessage(); message.fromName = \"聊天对象\"; message.chatId = chat.id; message.createTime = Date.now(); message.isInMsg = true; message.messageContent = \"这是我发给你的消息\"; message.receiveTime = Date.now(); message.avatar = `https://pic3.zhimg.com/v2-306cd8f07a20cba46873209739c6395d_im.jpg?source=32738c0c`; await trx(\"Message\").insert(message); }); } catch (error) { console.error(error); } }; 把两个插入操作封装到了一个事务中，两个插入操作要么都成功执行，要么一个也不执行，可以把 throw “throw a error” 语句取消注释，观察一下数据库的数据更新情况。 db.transaction 方法的回调函数中 trx 就是 Knex 封装的数据库事务对象。 分页查询 分页从数据库中获取数据。 import { ref, Ref } from 'vue'; // 当前是第几页 let currentPageIndex: Ref\u003cnumber\u003e = ref(0); // 每页数据行数 let rowCountPerPage: Ref\u003cnumber\u003e = ref(6); // 总页数 let pageCount: Ref\u003cnumber\u003e = ref(-1); // 获取某一页数据 const getOnePageData = async () =\u003e { let data = await db('Chat') .orderBy('sendTime', 'desc') .offset(currentPageIndex.value * rowCountPerPage.value) .limit(rowCountPerPage.value); console.log(data); } // 获取第一页数据 const getFirstPage = async () =\u003e { if (pageCount.value === -1) { // @ts-ignore let { count } = await db('Chat').count('id as count').first(); count = count as number; pageCount.value = count / rowCountPerPage.value as number; } currentPageIndex.value = 0; await getOnePageData(); } // 获取下一页数据 const getNextPage = async () =\u003e { currentPageIndex.value = currentPageIndex.value + 1 \u003e= pageCount.value ? Math.ceil(pageCount.value) - 1 : currentPageIndex.value + 1; await getOnePageData(); } // 获取上一页数据 const getPrevPage = async () =\u003e { currentPageIndex.value = currentPageIndex.value - 1 \u003c 0 ? 0 : currentPageIndex.value - 1; await getOnePageData(); } // 获取最后一页数据 const getLastPage = async () =\u003e { currentPageIndex.value = Math.ceil(pageCount.value) - 1; await getOnePageData(); } 获取第一页数据时，初始化总页数和当前页码数，总页数是通过数据库中的总行数除以每页行数得到的，这个值有可能包含小数部分。当前页码数是从零开始的整数。第一页时，它的值为 0。 获取下一页数据时，判断当前页码数是不是到达了最后一页，如果没有，那么就把当前页码数加 1，考虑到总页数存在小数的可能，所以最后一页的当前页码数应为：Math.ceil(pageCount) - 1。Math.ceil() 函数返回大于或等于一个给定数字的最小整数。 Math.ceil(6.11) 的结果为 7，Math.ceil(6) 的结果为 6。 获取上一页数据时，判断当前页码数是不是小于 0，如果是，就把当前页码数置为 0，如果不是就把当前页码数减一。 获取最后一页数据时，把当前页码数置为 Math.ceil(pageCount) - 1 即可。 每次获取数据都调用 getOnePageData 方法。这个方法中","date":"2023-02-07","objectID":"/electron/:9:5","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"开发原生模块 Node.js 允许开发者使用 C、C++ 等语言开发原生模块。并且遵循此方案开发出的原生模块可以像普通的 Node.js 模块一样通过 require() 函数加载，并使用 JavaScript 访问模块提供的 API。 Node.js 具备原生模块的能力还有以下原因： 性能提升： JavaScript 是解释型语言，相对于系统级语言来说性能上还是略有不足。 节约成本：有很多现成的 C/C++ 项目，在 Node.js 项目中直接复用这些项目可以节约很多开发成本。 能力拓展：Node.js 不是万能的，需要 C/C++ 的能力来辅助完成。 如何在 Electron 应用中使用原生模块？ ","date":"2023-02-07","objectID":"/electron/:10:0","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"搭建开发环境 一种方式是通过 Node-API 开发原生模块，Node-API 是专门用于构建原生模块，它独立于底层 JavaScript 运行时，并作为 Node.js 的一部分进行维护。 它是跨 Node.js 版本的应用程序二进制接口（Application Binary Interface，ABI），旨在将原生模块与底层实现隔离开，并允许为某个 Node.js 版本编译的模块在更高版本的 Node.js 上运行而无需重新编译。 不同版本的 Node.js 使用同样的接口为原生模块提供服务，这些接口是 ABI 化的，只要 ABI 的版本号一致，编译好的原生模块就可以直接使用，不需要重新编译。 基于 Node-API 开发原生模块仍存在两种方式。 一种方式就是使用 C 语言开发，由于 Node-API 就是用 C 语言封装的，所以这种方法更为直接，由于 C 语言过于简单直接，语言特性较少，所以开发起来非常麻烦。 另一种方式是基于 node-addon-api 使用 C++ 语言开发，node-addon-api 项目是对 Node-API 的 C++ 再包装，这种方式可以精简很多代码。 全局安装 node-gyp 工具，它是专门为构建开发、编译原生模块环境而生的跨平台命令行工具。 npm install -g node-gyp 新建一个 Node.js 项目，安装 node-addon-api: src 目录下新建文件夹 native。 初始化 Node.js 项目： npm init -y npm install node-addon-api 创建原生模块配置文件 binding.gyp: { \"targets\": [ { \"cflags!\": [\"-fno-exceptions\"], \"cflags_cc!\": [\"-fno-exceptions\"], \"defines\": [\"NAPI_DISABLE_CPP_EXCEPTIONS\"], \"target_name\": \"addon\", \"include_dirs\": [\"\u003c!(node -p \\\"require('node-addon-api').include_dir\\\")\"], \"sources\": [\"export.cc\"], \"conditions\": [ [ 'OS==\"mac\"', { \"sources\": [\"clipboard.mm\"], \"link_settings\": { \"libraries\": [\"-framework Cocoa\", \"-framework CoreFoundation\"] }, \"xcode_settings\": { \"GCC_ENABLE_CPP_EXCEPTIONS\": \"YES\", \"CLANG_ENABLE_OBJC_ARC\": \"YES\", \"OTHER_CFLAGS\": [\"-ObjC++\", \"-std=c++17\"] } } ], [ 'OS==\"win\"', { \"sources\": [\"clipboard.cc\"], \"libraries\": [\"Shlwapi.lib\", \"Shcore.lib\"], \"msvs_settings\": { \"VCCLCompilerTool\": { \"AdditionalOptions\": [\"/std:c++17\"] } } } ] ] } ] } include_dirs 配置 node-addon-api 项目提供的 C++ 头文件所在路径。 defines、cflags_cc!、 cflags!起到禁用 C++ 异常的作用（注意，如果选择禁用 C++ 异常，那么 node-addon-api 框架将不再为开发者处理异常，需要自己检查异常）。 sources 指向这个原生模块的入口文件。 target_name 为原生模块的名称。 ","date":"2023-02-07","objectID":"/electron/:10:1","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"读取剪切板文件路径 Electron 公开的剪切板 API 是无法读取剪切板内多个文件的路径的，开发一个原生模块来补全 Electron 在这方面的不足。 创建原生模块的入口文件： src/native/export.cc #include \u003cnapi.h\u003e #include \u003ctuple\u003e #include \"clipboard.h\" Napi::Array ReadFilePathsJs(const Napi::CallbackInfo \u0026info) { auto env = info.Env(); const auto file_paths = ReadFilePaths(); auto result = Napi::Array::New(env, file_paths.size()); for (size_t i = 0; i != file_paths.size(); ++i) { result.Set(i, file_paths[i]); } return result; } Napi::Object Init(Napi::Env env, Napi::Object exports) { exports.Set(\"readFilePaths\", Napi::Function::New(env, ReadFilePathsJs)); return exports; } NODE_API_MODULE(NODE_GYP_MODULE_NAME, Init); NODE_API_MODULE 定义此原生模块的入口函数，一旦 Node.js 加载该模块时，将执行 Init 方法，NODE_GYP_MODULE_NAME 宏展开后为编译配置文件 binding.gyp 中的 target_name。 Init 方法是这个模块的入口函数，这个函数包含两个参数，第一个是 JavaScript 运行时环境对象，第二个是模块的导出对象（也就是 module.exports），给这个对象设置属性，以导出想要暴露给外部的内容，此处导出了 ReadFilePathsJs 方法，当外部调用此方法时，将执行 ReadFilePathsJs 函数。入口函数退出时应把 exports 对象返回给调用方。 ReadFilePathsJs 方法执行时调用方会传入一个 CallbackInfo 类型的参数，它是一个由 Node.js 传入的对象，该对象包含 JavaScript 调用此方法时的输入参数，可以通过这个对象的 Env 方法获取 JavaScript 运行时环境对象。 ReadFilePathsJs 方法内，调用了 ReadFilePaths 方法，这个方法在 clipboard.h 中定义，它返回一个字符串容器（std::vectorstd::string类型），这个容器中的内容就是剪切板内的文件路径。 把这个容器中的内容逐一复制到一个数组中（Napi::Array 类型，这个类型可以直接被 JavaScript 访问），最后把这个数组返回给调用者。 定义 clipboard.h 头文件内容: src/native/clipboard.h #ifndef CLIPBOARD_H #define CLIPBOARD_H #include \u003cvector\u003e #include \u003cstring\u003e std::vector\u003cstd::string\u003e ReadFilePaths(); #endif 定义方法：ReadFilePaths，在不同平台下读取剪切板的实现逻辑不同，所以要为这个头文件完成两个实现逻辑。clipboard.cc 是 Windows 平台上的实现。clipboard.mm 是 Mac 平台上的实现逻辑。 Windows 平台上的实现逻辑： src/native/clipboard.cc #include \u003cWindows.h\u003e #include \u003cShlObj.h\u003e #include \u003cmemory\u003e #include \"clipboard.h\" // 宽字符串转UTF8字符串 std::string Utf16CStringToUtf8String(LPCWSTR input, UINT len) { int target_len = WideCharToMultiByte(CP_UTF8, 0, input, len, NULL, 0, NULL, NULL); std::string result(target_len, '\\0'); WideCharToMultiByte(CP_UTF8, 0, input, len, result.data(), target_len, NULL, NULL); return result; } // RAII（Resource Acquisition Is Initialization）类 class ClipboardScope { bool valid; public: ClipboardScope() { valid = static_cast\u003cbool\u003e(OpenClipboard(NULL)); } ~ClipboardScope() { CloseClipboard(); } bool IsValid() { return valid; } }; //读取剪切板内的文件路径 std::vector\u003cstd::string\u003e ReadFilePaths() { auto result = std::vector\u003cstd::string\u003e(); ClipboardScope clipboard_scope; if (!clipboard_scope.IsValid()) { return result; } HDROP drop_files_handle = (HDROP)GetClipboardData(CF_HDROP); if (!drop_files_handle) { return result; } UINT file_count = DragQueryFileW(drop_files_handle, 0xFFFFFFFF, NULL, 0); result.reserve(file_count); for (UINT i = 0; i \u003c file_count; ++i) { UINT path_len = DragQueryFileW(drop_files_handle, i, NULL, 0); UINT buffer_len = path_len + 1; std::unique_ptr\u003cWCHAR[]\u003e buffer(new WCHAR[buffer_len]); path_len = DragQueryFileW(drop_files_handle, i, buffer.get(), buffer_len); result.emplace_back(Utf16CStringToUtf8String(buffer.get(), path_len)); } return result; } OpenClipboard 之后要对应的关闭操作 CloseClipboard，把这两个操作封装到了一个对象中：clipboard_scope，这个对象初始化时，执行 OpenClipboard 操作，对象释放时，执行 CloseClipboard 操作，这是使用 C++ 开发常见的 RAII（Resource Acquisition Is Initialization）开发技巧。 通过 Windows API 获取到的文件路径是宽字节字符串，需要把这个字符串转化成 UTF8 格式的字符串才能被 JavaScript 使用，上述代码中 Utf16CStringToUtf8String 方法就是完成这个任务的。 如果剪切板内没有文件路径，就返回一个空容器，如果有文件路径，就把所有的文件路径都放置到容器中返回给调用者。 Mac 平台上的实现逻辑： src/native/clipboard.mm #import \u003cFoundation/Foundation.h\u003e #import \u003cCocoa/Cocoa.h\u003e #include \"clipboard.h\" std::vector\u003cstd::string\u003e ReadFilePaths() { NSPasteboard *pasteboard = [NSPasteboard generalPasteboard]; NSArray\u003cNSURL *\u003e *urls = [pasteboard readObjectsForClasses:@[NSURL.class] options:@{ NSPasteboardURLReadingFileURLsOnlyKey: @YES, }]; if (!urls) { return {}; } auto result = std::vector\u003cstd::string\u003e(); result.reserve(urls.count); for (NSURL *url in urls) { result.emplace_back([url.path UTF8String]); } return result; } ","date":"2023-02-07","objectID":"/electron/:10:2","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"编译原生模块 如何实现在 Windows 环境下，编译 src/native/clipboard.cc 源码，在 Mac 环境下编译 src/native/clipboard.mm？ 编译配置文件：src/native/binding.gyp 最后一个配置节提供了配置能力。这个配置节的作用是在操作系统不同时（‘OS==“mac”’），指定不同的源码文件（sources）、依赖库（libraries）和编译工具（msvs_settings、xcode_settings）。 现在执行如下指令来生成构建工程： node-gyp configure 构建好工程之后，尝试使用如下命令来编译这个原生模块。 node-gyp build 如果在命令行环境中看到彩色的 gyp info ok 这行信息，说明原生模块已经编译成功了，它被放置在 build/Release/addon.node 路径下。 接下来写一段 JavaScript 代码，测试一下这个原生模块。 //src\\native\\test.js let native = require(\"./build/Release/addon.node\"); let paths = native.readFilePaths(); console.log(paths); 先复制几个文件，然后使用如下命令执行这个测试脚本： node test.js 看看你复制的文件路径是不是已经打印到控制台上了呢？ 上面编译出的原生模块不一定能在 Electron 应用中正常工作。这是因为 Electron 内置的 Node.js 的版本可能与你编译原生模块使用的 Node.js 的版本不同。如果在 Electron 工程内使用原生模块时，碰到如下错误： Error: The module '/path/to/native/module.node' was compiled against a different Node.js version using NODE_MODULE_VERSION $XYZ. This version of Node.js requires NODE_MODULE_VERSION $ABC. Please try re-compiling or re-installing the module (for instance, using `npm rebuild` or `npm install`). 则说明你使用的原生模块与 Electron 的 ABI 不匹配，此时就要针对 Electron 内置的 ABI 来编译你的原生模块。 使用方法与编译 SQLite 原生模块时相同，如下指令所示： electron-rebuild -f -m ./src/native 现在编译出的原生模块就可以在 Electron 工程下正常使用了。 ","date":"2023-02-07","objectID":"/electron/:10:3","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"应用升级方案 产品在第一次上线后，开始进入迭代期，开发者会为产品增加新的功能，修复 Bug，随之就会推出新版本，怎么把新版本的产品分发给用户就成为了一个产品经理和开发人员都关注的问题。 市面上常见的产品升级方式有两种: 全量升级，这种升级方式要求用户重新安装新版本的产品，在安装新版本前，安装程序会把老版本的产品卸载掉，以达到升级的目的。这种方式最大的优点就是升级得比较彻底，不会受老版本产品的任何影响。可是如果开发者仅仅修改了一两个文件，就要让用户重新安装一遍产品的话，用户体验不好。 增量升级，这种升级方式只升级开发者修改过的内容，升级内容少，过程迅速，如果升级内容不涉及关键业务的话，还可以做到用户无感升级。 ","date":"2023-02-07","objectID":"/electron/:11:0","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"全量升级 使用 electron-updater 模块来完成升级功能，安装这个模块： npm install electron-updater -D 创建 Updater.ts 封装 Updater 类: src/main/Updater.ts import { dialog } from 'electron'; import { autoUpdater} from 'electron-updater'; export class Updater { static check() { autoUpdater.checkForUpdates(); autoUpdater.on('update-downloaded', async () =\u003e { await dialog.showMessageBox({ message: '有可用的升级', }); autoUpdater.quitAndInstall(); }); } } Updater 类提供了一个方法 check，在这个方法中，让 autoUpdater 对象检查服务端是否存在新版本的安装包，并监听 update-downloaded 事件。 一旦 autoUpdater 发现服务端存在更新的安装包，则会把安装包下载到用户本地电脑内，当新版本安装包下载完成后，update-downloaded 事件被触发。此时提醒用户“有可用的升级”，用户确认后就退出当前应用并安装新的安装包。 在升级过程有以下几点需要注意: 升级服务的地址是在制作安装包时，通过 config.publish.url 指定的，这个路径指向新版本安装包所在的服务器目录。 src/plugins/buildPlugin.ts publish: [{ provider: \"generic\", url: \"http://localhost:5500/\" }] 当完成新版本的开发工作后，要把 release 目录下的 [your_project_name] Setup [your_project_version].exe 和 latest.yml 两个文件上传到第 1 点中指定的服务器地址下（这是 Windows 平台下的工作）。Mac 平台下要把 release 目录下的 [your_project_name]-[your_project_version]-mac.zip、[your_project_name]-[your_project_version].dmg 和 latest-mac.yml 三个文件上传到指定的服务器地址下。 产品版本是通过 package.json 中的 version 属性指定的，产品的安装包的版本也是在这里指定的。 通过 dialog.showMessageBox 提醒用户升级程序实在称不上美观，这里应该发消息给渲染进程，让渲染进程弹出一个更漂亮的升级提醒窗口。用户做出选择后，再由渲染进程发消息给主进程，再执行 autoUpdater.quitAndInstall 逻辑。 在 app ready 事件发生之后再调用 Updater.check() 方法，而且应该在生产环境下调用，因为在开发环境下调用它没有任何意义，electron-updater库会给出如下错误提示： src/main/mainEntry.ts import {app, BrowserWindow} from 'electron'; import {CustomScheme} from \"./CustomScheme\"; import { Updater } from \"./Updater\"; import {CommonWindowEvent} from \"./CommonWindowEvent\"; process.env.ELECTRON_DISABLE_SECURITY_WARNINGS = 'true'; let mainWindow: BrowserWindow; app.on(\"browser-window-created\", (e, win) =\u003e { CommonWindowEvent.regWinEvent(win); }); app.whenReady().then(() =\u003e { let config = { frame: false, show: false, webPreferences: { nodeIntegration: true, webSecurity: false, allowRunningInsecureContent: true, contextIsolation: false, webviewTag: true, spellcheck: false, disableHtmlFullscreenWindowResize: true, nativeWindowOpen: true, }, }; mainWindow = new BrowserWindow(config); mainWindow.webContents.openDevTools({mode: 'undocked'}); if (process.argv[2]) { mainWindow.loadURL(process.argv[2]); } else { CustomScheme.registerScheme(); mainWindow.loadURL('app\"//index.html'); // Updater.check(); } CommonWindowEvent.listen(); }); Skip checkForUpdatesAndNotify because application is not packed 最好让升级服务地址下始终有一个安装包和相应的配置文件，不然 checkForUpdates 方法会报错。 latest.yml 的文件内包含如下几个信息：新版本安装文件的版本号、文件名、文件的 sha512 值、文件大小、文件生成时间、执行新版本安装文件时是否需要管理员权限。 当 autoUpdater.checkForUpdates() 方法执行时，会先请求这个 yml 文件，得到文件里的内容后，再拿此文件中的版本号与当前版本号对比，如果此文件中的版本号比当前版本号新，则下载新版本，否则就退出更新逻辑。 当新版本安装包下载完成后，electron-updater 会验证文件的 sha512 值是否合法，yml 文件中包含新版本安装包的 sha512 值，electron-updater 首先计算出下载的新版本安装包的 sha512 值，然后再与 yml 文件中的 sha512 值对比，两个值相等，则验证通过，不相等则验证不通过。 验证通过后 Electron 则使用 Node.js 的 child-process 模块启动这个新的安装文件，以完成应用程序升级工作。 ","date":"2023-02-07","objectID":"/electron/:11:1","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"增量升级 一般情况下会使用 asar 文件存储应用的业务逻辑代码，所以增量升级只要考虑更新这个文件即可。 Electron 应用启动时，会首先加载主进程的入口文件，这个文件是在打包 Electron 应用时指定的。 如下代码所示： src/plugins/buildPlugin.ts localPkgJson.main = \"mainEntry.js\"; 假设这个文件（mainEntry.js）没有具体的业务功能逻辑，而是只完成这样的逻辑：判断一下当前用户环境中是否存在一个新版本的 asar 文件，如果有，就直接加载新版本 asar 文件中的业务代码（假设叫 mainLogic.js）；如果没有，就加载当前 asar 文件中的业务代码 mainLogic.js。注意：mainEntry.js 和 mainLogic.js 都存在于 asar 文件中。 你可能会担心一个 asar 文件中的 js 代码是不是可以调用另一个 asar 中的 js 代码，这是没问题的。 如下代码可以正常执行，只要把 asar 当作一个目录即可，Electron 会完成具体的加载工作。 let mainLogicPath = path.join(`c://yourNewVersion.asar`, \"mainLogic.js\"); let mainLogic = require(this.mainPath); mainLogic.start(); 按照这个逻辑，就可以每次升级只升级 asar 文件，而不必升级整个应用了。 红色模块的逻辑是用户完成的，蓝色模块的逻辑都是在 mainEntry.js 中实现的，绿色模块的逻辑是在 mainLogic.js 文件中实现的。 mainLogic.js 不单单有绿色模块描述的业务逻辑，还包括整个应用的其他主进程业务逻辑。 在安装目录下的 asar 文件是一个完整应用的 asar 文件，它包括 mainEntry.js、mainLogic.js 和渲染进程的所有代码文件。 升级目录下的 asar 文件也是一个完整应用的 asar 文件，它也包括 mainEntry.js、mainLogic.js 和渲染进程的所有代码文件，只不过 mainEntry.js 文件对于它来说是可有可无的。 升级目录可以由开发者自己指定，推荐把这个目录指定为用户的 appData 目录下的一个子目录。 下载保存时，要注意 asar 文件的命名规则。比如：main.2.3.6.18.asar，其中 2.3.6 是产品的版本号，把这个版本号叫作大版本号；18 是 asar 文件的版本号，把这个版本号叫小版本号。 这样做有以下两个目的: 当用户多次增量升级应用程序后，升级目录下就会有多个 asar 文件，以这种规则命名 mainEntry.js 就可以方便地找到哪个文件是最新的。假设安装目录下的 asar 文件的版本号是 0，那么升级目录下的 asar 文件的版本号应该从版本号 1 开始。 应对用户自己重新安装了一个老旧的安装包的情况，当升级目录下有 main.2.3.7.1.asar 文件、也有 main.2.3.6.1.asar 文件时，但当前用户安装的产品的版本号是 2.3.6 时，不应该加载这个 main.2.3.7.1.asar，而应该加载 main.2.3.6.1.asar. 假设要考虑版本降级以应对版本发布后才发现了重大问题的场景，那么可以通过服务器给你的客户端发送一个指令，迫使你的客户端删除指定版本的 asar 文件，然后提示用户重启应用即可。 用户启动应用后，发现服务端有新的 asar 文件，下载成功后，马上又要求用户重启，如果你担心这会影响用户体验，那你可以把检查并下载新版本 asar 的逻辑放在主窗口显示之前，只有在服务端没有新 asar 文件或服务端无法访问时才会显示主窗口。 这样重启应用的逻辑也不需要用户确认了，即使客户端在没有网络的环境中，也可以正常运行。 但这样做会增加应用首屏加载的时间，不过开发者还可以加一个 splash window 以提升用户体验。 asar 文件不会太大，也就几兆，带给用户的负担更小，用户体验更好。 ","date":"2023-02-07","objectID":"/electron/:11:2","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"调试线上应用 （：请转移到公司提供的 windows 电脑上进行调试，毕竟把电脑玩坏了不用自掏腰包。 按默认配置生成的 Electron 应用不具备源码保护能力，先解析线上 Electron 应用的业务代码。 解析出的业务代码，一般都是压缩过的，可读性比较差，分析如何调试线上应用的业务代码。 分析 Electron 应用的崩溃报告，应对一些难以调试的问题。 ","date":"2023-02-07","objectID":"/electron/:12:0","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"业务代码解析 默认情况下，electron-builder 会把 HTML、CSS 和 JavaScript 代码以及相关的资源打包成 asar 文件嵌入到安装包中（就是安装目录下的 app.asar 文件），再分发给用户。 asar 是一种特殊的存档格式，它可以把大批的文件以一种无损、无压缩的方式连接在一起，并提供随机访问支持。 全局安装 asar 工具： npm install asar -g 安装好工具后，打开应用的安装目录，在 resources 子目录下找到 app.asar 文件，通过如下命令列出该文件内部包含的文件信息： asar list app.asar 如果想看 app.asar 包中的某个文件的内容，可以通过如下命令把该文件释放出来： asar ef app.asar entry.js 这样 entry.js 就会出现在 app.asar 同级目录下了，如果释放文件失败，提示如下错误： internal/fs/utils.js:307 throw err; Error: EPERM: operation not permitted, open 'entry.js' 90m at Object.openSync (fs.js:476:3)39m 90m at Object.writeFileSync (fs.js:1467:35)39m 可能是因为你的应用程序正在运行，app.asar 文件被占用了导致的，退出应用程序再次尝试，如果还是无法释放目标文件，可以考虑把 app.asar 拷贝到另一个目录下再释放。 如果希望一次性把 app.asar 内的文件全部释放出来，可以使用如下指令： asar e app.asar ","date":"2023-02-07","objectID":"/electron/:12:1","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"生产环境调试 把 asar 文件中的业务代码解析出来之后，这些业务代码都是压缩过的，可读性比较差，要想通过这些代码文件分析线上应用的业务逻辑是非常困难的，所以最好还是能想办法调试这些业务代码才行。 通过如下命令启动一个线上 Electron 应用： D:\\\\yourApp\\\\yourProductName.exe --inspect=7676 --remote-debugging-port=7878 这个命令在启动 Electron 应用程序时，为目标程序指定了两个端口号，一个是通过–inspect 指令指定的，一个是通过–remote-debugging-port 指令指定的，接下来要根据这两个端口号获取调试地址。 打开谷歌浏览器，访问如下两个地址： http://127.0.0.1:7676/json http://127.0.0.1:7878/json 这两个地址均会响应 JSON 字符串，响应结果是一个对应着主进程的调试信息，示例如下： { \"description\": \"node.js instance\", \"devtoolsFrontendUrl\": \"devtools://devtools/bundled/js_app.html?experiments=true\u0026v8only=true\u0026ws=127.0.0.1:7676/85ac5529-d1a5-49b3-8655-f71c7c198b71\", \"devtoolsFrontendUrlCompat\": \"devtools://devtools/bundled/inspector.html?experiments=true\u0026v8only=true\u0026ws=127.0.0.1:7676/85ac5529-d1a5-49b3-8655-f71c7c198b71\", \"faviconUrl\": \"https://nodejs.org/static/images/favicons/favicon.ico\", \"id\": \"85ac5529-d1a5-49b3-8655-f71c7c198b71\", \"title\": \"Node.js[25204]\", \"type\": \"node\", \"url\": \"file://\", \"webSocketDebuggerUrl\": \"ws://127.0.0.1:7676/85ac5529-d1a5-49b3-8655-f71c7c198b71\" } 另一个对应着渲染进程的调试信息，示例如下： { \"description\": \"\", \"devtoolsFrontendUrl\": \"/devtools/inspector.html?ws=127.0.0.1:7878/devtools/page/AFCF98D56EE8462C3D8E52FA99C02F91\", \"id\": \"AFCF98D56EE8462C3D8E52FA99C02F91\", \"title\": \"Vite App\", \"type\": \"page\", \"url\": \"app://./index.html\", \"webSocketDebuggerUrl\": \"ws://127.0.0.1:7878/devtools/page/AFCF98D56EE8462C3D8E52FA99C02F91\" } 这两个响应中最重要的信息就是 devtoolsFrontendUrl，得到此信息后，要把它们转换为如下的格式： devtools://devtools/bundled/js_app.html?experiments=true\u0026v8only=true\u0026ws=127.0.0.1:7676/e9c9b139-a606-4703-be3f-f4ffc496a6aa devtools://devtools/bundled/inspector.html?ws=127.0.0.1:7878/devtools/page/33DFD3D347C1B575DC6361CC61ABAEDE 这个转换过程是一个简单的字符串替换，如果你嫌麻烦也可以用如下代码进行替换： devtoolsFrontendUrl.replace(/^\\/devtools/, \"devtools://devtools/bundled\"); 把转换后的地址放入谷歌浏览器中，将得到如下图所示结果，可以试着在对应的源文件中下一个断点试试看。 如果目标应用的源码是压缩过的，可以尝试点击调试器右下角的 {} 按钮美化代码，查看美化后的代码，这样就可以更方便地下断点调试了。 通过这种方法只能调试市面上一部分基于 Electron 开发的应用，并不是所有的基于 Electron 开发的应用都能使用这种方法调试。 ","date":"2023-02-07","objectID":"/electron/:12:2","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"分析崩溃报告 分析调试业务代码主要目的是追踪业务代码的问题，但有些问题是不会给我们追踪的机会的，比如那些偶发的、一旦出现应用程序就立即 Crash 的问题。要解决这些问题就要掌握分析 Electron 应用崩溃报告的知识。 如果你希望你的应用程序崩溃时，自动保存崩溃报告文件，那么你就要在你的应用程序中使用如下代码收集崩溃报告： import { crashReporter } from \"electron\"; crashReporter.start({ submitURL: \"\", uploadToServer: false }); 有了这段代码，当应用程序崩溃时，就会产生一个.dmp 扩展名结尾的文件（存放于 C://Users/[yourOsUserName]/AppData/Roaming/[yourAppName]/Crashpad）。 首先需要安装 WinDbg 调试工具，如果你在安装 Windows 10 SDK 时勾选了 Debugging Tools For Windows，那么 WinDbg 已经在如下目录内了，直接使用即可： C://Program Files (x86)/Windows Kits/10/Debuggers/x86 如果没有，那么可以在如下地址下载安装： https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools 安装完成后，通过菜单 File-\u003eSymbol File Path 打开符号路径设置窗口，输入如下信息： SRV*d:\\code\\symbols\\*https://msdl.microsoft.com/download/symbols;SRV*d:\\code\\symbols\\*https://symbols.electronjs.org 这段配置中有三个关键信息，依次是符号文件的缓存路径、Windows 操作系统关键 dll 的符号服务器和 Electron 的符号服务器。 设置完符号服务器之后，通过菜单 File-\u003eOpen Crash Dump 打开刚刚生成的崩溃报告，接着就等待 WinDbg 加载对应的符号（WinDbg 会通过 Electron 符号服务器下载与崩溃报告对应的 Electron 版本的符号文件，并保存在缓存目录中以备下次使用）。 接着再在命令窗口的底部输入 !analyze -v 指令开始分析崩溃报告。 加载完成后 WinDbg 会在窗口中显示崩溃报告内部的信息： EXCEPTION_RECORD: (.exr -1) ExceptionAddress: 00007ff725996fac (electron!node::AsyncResource::CallbackScope::~CallbackScope+0x000000000013227c) ExceptionCode: c0000005 (Access violation) ExceptionFlags: 00000000 NumberParameters: 2 Parameter[0]: 0000000000000001 Parameter[1]: 0000000000000000 Attempt to write to address 0000000000000000 PROCESS_NAME: electron.exe WRITE_ADDRESS: 0000000000000000 ERROR_CODE: (NTSTATUS) 0xc0000005 - 0x%p 0x%p %s EXCEPTION_CODE_STR: c0000005 EXCEPTION_PARAMETER1: 0000000000000001 EXCEPTION_PARAMETER2: 0000000000000000 STACK_TEXT: 00000053`0abf82f0 00007ff7`275a0513 : 00001c69`00000000 00000053`0abf84d8 00008d04`5e11c7b4 00001c69`00000000 : electron!node::AsyncResource::CallbackScope::~CallbackScope+0x13227c 00000053`0abf84a0 00007ff7`275a0121 : 00008d04`5e11c7a4 00000053`0abf8690 00007ff7`2b7e55c0 0000452c`0087b1bb : electron!v8::Object::SlowGetInternalField+0x7f3 00000053`0abf84d0 00007ff7`26cacd53 : 00000000`00000000 00007ff7`26c1f112 00000000`00000000 00000000`06b96722 : electron!v8::Object::SlowGetInternalField+0x401 00000053`0abfcfe0 00007ff7`26652c61 : 00000000`00000000 00001c69`08042229 00001c69`c0cdb000 00001c69`08282125 : electron!v8::V8::ToLocalEmpty+0x2193 00000053`0abfd010 00007ff7`27720c24 : 00000000`00000000 00000000`00000000 00000053`0abfd068 00000000`00000000 : electron!v8::Value::ToString+0x2eef1 00000053`0abfd050 00007ff7`251fa720 : 00000000`00000000 00000000`00000000 00000000`00000000 00001c69`a5e82115 : electron!v8::internal::TickSample::Init+0x11a24 00000053`0abfd0d0 00007ff7`25ae571c : 00000000`00000000 00000053`0abfd218 00001c69`a5e80000 00000000`00000002 : electron!v8::Isolate::CreateParams::~CreateParams+0xce60 00000053`0abfd130 00001c69`000c6308 : 00000000`0d72ce44 00001c69`08942dd9 00000000`06b96722 00001c69`08582e0d : electron!v8_inspector::protocol::Binary::operator=+0x6f12c 00000053`0abfd188 00000000`0d72ce44 : 00001c69`08942dd9 00000000`06b96722 00001c69`08582e0d 00000000`0d72ce44 : 0x00001c69`000c6308 00000053`0abfd190 00001c69`08942dd9 : 00000000`06b96722 00001c69`08582e0d 00000000`0d72ce44 00001c69`0946344d : 0xd72ce44 00000053`0abfd198 00000000`06b96722 : 00001c69`08582e0d 00000000`0d72ce44 00001c69`0946344d 00001c69`088c2349 : 0x00001c69`08942dd9 00000053`0abfd1a0 00001c69`08582e0d : 00000000`0d72ce44 00001c69`0946344d 00001c69`088c2349 00001c69`08582e0d : 0x6b96722 00000053`0abfd1a8 00000000`0d72ce44 : 00001c69`0946344d 00001c69`088c2349 00001c69`08582e0d 00001c69`083d6e61 : 0x00001c69`08582e0d 00000053`0abfd1b0 00001c69`0946344d : 00001c69`088c2349 00001c69`08582e0d 00001c69`083d6e61 00001c69`08584a49 : 0xd72ce44 00000053`0abfd1b8 00001c69`088c2349 : 00001c69`08582e0d 00001c69`083d6e61 00001c69`08584a49 00000000`0000069c : 0x00001c69`0946344d 00000053`0abfd1c0 00001c69`08582e0d : 00001c69`083d6e61 00001c69`08584a49 00000000`0000069c 00000000`0000645c : 0x00001c69`088c2349 00000053`0abf","date":"2023-02-07","objectID":"/electron/:12:3","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"其它 ","date":"2023-02-07","objectID":"/electron/:13:0","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"应用程序安装目录 使用 electron-builder 打包应用时设置了不允许用户修改应用程序安装目录，那么应用程序会安装在用户的如下目录中： 64 位应用程序的安装目录：C:\\Program Files\\\\[yourAppName] 32 位应用程序的安装目录：C:\\Program Files (x86)\\\\[yourAppName] 应用程序安装目录下的文件及其功用如下所示： 应用程序的安装目录 ├─ locales（Electron的多国语言文件） │ │ ├─ en-GB.pak（英国英语） │ │ ├─ en-US.pak（美国英语） │ │ ├─ zh-CN.pak（简体中文） │ │ ├─ zh-TW.pak（繁体中文） │ │ ├─ .....（其他国家语言文件，一般情况下可以删除） ├─ resources（应用程序资源及编译后的源码） │ ├─ app.asar（编译后的源码压缩文档） │ ├─ app.asar.unpacked（编译后的源码未压缩文档） │ ├─ app（如果没有app.asar或app.asar.unpacked，则编译后源码文档在此目录下） │ ├─ app-update.yml（应用程序升级相关的配置文件） │ ├─ .....（通过electron-builder配置的其他的额外资源） ├─ swiftshader（图形渲染引擎相关库） ├─ yourApp.exe（应用程序可执行文件，其实就是electron.exe修改图标和文件名后得来的） ├─ UnInstall yourApp.exe（卸载应用程序的可执行文件） └─ ......（其他Electron应用程序使用的二进制资源） Electron 应用在 Mac 操作系统上安装之后，会以 app 应用的形式出现在用户的应用程序目录下，右击菜单的显示包内容来查看应用程序的目录结构： 应用程序.app ├─ Contents（根目录） │ │ ├─ _CodeSignature（存放应用程序的签名信息） │ │ ├─ Frameworks（存放Electron相关的二进制资源） │ │ ├─ Info.plist（应用程序的配置文件，包含应用程序名称、id、图标以及底层接口权限的信息） │ │ ├─ Resources（应用程序资源及编译后的源码） │ │ │ ├─ app-update.yml（应用程序升级相关的配置文件） │ │ │ ├─ app.asar（编译后的源码压缩文档） │ │ │ ├─ app.asar.unpacked（编译后的源码未压缩文档） │ │ │ ├─ app（如果没有app.asar或app.asar.unpacked文件，则编译后源码文档在此目录下） │ │ │ ├─ ...（Electron内置的多国语言文件） └─└─└─ ...（通过electron-builder配置的其他的额外资源） ","date":"2023-02-07","objectID":"/electron/:13:1","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"应用程序缓存目录 用户第一次启动 Electron 应用后，Electron 会在如下目录创建相应的缓存文件，该目录的文件结构及功能说明如下： C://Users/[yourOsUserName]/AppData/Roaming/[yourAppName] ├─ IndexedDB（Electron应用渲染进程IndexedDB数据存放目录） ├─ Local Storage（Electron应用渲染进程Local Storage数据存放目录） ├─ Session Storage（Electron应用渲染进程Session Storage数据存放目录） ├─ Crashpad（Electron应用崩溃日志数据存放目录） ├─ Code Cache（Electron应用渲染进程源码文件缓存目录，wasm的缓存也会存在此处） ├─ Partitions（如果你的应用中适应了自定义协议，或根据字符串产生了session，此目录将有相应的内容） ├─ GPUCache（Electron应用渲染进程GPU运行过程产生的缓存数据） └─ ......（其他Electron渲染进程缓存文件） Mac 操作系统下的缓存目录为： MacintoshHD/用户/[yourOsUserName]/资源库/ApplicationSupport/[yourAppName] 该目录下的内容与子目录结构跟 Windows 操作系统类似。 虽然以上目录内的文件都是加密存储的，但只要把这个目录下的文件拷贝到另一台机器上，就可以用一个伪造的 Electron 程序读取到这些缓存文件内的数据。 客户端数据库文件也是存放在这个目录下的。 Electron 提供了一个便捷的 API 来获取此路径，此方法执行时会判断当前应用正运行在什么操作系统上，然后根据操作系统的名称返回具体的路径地址。 app.getPath(\"userData\"); ","date":"2023-02-07","objectID":"/electron/:13:2","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"窗口钉在桌面上 使用 electget 库，安装并在主进程代码中引入： // import electget from \"electget\"; electget.preventFromAeroPeek(win); electget.preventFromShowDesktop(win); electget.moveToBottom(win); 这时窗口就可以“钉”在桌面上了。 为了更完美地满足需求，最好监控一下窗口聚焦事件，当用户聚焦窗口时，把窗口移至最底层： app.on(\"browser-window-focus\", (e, win: BrowserWindow) =\u003e { if (win.id != mainWindow.id) return; electget.moveToBottom(mainWindow); }); 这样做可以避免在用户与窗口交互后，被钉住的窗口浮到其他窗口之上。 ","date":"2023-02-07","objectID":"/electron/:13:3","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"文件重新上传 开发者在上传文件之前，把文件路径记录下来，重新上传文件时，直接用文件路径构造一个 File 对象，然后再上传到服务端。 使用文件路径构造 File 对象的代码如下所示： let extname = path.extname(filePath); let buffer = await fs.promises.readFile(filePath); let file = new window.File([Uint8Array.from(buffer)], path.basename(filePath), { type: this.ext2type[extname], //mimetype类似\"image/png\" }); 这种方法要把整个文件的内容都读出来放到 buffer 里，小文件还好，遇到大文件就极其消耗用户的内存了，而且 V8 并不会及时释放这块内存。 更好的方案是一块一块读文件的内容，然后再附加到 POST 请求内。 有一个开源库 —— form-data，可以大大简化这方面的工作。 把 form-data 引入工程内后，可以使用如下代码构造上传表单，用这种方法上传文件就是分片上传的。 var FormData = require(\"form-data\"); var fs = require(\"fs\"); var form = new FormData(); form.append(\"yourFile\", fs.createReadStream(\"/your/file/path.7z\")); form.submit(\"http://yourFileService.com/upload\"); 如果要开发取消上传、显示文件上传进度等功能，可以参考如下代码： new Promise((resolve, reject) =\u003e { let req = formData.submit(params, (err, res) =\u003e { const body = []; res.on(\"data\", (chunk) =\u003e { body.push(chunk); }); res.on(\"end\", () =\u003e { let resString = Buffer.concat(body).toString(); let resObj = JSON.parse(resString); eventer.off(\"setXhrAbort\", abort); resolve(res); }); }); req.on(\"socket\", () =\u003e req.socket.on(\"drain\", () =\u003e { let percent = parseInt((req.socket.bytesWritten / file.size) * 100); // 此处显示文件上传进度的逻辑 }) ); let abort = () =\u003e { req.destroy(); // 调用此方法结束文件上传 }; }); ","date":"2023-02-07","objectID":"/electron/:13:4","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"总结 🤪 今天不学习，明天变垃圾。 ","date":"2023-02-07","objectID":"/electron/:14:0","tags":["第一技能"],"title":"基于 Electron + Vue3 的桌面应用开发实战","uri":"/electron/"},{"categories":["谈人生"],"content":"倒霉 🥚 儿行为大赏 🤪，且看且珍惜。 ","date":"2023-02-01","objectID":"/blog/:0:0","tags":["谈人生"],"title":"看事儿的那些年","uri":"/blog/"},{"categories":["谈人生"],"content":"2023 ","date":"2023-02-01","objectID":"/blog/:1:0","tags":["谈人生"],"title":"看事儿的那些年","uri":"/blog/"},{"categories":["谈人生"],"content":"由房屋租赁纠纷引发的思考 简述一下事情的起因，因为工作变动，没有太多时间找房子，在贝壳找房上紧急租到了套一公寓，和中介公司签订了半年的租房合同，签订合同前，凭借着自己那点可怜的人生经验觉得合同好像没什么问题，就痛快地签了。 (注：合同的甲方写的是房东的名字，涉及个人隐私部分打码)。 也怪自己租房前没仔细检查，搬进来之后发现电器有一些小问题，比如客厅灯不亮这些，想着也没有太大影响，反正只租了半年，到期后肯定不租了，就先凑合住吧，就这样相安无事地住了3个月。 今年1月份忽然被告知中介公司与房东合约到期（实际是公司经营不善决定退租(：房东说的，真假无从考证），并且双方在没有告知我的情况下已经完成了手续移交。 首先沟通的是宽带问题，因为之前要每个月给中介公司交200元杂费，其中包括物业费、宽带等之类的费用，现在中介公司不管了，宽带我肯定是要用的，遂找到房东，房东让我找中介公司，中介公司让我找房东（相互踢皮球）。以下是聊天记录： 和房东沟通： 和中介沟通： 房东让找中介，中介选择沉默，最后这件事情不了了之，没办法，自己装个宽带吧。。。害。 过节回来后，又有麻烦了，窗户的锁因为老旧坏掉了，大冬天太冷了，冻了3天之后，实在忍不了了，因为我对周围环境也不熟悉，想着联系下房东帮忙给处理下，然后就发生了不愉快的事情，房东勒令我立马搬出去，中介还是一如既往地踢皮球，还报了警，民警来了只是问了问，给了点建议，说他们管不了，然后就走了。 和房东沟通： 和中介沟通： 中间还给房东打了电话，房东说自己是70岁+的退休国家干部，已经实现了财务自由，言语中透露出浓浓地官僚资本主义，所以不在乎房子租不租的出去，只是怕麻烦，喊我如果想继续住下去，就每个月只按时给她房租，其余的事情全部自己来解决。 最后这件事情，肯定是自己掏钱把锁修好了。自己可能还是太年轻吧，言语中充满了愤愤不平和对当今这个社会的失望。冷静下来之后，研究了下租房合同、他们的交接协议、以及这段时间和他们的沟通记录： 首先：甲乙（甲：房东，乙：中介公司）双方于1月15日进行房子交割协议，中介公司将押金和15日之后的房租交给了房东，是不是就说明这个房子和中介公司没有关系了，以后房子的事情都由房东自己来处理（作为房东出租房屋应该有责任要处理房子硬件设施老化维护的问题）。 其次：中介公司未提前与我进行沟通，这种情况是不是处理太不恰当，并应该有义务对之后的纠纷进行协调处理。 附上一篇从网上找到的相关报道，虽然我目前的状况还没有这个人的这么严重… 我的朋友，你怎么看待这件事情呢？期待收获您的宝贵经验。 更新： 几位朋友给出了自己的建议。 “你可以找人问问合同的履行人现在是公司还是房东，but都很麻烦，走警察都是劝诫为主，走法院半年起步。” “这事只能吃哑巴亏，自己认倒霉。” “那你直接跟这个房东补签一个三个月的短租合同好了看她同不同意。” “你就说她让你搬出去也得把之前的押金退给你，然后你搬出去了再到她找到新房客中间少说也要一个多星期两个星期房子是空着的，她自己是有损失的，谁也不会跟钱过不去。” so，这房子到期就 👋🏻 吧 👵🏻，等待下一个倒霉 🥚 入坑。 ","date":"2023-02-01","objectID":"/blog/:1:1","tags":["谈人生"],"title":"看事儿的那些年","uri":"/blog/"},{"categories":null,"content":"关于 LoveIt","date":"2019-08-02","objectID":"/about/","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"  LoveIt 是一个由  Dillon 开发的简洁、优雅且高效的 Hugo 博客主题。 它的原型基于 LeaveIt 主题 和 KeepIt 主题。 Hugo 主题 LoveIt ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"特性 ","date":"2019-08-02","objectID":"/about/:1:0","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"性能和 SEO  性能优化：在 Google PageSpeed Insights 中， 99/100 的移动设备得分和 100/100 的桌面设备得分  使用基于 JSON-LD 格式 的 SEO SCHEMA 文件进行 SEO 优化  支持 Google Analytics  支持 Fathom Analytics  支持 Plausible Analytics  支持 Yandex Metrica  支持搜索引擎的网站验证 (Google, Bind, Yandex and Baidu)  支持所有第三方库的 CDN  基于 lazysizes 自动转换图片为懒加载 ","date":"2019-08-02","objectID":"/about/:1:1","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"外观和布局  桌面端/移动端 响应式布局  浅色/深色 主题模式  全局一致的设计语言  支持分页  易用和自动展开的文章目录  支持多语言和国际化  美观的 CSS 动画 社交和评论系统  支持 Gravatar 头像  支持本地头像  支持多达 73 种社交链接  支持多达 24 种网站分享  支持 Disqus 评论系统  支持 Gitalk 评论系统  支持 Valine 评论系统  支持 Facebook comments 评论系统  支持 Telegram comments 评论系统  支持 Commento 评论系统  支持 utterances 评论系统  支持 giscus 评论系统 ","date":"2019-08-02","objectID":"/about/:1:2","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"扩展功能  支持基于 Lunr.js 或 algolia 的搜索  支持 Twemoji  支持代码高亮  一键复制代码到剪贴板  支持基于 lightGallery 的图片画廊  支持 Font Awesome 图标的扩展 Markdown 语法  支持上标注释的扩展 Markdown 语法  支持分数的扩展 Markdown 语法  支持基于 $\\KaTeX$ 的数学公式  支持基于 mermaid 的图表 shortcode  支持基于 ECharts 的交互式数据可视化 shortcode  支持基于 Mapbox GL JS 的 Mapbox shortcode  支持基于 APlayer 和 MetingJS 的音乐播放器 shortcode  支持 Bilibili 视频 shortcode  支持多种注释的 shortcode  支持自定义样式的 shortcode  支持自定义脚本的 shortcode  支持基于 TypeIt 的打字动画 shortcode  支持基于 cookieconsent 的 Cookie 许可横幅  支持人物标签的 shortcode … ","date":"2019-08-02","objectID":"/about/:1:3","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"许可协议 LoveIt 根据 MIT 许可协议授权。 更多信息请查看 LICENSE 文件。 ","date":"2019-08-02","objectID":"/about/:2:0","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"特别感谢 LoveIt 主题中用到了以下项目，感谢它们的作者： normalize.css Font Awesome Simple Icons Animate.css autocomplete Lunr.js algoliasearch lazysizes object-fit-images Twemoji emoji-data lightGallery clipboard.js Sharer.js TypeIt $\\KaTeX$ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine cookieconsent ","date":"2019-08-02","objectID":"/about/:3:0","tags":null,"title":"关于 LoveIt","uri":"/about/"}]