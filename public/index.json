[{"categories":["碎碎念"],"content":"2023-02 ","date":"2023-02-02","objectID":"/2023/:1:0","tags":["连载","碎碎念"],"title":"Q的乱语-2023年","uri":"/2023/"},{"categories":["碎碎念"],"content":"02-01 ","date":"2023-02-02","objectID":"/2023/:1:1","tags":["连载","碎碎念"],"title":"Q的乱语-2023年","uri":"/2023/"},{"categories":["碎碎念"],"content":"02-02 DAMN COOL!!! 第一季看完，第二季安排上。 ","date":"2023-02-02","objectID":"/2023/:1:2","tags":["连载","碎碎念"],"title":"Q的乱语-2023年","uri":"/2023/"},{"categories":["碎碎念"],"content":"2023-01 ","date":"2023-02-02","objectID":"/2023/:2:0","tags":["连载","碎碎念"],"title":"Q的乱语-2023年","uri":"/2023/"},{"categories":["碎碎念"],"content":"01-01 去成都SKP逛一圈，才能知道自己有多穷😭 ","date":"2023-02-02","objectID":"/2023/:2:1","tags":["连载","碎碎念"],"title":"Q的乱语-2023年","uri":"/2023/"},{"categories":["碎碎念"],"content":"01-02 乔妹的演技还是可以，一口气追完了，期待第二季😄 ","date":"2023-02-02","objectID":"/2023/:2:2","tags":["连载","碎碎念"],"title":"Q的乱语-2023年","uri":"/2023/"},{"categories":["碎碎念"],"content":"01-03 ","date":"2023-02-02","objectID":"/2023/:2:3","tags":["连载","碎碎念"],"title":"Q的乱语-2023年","uri":"/2023/"},{"categories":["碎碎念"],"content":"01-04 读文学经典以来最大的感受是：慢慢看淡生与死。 ","date":"2023-02-02","objectID":"/2023/:2:4","tags":["连载","碎碎念"],"title":"Q的乱语-2023年","uri":"/2023/"},{"categories":["碎碎念"],"content":"01-05 做前端死路一条，后端也是。 ","date":"2023-02-02","objectID":"/2023/:2:5","tags":["连载","碎碎念"],"title":"Q的乱语-2023年","uri":"/2023/"},{"categories":["碎碎念"],"content":"01-06 或许曾经我们都想自己是齐天大圣，可长大后才发现，其实我们都只是一只努力生存的小猪妖。 ","date":"2023-02-02","objectID":"/2023/:2:6","tags":["连载","碎碎念"],"title":"Q的乱语-2023年","uri":"/2023/"},{"categories":["碎碎念"],"content":"01-07 不好好看文档系列😭。。包子都吃完了，才看到要按照顺序吃，可惜肚子吃不下了，不然再来一笼。 好想知道如果这样吃，会不会让灵魂得到升华🤔。 ","date":"2023-02-02","objectID":"/2023/:2:7","tags":["连载","碎碎念"],"title":"Q的乱语-2023年","uri":"/2023/"},{"categories":["碎碎念"],"content":"01-08 在飞机上看了《一条狗的使命2》，哭得稀里哗啦的😭。 多希望饼干🐱也可以一直历经生死轮回找到我并陪伴着我，直到我走到生命的终点。 ","date":"2023-02-02","objectID":"/2023/:2:8","tags":["连载","碎碎念"],"title":"Q的乱语-2023年","uri":"/2023/"},{"categories":["碎碎念"],"content":"01-09 犹豫了很久很久，终于下定决心入手 AJ 扣碎篮板😍。 钱不花就是一张纸，花了才是钱😳。 ","date":"2023-02-02","objectID":"/2023/:2:9","tags":["连载","碎碎念"],"title":"Q的乱语-2023年","uri":"/2023/"},{"categories":["碎碎念"],"content":"01-10 公司产品总监为了拍老板🐴屁，东西还没做完就着急给老板👁，然后白屏了，🦷都笑掉了。 ","date":"2023-02-02","objectID":"/2023/:2:10","tags":["连载","碎碎念"],"title":"Q的乱语-2023年","uri":"/2023/"},{"categories":["碎碎念"],"content":"01-11 闺蜜失恋了，被迫听了3个小时的她和她前男友的爱情故事🤕。 ","date":"2023-02-02","objectID":"/2023/:2:11","tags":["连载","碎碎念"],"title":"Q的乱语-2023年","uri":"/2023/"},{"categories":["碎碎念"],"content":"01-12 原来妈妈也喜欢听你给她讲在外面遇到的新鲜事儿😊。 ","date":"2023-02-02","objectID":"/2023/:2:12","tags":["连载","碎碎念"],"title":"Q的乱语-2023年","uri":"/2023/"},{"categories":["碎碎念"],"content":"01-13 塔勒布说过：“21世纪有三大毒品：海洛因、碳水化合物、每月发一次的工资。” ","date":"2023-02-02","objectID":"/2023/:2:13","tags":["连载","碎碎念"],"title":"Q的乱语-2023年","uri":"/2023/"},{"categories":["碎碎念"],"content":"01-14 直发回来的那一刻，如释重负😊。 ","date":"2023-02-02","objectID":"/2023/:2:14","tags":["连载","碎碎念"],"title":"Q的乱语-2023年","uri":"/2023/"},{"categories":["碎碎念"],"content":"01-15 😴😴😴 ","date":"2023-02-02","objectID":"/2023/:2:15","tags":["连载","碎碎念"],"title":"Q的乱语-2023年","uri":"/2023/"},{"categories":["碎碎念"],"content":"01-16 打扫卫生。 ","date":"2023-02-02","objectID":"/2023/:2:16","tags":["连载","碎碎念"],"title":"Q的乱语-2023年","uri":"/2023/"},{"categories":["碎碎念"],"content":"01-17 世界上怎么会有IU这么可爱的👧🏻。 ","date":"2023-02-02","objectID":"/2023/:2:17","tags":["连载","碎碎念"],"title":"Q的乱语-2023年","uri":"/2023/"},{"categories":["碎碎念"],"content":"01-18 重温《德鲁纳酒店》，每个人看似理智又冷静，但其实内心也有着最脆弱的一面，没有了依靠时，只能用坚强来掩盖自己的脆弱。 ","date":"2023-02-02","objectID":"/2023/:2:18","tags":["连载","碎碎念"],"title":"Q的乱语-2023年","uri":"/2023/"},{"categories":["碎碎念"],"content":"01-19 彩妆的尽头是裸妆 烫发的尽头是黑长直 美甲的尽头是肉粉色 医美的尽头是养生 消费主义的尽头是断舍离 道理的尽头是大道至简 万事的尽头是尽人事听天命 人生的尽头是一个人面对孤独 ","date":"2023-02-02","objectID":"/2023/:2:19","tags":["连载","碎碎念"],"title":"Q的乱语-2023年","uri":"/2023/"},{"categories":["碎碎念"],"content":"01-20 🤔发现一个挺有意思的事情，因为要回老家过年，给🐱准备了两个猫砂盆，这家伙竟然自己主动分类了，一个专门用来💧，一个专门用来💩。 ","date":"2023-02-02","objectID":"/2023/:2:20","tags":["连载","碎碎念"],"title":"Q的乱语-2023年","uri":"/2023/"},{"categories":["碎碎念"],"content":"01-21 新年快乐鸭🎆。 ","date":"2023-02-02","objectID":"/2023/:2:21","tags":["连载","碎碎念"],"title":"Q的乱语-2023年","uri":"/2023/"},{"categories":["碎碎念"],"content":"01-22 🥰的一天，老弟给买了烤鸡和🧋，陪爸爸妈妈一起看📺。 ","date":"2023-02-02","objectID":"/2023/:2:22","tags":["连载","碎碎念"],"title":"Q的乱语-2023年","uri":"/2023/"},{"categories":["碎碎念"],"content":"01-23 飞扬的👖。 ","date":"2023-02-02","objectID":"/2023/:2:23","tags":["连载","碎碎念"],"title":"Q的乱语-2023年","uri":"/2023/"},{"categories":["碎碎念"],"content":"01-24 4个人一起喝🍺，吐了1个，晕了2个。 ","date":"2023-02-02","objectID":"/2023/:2:24","tags":["连载","碎碎念"],"title":"Q的乱语-2023年","uri":"/2023/"},{"categories":["碎碎念"],"content":"01-25 ","date":"2023-02-02","objectID":"/2023/:2:25","tags":["连载","碎碎念"],"title":"Q的乱语-2023年","uri":"/2023/"},{"categories":["碎碎念"],"content":"01-26 I am sorry MJ… it’s 2023 and the world is still cruel. ","date":"2023-02-02","objectID":"/2023/:2:26","tags":["连载","碎碎念"],"title":"Q的乱语-2023年","uri":"/2023/"},{"categories":["碎碎念"],"content":"01-27 在🚄上读《解忧杂货店》，要是世界上真的有一家这样的店就好了。 ","date":"2023-02-02","objectID":"/2023/:2:27","tags":["连载","碎碎念"],"title":"Q的乱语-2023年","uri":"/2023/"},{"categories":["碎碎念"],"content":"01-28 上班第一天，😴。 ","date":"2023-02-02","objectID":"/2023/:2:28","tags":["连载","碎碎念"],"title":"Q的乱语-2023年","uri":"/2023/"},{"categories":["碎碎念"],"content":"01-29 😠。 ","date":"2023-02-02","objectID":"/2023/:2:29","tags":["连载","碎碎念"],"title":"Q的乱语-2023年","uri":"/2023/"},{"categories":["碎碎念"],"content":"01-30 一本书，可以折射一个小世界，也可以成为一部分人的朋友。 ","date":"2023-02-02","objectID":"/2023/:2:30","tags":["连载","碎碎念"],"title":"Q的乱语-2023年","uri":"/2023/"},{"categories":["碎碎念"],"content":"01-31 被公司的 UI 折磨惨了😭。 ","date":"2023-02-02","objectID":"/2023/:2:31","tags":["连载","碎碎念"],"title":"Q的乱语-2023年","uri":"/2023/"},{"categories":["第一技能"],"content":"项目地址： ElectronVue3 ","date":"2023-02-02","objectID":"/electron/:0:0","tags":["连载","第一技能"],"title":"Electron + Vue3 桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"构建开发环境 按如下步骤搭建开发环境： ","date":"2023-02-02","objectID":"/electron/:1:0","tags":["连载","第一技能"],"title":"Electron + Vue3 桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"创建项目 首先通过命令行创建一个 Vue 项目： npm create vite@latest electron -- --template vue-ts 安装 electron 依赖： npm i electron -D 调整 package.json 文件： { \"name\": \"electron\", \"private\": true, \"version\": \"0.0.0\", \"scripts\": { \"dev\": \"vite\", \"build\": \"vue-tsc --noEmit \u0026\u0026 vite build\", \"preview\": \"vite preview\" }, \"dependencies\": {}, \"devDependencies\": { \"@vitejs/plugin-vue\": \"^4.0.0\", \"electron\": \"^22.0.3\", \"typescript\": \"^4.9.3\", \"vite\": \"^4.0.0\", \"vue-tsc\": \"^1.0.11\", \"vue\": \"^3.2.45\" } } 将 vue 从 dependencies 移到 devDependencies。 在 Vite 编译项目的时候，Vue 库会被编译到输出目录下，输出目录下的内容是完整的，没必要把 Vue 标记为生产依赖；而且在我们将来制作安装包的时候，还要用到这个 package.json 文件，它的生产依赖里不应该有没用的东西。 去掉 type: module 配置项。 package.json 里的 type 定义了这个项目所有 .js 文件的处理方式。 如果 type 的值为 module，那么所有 .js 文件将被当做 ES Modules 对待。如果 type 的值为 commonjs，那么所有 .js 文件将被当做 CommonJS 模块对待。如果没有设置 type，那么它的默认值为 commonjs。 ","date":"2023-02-02","objectID":"/electron/:1:1","tags":["连载","第一技能"],"title":"Electron + Vue3 桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"创建主进程代码 新建主进程入口文件：src/main/mainEntry.ts import { app, BrowserWindow } from \"electron\"; let mainWindow: BrowserWindow; app.whenReady().then(() =\u003e { mainWindow = new BrowserWindow({}); mainWindow.loadURL(process.argv[2]); }); app 是 Electron 的全局对象，用于控制整个应用程序的生命周期。 Electron 初始化完成后，app 对象的 ready 事件被触发。 app ready 后创建一个 BrowserWindow 对象，mainWindow 被设置为一个全局变量，避免被 JS 垃圾回收机制回收。 窗口加载了一个 Url 路径，这个路径以命令行参数（第三个参数）的方式传递给应用程序。 app 和 BrowserWindow 都是 Electron 的内置模块，这些内置模块是通过 ES Module 的形式导入进来的。 ","date":"2023-02-02","objectID":"/electron/:1:2","tags":["连载","第一技能"],"title":"Electron + Vue3 桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"开发环境 Vite 插件 主进程的代码写好后，需要编译过之后才能被 Electron 加载，通过 Vite 插件的形式来完成编译和加载工作。 import { ViteDevServer } from 'vite'; interface IAddressInfo { address: string; port: string; } export let devPlugin = () =\u003e { return { name: 'dev-plugin', configureServer(server: ViteDevServer) { require('esbuild').buildSync({ entryPoints: ['./src/main/mainEntry.ts'], bundle: true, platform: 'node', outfile: './dist/mainEntry.js', external: ['electron'], }); server?.httpServer?.once('listening', () =\u003e { let { spawn } = require('child_process'); let addressInfo: IAddressInfo = server?.httpServer?.address() as unknown as IAddressInfo; let httpAddress = `http://${addressInfo?.address}:${addressInfo?.port}`; let electronProcess = spawn(require('electron').toString(), ['./dist/mainEntry.js', httpAddress], { cwd: process.cwd(), stdio: 'inherit', }); electronProcess.on('close', () =\u003e { server.close(); process.exit(); }); }); }, }; }; 注册了一个名为 configureServer 的钩子，当 Vite 启动 Http 服务时，configureServer 会执行。 入参为类型为 ViteDevServer 的对象 server，server 持有一个 http.Server 类型的属性 httpServer，这个属性代表调试 Vue 页面的 http 服务，一般情况下地址为：http://127.0.0.1:5173/。 通过监听 server.httpServer 的 listening 事件来判断 httpServer 是否已经成功启动。如果已经成功启动，就启动 Electron 应用，并给它传递两个命令行参数，第一个参数是主进程代码编译后的文件路径，第二个参数是 Vue 页面的 http 地址。 通过 Node.js child_process 模块的 spawn 方法启动 electron 子进程，除了两个命令行参数外，还传递了一个配置对象。 这个对象的 cwd 属性用于设置当前的工作目录，process.cwd() 返回的值就是当前项目的根目录。 stdio 用于设置 electron 进程的控制台输出，这里设置 inherit 可以让 electron 子进程的控制台输出数据同步到主进程的控制台。 在主进程中 console.log 的内容就可以在 VSCode 的控制台上看到了。 当 electron 子进程退出的时候，要关闭 Vite 的 http 服务，并且控制父进程退出，准备下一次启动。 http 服务启动之前，使用 esbuild 模块完成了主进程 TypeScript 代码的编译工作，这个模块是 Vite 自带的，不需要额外安装，可以直接使用。 主进程的入口文件是通过 entryPoints 配置属性设置的，编译完成后的输出文件是通过 outfile 属性配置的。 编译平台 platform 设置为 node，排除的模块 external 设置为 electron，这两个设置使在主进程代码中可以通过 import 的方式导入 electron 内置的模块，非但如此，Node 的内置模块也可以通过 import 的方式引入。 在 vite.config.ts 文件中引入： import { defineConfig } from 'vite'; import vue from '@vitejs/plugin-vue'; import { devPlugin } from './plugins/devPlugin'; // https://vitejs.dev/config/ export default defineConfig({ plugins: [devPlugin(), vue()], }) 在 tsconfig.node.json 中配置 plugins 路径： { \"compilerOptions\": { \"composite\": true, \"module\": \"ESNext\", \"moduleResolution\": \"Node\", \"allowSyntheticDefaultImports\": true }, \"include\": [\"vite.config.ts\", \"./plugins/*.*\"] } 执行命令 npm run dev: ","date":"2023-02-02","objectID":"/electron/:1:3","tags":["连载","第一技能"],"title":"Electron + Vue3 桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"渲染进程集成内置模块 现在主进程内可以自由的使用 Electron 和 Node.js 的内置模块了，但渲染进程还不行。 修改主进程代码，打开渲染进程的一些开关，允许渲染进程使用 Node.js 的内置模块: import { app, BrowserWindow } from 'electron'; process.env.ELECTRON_DISABLE_SECURITY_WARNINGS = 'true'; let mainWindow: BrowserWindow; app.whenReady().then(() =\u003e { let config = { webPreferences: { nodeIntegration: true, webSecurity: false, allowRunningInsecureContent: true, contextIsolation: false, webviewTag: true, spellcheck: false, disableHtmlFullscreenWindowResize: true, }, }; mainWindow = new BrowserWindow(config); mainWindow.webContents.openDevTools({ mode: 'undocked' }); mainWindow.loadURL(process.argv[2]); }); ELECTRON_DISABLE_SECURITY_WARNINGS 用于设置渲染进程开发者调试工具的警告，这里设置为 true 就不会再显示任何警告了。 nodeIntegration配置项的作用是把 Node.js 环境集成到渲染进程中。 contextIsolation配置项的作用是在同一个 JavaScript 上下文中使用 Electron API。 webContents的openDevTools方法用于打开开发者调试工具。 现在可以在开发者调试工具中访问 Node.js 和 Electron 的内置模块了。 ","date":"2023-02-02","objectID":"/electron/:1:4","tags":["连载","第一技能"],"title":"Electron + Vue3 桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"设置模块别名与解析钩子 虽然可以在开发者调试工具中使用 Node.js 和 Electron 的内置模块，但现在还不能在 Vue 的页面内使用这些模块。 因为 Vite 主动屏蔽了这些内置的模块，如果开发者强行引入它们，那么大概率会得到如下报错： Module \"xxxx\" has been externalized for browser compatibility and cannot be accessed in client code. 安装 vite-plugin-optimizer： npm i vite-plugin-optimizer -D 修改 vite.config.ts 的代码，让 Vite 加载这个插件： import { defineConfig } from 'vite'; import vue from '@vitejs/plugin-vue'; import { devPlugin, getReplacer } from './plugins/devPlugin'; import optimizer from 'vite-plugin-optimizer'; // https://vitejs.dev/config/ export default defineConfig({ plugins: [optimizer(getReplacer()), devPlugin(), vue()], }) vite-plugin-optimizer 插件会创建一个临时目录：node_modules.vite-plugin-optimizer。 然后把类似 const fs = require(‘fs’); export { fs as default } 这样的代码写入这个目录下的 fs.js 文件中。 渲染进程执行到：import fs from “fs” 时，就会请求这个目录下的 fs.js 文件，这样就达到了在渲染进程中引入 Node 内置模块的目的。 getReplacer 方法是为 vite-plugin-optimizer 插件提供的内置模块列表: export let getReplacer = () =\u003e { let externalModels = ['os', 'fs', 'path', 'events', 'child_process', 'crypto', 'http', 'buffer', 'url', 'better-sqlite3', 'knex']; let result = {}; for (let item of externalModels) { result[item] = () =\u003e ({ find: new RegExp(`^${item}$`), code: `const ${item} = require('${item}'); export { ${item} as default }`, }); } result['electron'] = () =\u003e { let electronModules = ['clipboard', 'ipcRenderer', 'nativeImage', 'shell', 'webFrame'].join(','); return { find: new RegExp(`^electron$`), code: `const {${electronModules}} = require('electron'); export { ${electronModules} }`, } } return result; } 在这个方法中把一些常用的 Node 模块和 electron 的内置模块提供给了 vite-plugin-optimizer 插件，以后想要增加新的内置模块只要修改这个方法即可。 vite-plugin-optimizer 插件不仅用于开发环境，编译 Vue 项目时，它也会参与工作。 通过如下代码在 Vue 组件中做测试： // src\\App.vue import fs from \"fs\"; import { ipcRenderer } from \"electron\"; import { onMounted } from \"vue\"; onMounted(() =\u003e { console.log(fs.writeFileSync); console.log(ipcRenderer); }); 开发者调试工具将会输出如下内容： ","date":"2023-02-02","objectID":"/electron/:1:5","tags":["连载","第一技能"],"title":"Electron + Vue3 桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"构建生产环境 制作一个 Vite 插件。通过这个新的插件生成安装包，有了安装包就可以把应用分发给用户了。 ","date":"2023-02-02","objectID":"/electron/:2:0","tags":["连载","第一技能"],"title":"Electron + Vue3 桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"编译结束钩子函数 vite.config.ts 增加一个新的配置： import { defineConfig } from 'vite'; import vue from '@vitejs/plugin-vue'; import { devPlugin, getReplacer } from './plugins/devPlugin'; import { buildPlugin } from './plugins/buildPlugin'; import optimizer from 'vite-plugin-optimizer'; // https://vitejs.dev/config/ export default defineConfig({ build: { rollupOptions: { plugins: [buildPlugin()], }, }, plugins: [optimizer(getReplacer()), devPlugin(), vue()], }) ","date":"2023-02-02","objectID":"/electron/:2:1","tags":["连载","第一技能"],"title":"Electron + Vue3 桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"制作应用安装包 vite 编译完成之后，也就是执行 npm run build 指令，将在项目dist目录内会生成一系列的文件（如下图所示），此时 closeBundle 钩子被调用，在这个钩子中把上述生成的文件打包成一个应用程序安装包。 import path from 'path'; import fs from 'fs'; class BuildObj { // 编译主进程代码 buildMain() { require('esbuild').buildSync({ entryPoints: ['./src/main/mainEntry.ts'], bundle: true, platform: 'node', minify: true, outfile: './dist/mainEntry.js', external: ['electron'], }); } // 为生产环境准备package.json preparePackageJson() { let pkgJsonPath = path.join(process.cwd(), 'package.json'); let localPkgJson = JSON.parse(fs.readFileSync(pkgJsonPath, 'utf-8')); let electronConfig = localPkgJson.devDependencies.electron.replace('^', ''); localPkgJson.main = 'mainEntry.js'; delete localPkgJson['scripts']; delete localPkgJson['devDependencies']; localPkgJson.devDependencies = { electron: electronConfig, }; let tarJsonPath = path.join(process.cwd(), 'dist', 'package.json'); fs.writeFileSync(tarJsonPath, JSON.stringify(localPkgJson)); fs.mkdirSync(path.join(process.cwd(), 'dist/node_modules')); } // 使用electron-builder制成安装包 buildInstaller() { let options = { config: { directories: { output: path.join(process.cwd(), 'release'), app: path.join(process.cwd(), 'dist'), }, files: ['**'], extends: null, productName: 'Electron', appId: 'com.xxx.desktop', asar: true, nsis: { oneClick: true, perMachine: true, allowToChangeInstallationDirectory: false, createDesktopShortcut: true, createStartMenuShortcut: true, shortcutName: 'ElectronDesktop', }, publish: [{ provider: 'generic', url: 'http://localhost:5500/', }], }, project: process.cwd(), }; return require('electron-builder').build(options); } } export let buildPlugin = () =\u003e { return { name: 'build-plugin', closeBundle: () =\u003e { let buildObj = new BuildObj(); buildObj?.buildMain(); buildObj?.preparePackageJson(); buildObj?.buildInstaller(); } } } 这个对象通过三个方法提供了三个功能： buildMain。由于 ite 在编译之前会清空 dist 目录，所以在之前生成的 mainEntry.js 文件也被删除了，此处通过 buildMain 方法再次编译主进程代码。不过由于此处是在为生产环境编译代码，所以增加了minify: true 配置，生成压缩后的代码。 preparePackageJson。用户安装产品后，在启动应用程序时，实际上是通过 Electron 启动一个 Node.js 的项目，所以要为这个项目准备一个 package.json 文件，这个文件是以当前项目的 package.json 文件为蓝本制作而成的。里面注明了主进程的入口文件，移除了一些对最终用户没用的配置节。 buildInstaller。这个方法负责调用 electron-builder（npm install electron-builder -D 安装 electron-builder 库） 提供的 API 以生成安装包。最终生成的安装包被放置在 release 目录下，这是通过 config.directories.output 指定的。静态文件所在目录是通过 config.directories.app 配置项指定。其他配置项，请自行查阅官网文档。 生成 package.json 文件之后，还创建了一个 node_modules 目录。此举是为了阻止 electron-builder 的一些默认行为（目前来说它会阻止 electron-builder 创建一些没用的目录或文件）。 这段脚本还明确指定了 Electron 的版本号，如果 Electron 的版本号前面有\"^“符号的话，需把它删掉。这是 electron-builder 的一个 Bug，这个 bug 导致 electron-builder 无法识别带 ^ 或 ~ 符号的版本号。 做好这些配置之后，执行 npm run build 就可以制作安装包了，最终生成的安装文件会被放置到 release 目录下。 ","date":"2023-02-02","objectID":"/electron/:2:2","tags":["连载","第一技能"],"title":"Electron + Vue3 桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"主进程生产环境加载本地文件 虽然成功制作了安装包，而且这个安装包可以正确安装应用程序，但是这个应用程序无法正常启动，这是因为应用程序的主进程还在通过 process.argv[2] 加载首页。显然用户通过安装包安装的应用程序没有这个参数。 接下来就要让应用程序在没有这个参数的时候，也能加载静态页面。 新建 src\\main\\CustomScheme.ts： import { protocol } from 'electron'; import path from 'path'; import fs from 'fs'; // 为自定义app协议提供特权 let schemeConfig = { standard: true, supportFetchAPI: true, bypassCSP: true, corsEnabled: true, stream: true, }; protocol.registerSchemesAsPrivileged([{ scheme: 'app', privileges: schemeConfig, }]); export class CustomScheme { // 根据文件扩展名获取mime-type private static getMimeType(extension: string) { let mineType = ''; switch (extension) { case '.js': mineType = 'text/javascript'; break; case '.html': mineType = 'text/html'; break; case '.css': mineType = 'text/css'; break; case '.svg': mineType = 'image/svg+xml'; break; case '.json': mineType = 'application/json'; break; } return mineType; }; // 注册自定义app协议 static registerScheme() { protocol.registerStreamProtocol('app', (request, callback) =\u003e { let pathName = new URL(request.url).pathname; let extension = path.extname(pathName).toLowerCase(); if (extension === '') { pathName = 'index.html'; extension = '.html'; } let tarFile = path.join(__dirname, pathName); callback({ statusCode: 200, headers: { 'content-type': this.getMimeType(extension), }, data: fs.createReadStream(tarFile), }) }); }; } 在主进程 app ready 前，通过 protocol 对象的 registerSchemesAsPrivileged 方法为名为 app 的 scheme 注册了特权（可以使用 FetchAPI、绕过内容安全策略等）。 在 app ready 之后，通过 protocol 对象的 registerStreamProtocol 方法为名为 app 的 scheme 注册了一个回调函数。当加载类似 app://index.html 这样的路径时，这个回调函数将被执行。 这个函数有两个传入参数 request 和 callback，通过 request.url 获取到请求的文件路径，通过 callback 做出响应。 给出响应时，要指定响应的 statusCode 和 content-type，这个 content-type 是通过文件的扩展名得到的。这里通过 getMimeType 方法确定了文件的 content-type。 响应的 data 属性为目标文件的可读数据流，当你的静态文件比较大时，不必读出整个文件再给出响应。 接下来在 src\\main\\mainEntry.ts 中使用这段代码： import {CustomScheme} from './customScheme'; if (process.argv[2]) { mainWindow.loadURL(process.argv[2]); } else { CustomScheme.registerScheme(); mainWindow.loadURL('app\"//index.html'); } 这样当存在指定的命令行参数时，就认为是开发环境，使用命令行参数加载页面，当不存在命令行参数时，就认为是生产环境，通过 app:// scheme 加载页面。 ","date":"2023-02-02","objectID":"/electron/:2:3","tags":["连载","第一技能"],"title":"Electron + Vue3 桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"设计工程项目结构 在继续引入新的模块或组件之前，先调整一下工程的结构： dist 目录是打包过程的临时产物放置目录。 plugins 目录放置开发环境 vite 插件和打包 vite 插件。 release 目录放置最终生成的安装包。 resource 目录放置一些外部资源，比如应用程序图标、第三方类库等。 src/common 目录放置主进程和渲染进程都会用到的公共代码，比如日期格式化的工具类、数据库访问工具类等，主进程和渲染进程的代码都有可能使用这些类。 src/main 目录放置主进程的代码。 src/model 目录放置应用程序的模型文件，比如消息类、会话类、用户设置类等，主进程和渲染进程的代码都有可能使用这些类。 src/renderer 目录放置渲染进程的代码。 src/renderer/assets 放置字体图标、公共样式、图片等文件。 src/renderer/components 放置公共组件，比如标题栏组件、菜单组件等。 src/renderer/store 目录存放 Vue 项目的数据状态组件，用于在不同的 Vue 组件中共享数据。 src/renderer/router 目录存放 Vue 项目的路由配置信息。 src/renderer/indow 目录存放不同窗口的入口组件，这些组件是通过 vue-router 导航的，这个目录下的子目录存放对应窗口的子组件。 src/renderer/App.vue 是渲染进程的入口组件，这个组件内只有一个用于导航到不同的窗口。 src/renderer/main.ts 是渲染进程的入口脚本。 index.html 是渲染进程的入口页面。 vite.config.ts 是 vite 的配置文件。 调整好工程结构后，要修改一下 index.html 的代码才能让这些调整生效。实际上就是修改一下渲染进程入口脚本的引入路径: \u003cscript type=\"module\" src=\"/src/renderer/main.ts\"\u003e\u003c/script\u003e ","date":"2023-02-02","objectID":"/electron/:3:0","tags":["连载","第一技能"],"title":"Electron + Vue3 桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"引入 vue-router 安装 vue-router 模块： npm install vue-router@4 -D 安装完成后，为 src/renderer/router/index.ts 添加如下代码逻辑： import * as VueRouter from 'vue-router'; // 路由规则数组 const routes = [{ path: '/', redirect: '/WindowMain/Chat', }, { path: '/WindowMain', component: () =\u003e import('../window/WindowMain.vue'), children: [{ path: 'Chat', component: () =\u003e import('../window/WindowMain/Chat.vue'), }, { path: 'Contact', component: () =\u003e import('../window/WindowMain/Contact.vue'), }, { path: 'Collection', component: () =\u003e import('../window/WindowMain/Collection.vue'), },] }, { path: '/WindowSetting', component: () =\u003e import('../window/WindowSetting.vue'), children: [ { path: 'AccountSetting', component: () =\u003e import('../window/WindowSetting/AccountSetting.vue'), } ] }, { path: '/WindowUserInfo', component: () =\u003e import('../window/WindowUserInfo.vue'), }] export let router = VueRouter.createRouter({ history: VueRouter.createWebHistory(), routes, }); 这段代码导出了一个 router 对象，这个 router 对象是基于 WebHistory 模式创建路由的，也就是说页面路径看起来是这样的：http://127.0.0.1:5173/WindowMain/PageChat（开发环境），app://index.html/WindowMain/PageChat（生产环境）。 上述代码中 routes 数组里的内容就是导航的具体配置，在这些配置中使用 import 方法动态引入 Vue 组件，vite 在处理这种动态引入的组件时，会把对应的组件编译到独立的源码文件中，类似 WindowUserInfo.689249b8.js 和 WindowSetting.6354f6d6.js，这种编译策略可以帮助控制最终编译产物的大小，避免应用启动时就加载一个庞大的 JavaScript 文件。 在应用启动时请求的路径是：”/\"，这个路径被重定向到\"/WindowMain/Chat\"，也就是说 WindowMain 组件和 Chat 组件是首页组件（这是在第一个导航配置对象中设置的）。 上述代码完成后，需要在 main.ts 中使用它，代码如下： import { createApp } from 'vue'; import './style.css'; import { router } from './router'; import App from './App.vue'; createApp(App).use(router).mount('#app'); 接下来把 App.vue 的代码修改成如下内容： \u003ctemplate\u003e \u003crouter-view /\u003e \u003c/template\u003e 应用启动时，第一个窗口（主窗口）就会加载 src\\renderer\\window\\WindowMain.vue 组件的代码。 当在主窗口内打开别的子窗口时（弹出一个子窗口），只要加载类似这样的路径/WindowUserInfo，就可以让子窗口加载 src\\renderer\\Window\\WindowUserInfo.vue 这个组件。 ","date":"2023-02-02","objectID":"/electron/:4:0","tags":["连载","第一技能"],"title":"Electron + Vue3 桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"菜单组件及跳转 在 src\\renderer\\components 目录下新建 BarLeft.vue 的组件，这是整个应用的侧边栏组件，里面放置应用程序的菜单： \u003ctemplate\u003e \u003cdiv class=\"BarLeft\"\u003e \u003cdiv class=\"userIcon\"\u003e \u003cimg src=\"../assets/avatar.jpg\" alt=\"\"\u003e \u003c/div\u003e \u003cdiv class=\"menu\"\u003e \u003crouter-link v-for=\"item in mainWindowRoutes\" :to=\"item.path\" :class=\"['menuItem', {'selected': item.isSelected}]\"\u003e \u003ci :class=\"['icon', item.isSelected ? item.iconSelected : item.icon]\"\u003e\u003c/i\u003e \u003c/router-link\u003e \u003c/div\u003e \u003cdiv class=\"setting\"\u003e \u003cdiv class=\"menuItem\"\u003e \u003ci class=\"icon icon-setting\" /\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript setup lang=\"ts\"\u003e import { ref, watch } from 'vue'; import { useRoute } from 'vue-router'; let mainWindowRoutes = ref([ { path: '/WindowMain/Chat', isSelected: true, icon: 'icon-chat', iconSelected: 'icon-chat' }, { path: '/WindowMain/Contact', isSelected: false, icon: 'icon-tongxunlu1', iconSelected: 'icon-tongxunlu' }, { path: '/WindowMain/Collection', isSelected: false, icon: 'icon-shoucang1', iconSelected: 'icon-shoucang' }, ]) let route = useRoute(); watch( () =\u003e route, () =\u003e mainWindowRoutes.value.forEach(v =\u003e v.isSelected = v.path === route.fullPath), { immediate: true, deep: true, }) \u003c/script\u003e \u003cstyle scoped lang=\"scss\"\u003e .BarLeft { width: 54px; height: 100%; display: flex; flex-direction: column; background: rgb(46, 46, 46); -webkit-app-region: drag; } .userIcon { height: 84px; padding-top: 36px; box-sizing: border-box; img { width: 34px; height: 34px; margin-left: 10px; } } .menu { flex: 1; } .menuItem { height: 44px; line-height: 44px; text-align: center; padding-left: 12px; padding-right: 12px; display: block; text-decoration: none; color: rgb(126, 126, 126); cursor: pointer; -webkit-app-region: no-drag; i { font-size: 22px; } \u0026:hover { color: rgb(141, 141, 141); } } .selected { color: rgb(7, 193, 96); \u0026:hover { color: rgb(7, 193, 96); } } .setting { margin-bottom: 5px; } \u003c/style\u003e 样式为 menu 的 div 用于存放主窗口的菜单，通过 mainWindowRoutes 数组里的数据来渲染菜单。 router-link 组件会被渲染成 a 标签，当用户点击菜单时，主窗口的二级路由发生跳转（src\\renderer\\window\\WindowMain.vue）。 通过 watch 方法监控路由跳转的行为，当路由跳转后，遍历 mainWindowRoutes 数组内的对象，取消以前选中的菜单，选中新的菜单。 由于 mainWindowRoutes 是一个 Ref 对象，所以菜单被选中或取消选中之后，相应的菜单样式（和菜单内的字体图标）也会跟着变化。 在 WindowMain.vue 中添加如下代码： \u003cscript setup lang=\"ts\"\u003e import { ipcRenderer } from \"electron\"; import { onMounted } from \"vue\"; import BarLeft from \"../components/BarLeft.vue\"; onMounted(() =\u003e { ipcRenderer.invoke(\"showWindow\"); }); \u003c/script\u003e \u003ctemplate\u003e \u003cBarLeft /\u003e \u003cdiv class=\"pageBox\"\u003e \u003crouter-view /\u003e \u003c/div\u003e \u003c/template\u003e \u003cstyle scoped lang=\"scss\"\u003e .pageBox { flex: 1; height: 100%; border-top: 1px solid #e6e6e6; box-sizing: border-box; display: flex; margin-top: -1px; } \u003c/style\u003e ","date":"2023-02-02","objectID":"/electron/:5:0","tags":["连载","第一技能"],"title":"Electron + Vue3 桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"引入字体图标 在 www.iconfont.cn/ 获得字体图标，Electron 使用 Chromium 核心，一般情况下只使用 iconfont.css 和 iconfont.ttf 这两个文件。把这两个文件放到 src/renderer/assets/icon 下，在 main.ts 导入一下 iconfont.css 就可以全局使用字体图标了。 import { createApp } from 'vue'; import './style.css'; import \"./assets/icon/iconfont.css\"; import { router } from './router'; import App from './App.vue'; createApp(App).use(router).mount('#app'); \u003ci class=\"icon icon-chat\"\u003e\u003c/i\u003e 如果 iconfont.ttf 足够小，那么 vite 会把它转义成 base64 编码的字符串，直接嵌入到样式文件中来达到少请求数量的目的，开发者可以通过在 vite.config.ts 中增加 build.assetsInlineLimit 配置（值设置为 0 即可）来关闭 vite 的这个行为。 运行项目： ","date":"2023-02-02","objectID":"/electron/:6:0","tags":["连载","第一技能"],"title":"Electron + Vue3 桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"管控应用窗口 如何管控应用内的窗口，比如：什么时候显示窗口、如何通过自定义窗口标题栏来管控单个窗口等内容。 ","date":"2023-02-02","objectID":"/electron/:7:0","tags":["连载","第一技能"],"title":"Electron + Vue3 桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"主窗口显示时机 在第一个窗口初始化的瞬间，会有一个黑窗口闪现一下，如下图所示： 按照 Electron 官网的建议，窗口一开始应该是隐藏的，在 ready-to-show 事件触发后再显示窗口，如下代码所示： const { BrowserWindow } = require(\"electron\"); const win = new BrowserWindow({ show: false }); win.once(\"ready-to-show\", () =\u003e { win.show(); }); 但这个事件的触发太早了，因为 Vue 项目的 HTML 加载之后，JavaScript 脚本还需要做很多事情才能把组件渲染出来。况且开发者可能还会在 Vue 组件初始化的早期做很多额外的工作，所以显示窗口不能依赖 ready-to-show 事件，必须手动控制。 主窗口对象 mainWindow 初始化时，把配置属性 show 设置为 false，就可以让主窗口初始化成功后处于隐藏状态。 接下来再在合适的时机让渲染进程控制主窗口显示出来即可。这里在 WindowMain.vue 组件渲染完成之后来完成这项工作，如下代码所示： import { ipcRenderer } from \"electron\"; import { onMounted } from \"vue\"; onMounted(() =\u003e { ipcRenderer.invoke(\"showWindow\"); }); ","date":"2023-02-02","objectID":"/electron/:7:1","tags":["连载","第一技能"],"title":"Electron + Vue3 桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"自定义窗口标题栏 在 src/renderer/components 下新建 BarTop.vue，这是窗口标题栏组件： \u003ctemplate\u003e \u003cdiv class=\"topBar\"\u003e \u003cdiv class=\"winTitle\"\u003e{{ title }}}\u003c/div\u003e \u003cdiv class=\"winTool\"\u003e \u003cdiv @click=\"minimizeMainWindow\"\u003e \u003ci class=\"icon icon-minimize\"/\u003e \u003c/div\u003e \u003cdiv v-if=\"isMaximized\" @click=\"unmaximizeMainWindow\"\u003e \u003ci class=\"icon icon-restore\"/\u003e \u003c/div\u003e \u003cdiv v-else @click=\"maxmizeMainWin\"\u003e \u003ci class=\"icon icon-maximize\"/\u003e \u003c/div\u003e \u003cdiv @click=\"closeWindow\"\u003e \u003ci class=\"icon icon-close\"/\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript lang=\"ts\" setup\u003e \u003c/script\u003e \u003cstyle lang=\"scss\" scoped\u003e .topBar { display: flex; height: 25px; line-height: 25px; -webkit-app-region: drag; /* 可拖拽区域 */ width: 100%; } .winTitle { flex: 1; padding-left: 12px; font-size: 14px; color: #888; } .winTool { height: 100%; display: flex; -webkit-app-region: no-drag; /* 可拖拽区域内的不可拖拽区域 */ } .winTool div { height: 100%; width: 34px; text-align: center; color: #999; cursor: pointer; line-height: 25px; } .winTool .icon { font-size: 10px; color: #666666; font-weight: bold; } .winTool div:hover { background: #efefef; } .winTool div:last-child:hover { background: #ff7875; } .winTool div:last-child:hover i { color: #fff !important; } \u003c/style\u003e 要自定义一个窗口的标题栏必须把窗口默认的标题栏取消掉才行。只需要在初始化 mainWindow 对象时（主进程里的逻辑），把窗口配置对象的 frame 属性设置为 false 就可以使这个窗口成为无边框窗口了。 窗口标题是通过 props 数据传递给标题栏组件的，也就是说标题栏的标题是由其父组件来确定的。 标题栏中可拖拽区域是通过样式 -webkit-app-region: drag 定义的，鼠标在这个样式定义的组件上拖拽可以移动窗口，双击可以放大或者还原窗口，如果这个组件内有子组件不希望拥有该能力，可以通过 -webkit-app-region: no-drag; 来取消此能力。 最大化、最小化、还原、关闭窗口等按钮的点击事件，都是通过 ipcRenderer.invoke 方法来调用主进程 CommonWindowEvent 类提供的消息管道来实现对应的功能的。 由于窗口最大化（或还原）不一定是通过点击最大化按钮（或还原按钮）触发的，有可能是通过双击标题栏可拖拽区域触发的，所以这里只能通过 ipcRenderer.on 来监听窗口的最大化或还原事件，以此来改变对应的最大化或还原按钮的显隐状态。不能在按钮点击事件中来完成这项工作。windowMaximized 消息和 windowUnmaximized 消息也是由主进程的 CommonWindowEvent 类发来的。 由于多个二级路由页面会引用 BarTop.vue，为了避免在切换路由的时候，反复通过 ipcRenderer.on 注册消息监听器，所以在组件的 onUnmounted 事件内注销了消息监听器，避免事件泄漏。 src/main/CommonWindowEvent.ts 的代码如下： import { BrowserWindow, ipcMain, app } from 'electron'; // 主进程公共消息处理逻辑 export class CommonWindowEvent { private static getWin(event: any) { return BrowserWindow.fromWebContents(event.sender); } public static listen() { ipcMain.handle('minimizeWindow', e =\u003e { this.getWin(e)?.minimize(); }); ipcMain.handle('maxmizeWindow', e =\u003e { this.getWin(e)?.maximize(); }); ipcMain.handle('unmaximizeWindow', e =\u003e { this.getWin(e)?.unmaximize(); }); ipcMain.handle('hideWindow', e =\u003e { this.getWin(e)?.hide(); }); ipcMain.handle('showWindow', e =\u003e { this.getWin(e)?.show(); }); ipcMain.handle('closeWindow', e =\u003e { this.getWin(e)?.close(); }); ipcMain.handle('resizable', e =\u003e this.getWin(e)?.isResizable()); ipcMain.handle('getPath', (e, name) =\u003e app.getPath(name)); } // 主进程公共事件处理逻辑 public static regWinEvent(win: BrowserWindow) { win.on('maximize', () =\u003e { win.webContents.send('windowMaximized'); }); win.on('unmaximize', () =\u003e { win.webContents.send('windowUnmaximized'); }) } } 在 listen 方法内部注册了一系列消息管道，方便渲染进程控制主进程的一些行为，标题栏组件的窗口的最大化、最小化、还原等功能都是在这里实现的。在 app ready 之后调用 CommonWindowEvent.listen(); 这个方法即可注册这些消息管道。 regWinEvent 方法负责为窗口对象注册事件，当窗口最大化或还原后，这些事件的处理函数负责把消息发送给渲染进程。标题栏的对应按钮的图标也会发生相应的变化，同样也是在 app ready 之后调用 CommonWindowEvent.regWinEvent(mainWindow); 这个方法即可。 在 src/main/mainEntry.ts 下添加如下代码： import {app, BrowserWindow} from 'electron'; import {CustomScheme} from \"./customScheme\"; import { CommonWindowEvent } from \"./CommonWindowEvent\"; process.env.ELECTRON_DISABLE_SECURITY_WARNINGS = 'true'; let mainWindow: BrowserWindow; // 调用 CommonWindowEvent.regWinEvent(win); app.on(\"browser-window-created\", (e, win) =\u003e { CommonWindowEvent.regWinEvent(win); }); app.whenReady().then(() =\u003e { let config = { webPreferences: { nodeIntegration: true, webSecurity: false, allowRunningInsecureContent: true, contextIsolation: false, webviewTag: true, spellcheck: false, disableHtmlFullscreenWindowResize: true, }, }; mainWindow = new BrowserWindow(config); mainWindow.webContents.openDevTools({mode: 'undocked'}); if (process.argv[2]) { mainWindow.loadURL(process.argv[2]); } else { CustomScheme.regi","date":"2023-02-02","objectID":"/electron/:7:2","tags":["连载","第一技能"],"title":"Electron + Vue3 桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"窗口加载过慢解决方案 Electron 创建一个 BrowserWindow 对象，并让它成功渲染一个页面是非常耗时的，在一个普通配置的电脑上，这大概需要 2~5 秒左右的时间（少量用户反馈没这个问题）。 窗口池解决方案 提前准备 1 个或多个隐藏的窗口，让它们加载一个骨架屏页面，放到一个数组里，当应用程序需要打开一个新窗口时，就从这个数组里取出一个窗口，执行页内跳转，从骨架屏页面跳转到业务页面，然后再把这个窗口显示出来。这就消费掉了一个窗口。 当应用程序消费掉一个窗口之后，马上再创建一个新的加载了骨架屏页面的窗口放入数组，保证有足够的待命隐藏窗口。 当用户关闭某个加载了业务页面的窗口时，就把它从数组中删除掉。避免数组里存在无用的窗口。 这个方案之所以行之有效是因为在没有使用窗口时就提前准备好了窗口，等真正需要使用窗口时，仅仅是完成了一次页面跳转的工作，这个跳转工作可以在很短的时间内就完成。所以给用户的感知就是打开子窗口特别快。 webview 和 BrowserView 创建慢的问题也可以使用类似的方案解决。 然而这个方案有以下三个缺点。 无法优化整个应用的第一个窗口。 系统内部始终会有 1 到 2 个隐藏窗口处于待命状态，这无形中增加了用户的内存消耗。 虽然这个方案看上去逻辑比较简单，但要控制好所有的细节（比如，窗口间的通信、界面代码如何控制窗口的外观、如何实现模态子窗口等）还是非常繁琐的。 window.open 解决方案 Electron 允许使用 window.open 的方式打开一个子窗口，通过这种方式打开的子窗口不会创建新的进程，效率非常高，可以在几百毫秒内就为用户呈现窗口内容。 但对于一些复杂的需求却需要额外的处理才能满足需求，比如：系统设置子窗口，当用户完成某一项设置之后，要通知父窗口做出相应的改变。这是常见的父子窗口通信的需求。 首先需要为主窗口的 webContents 注册 setWindowOpenHandler 方法。 在 src/main/CommonWindowEvent.ts 中添加如下代码： mainWindow.webContents.setWindowOpenHandler((param) =\u003e { return { action: \"allow\", overrideBrowserWindowOptions: yourWindowConfig }; }); 使用 setWindowOpenHandler 方法的回调函数返回一个对象，这个对象中 action: “allow” 代表允许窗口打开，如果你想阻止窗口打开，那么只要返回 {action: “deny”} 即可。 返回对象的 overrideBrowserWindowOptions 属性的值是被打开的新窗口的配置对象。 在渲染进程中打开子窗口的代码如下所示: window.open(`/WindowSetting/AccountSetting`); window.open 打开新窗口之所以速度非常快，是因为用这种方式创建的新窗口不会创建新的进程。这也就意味着一个窗口崩溃会拖累其他窗口跟着崩溃（主窗口不受影响）。 使用 window.open 打开的新窗口还有一个问题，这类窗口在关闭之后虽然会释放掉大部分内存，但有一小部分内存无法释放（无论你打开多少个子窗口，全部关闭之后总会有那么固定的一小块内存无法释放），这与窗口池方案的内存损耗相当。 接下来介绍如何使用这个方案控制子窗口。 子窗口的标题栏消息 自定义主窗口的标题栏 BarTop.vue，标题栏组件需要监听主进程发来的 windowMaximized 消息和 windowUnmaximized 消息，子窗口当然也希望复用这个组件，然而子窗口的窗口对象是在 Electron 内部创建的，不是开发者创建的，没有子窗口的窗口对象，该如何使用 regWinEvent 方法为子窗口注册最大化和还原事件呢？ 这就需要用到 app 对象的 browser-window-created 事件，代码如下： // src/main/mainEntry.ts app.on(\"browser-window-created\", (e, win) =\u003e { CommonWindowEvent.regWinEvent(win); }); 每当有一个窗口被创建成功后，这个事件就会被触发，主窗口和使用 window.open 创建的子窗口都一样，这个事件的第二个参数就是窗口对象。 动态设置子窗口的配置 虽然可以在渲染进程中用 window.open 方法打开一个子窗口，但这个子窗口的配置信息目前还是在主进程中设置的（overrideBrowserWindowOptions），大部分时候要根据渲染进程的要求来改变子窗口的配置，所以最好的办法是由渲染进程来设置这些配置信息。 在 CommonWindowEvent 类的 regWinEvent 方法增加一段逻辑，代码如下： // 注册打开子窗口的回调函数 // @ts-ignore win.webContents.setWindowOpenHandler((param) =\u003e { // 基础窗口配置对象 let config = { frame: false, show: true, parent: null, webPreferences: { nodeIntegration: true, webSecurity: false, allowRunningInsecureContent: true, contextIsolation: false, webviewTag: true, spellcheck: false, disableHtmlFullscreenWindowResize: true, nativeWindowOpen: true, }, }; // 开发者自定义窗口配置对象 let features = JSON.parse(param.features); for (let p in features) { if (p === \"webPreferences\") { for (let p2 in features.webPreferences) { //@ts-ignore config.webPreferences[p2] = features.webPreferences[p2]; } } else { //@ts-ignore config[p] = features[p]; } } // @ts-ignore if (config[\"modal\"] === true) config.parent = win; // 允许打开窗口，并传递窗口配置对象 return {action: \"allow\", overrideBrowserWindowOptions: config}; }); config 对象和主窗口的 config 对象基本上是一样的，所以最好把它抽象出来。 param 参数的 features 属性是由渲染进程传过来的，是一个字符串，这里把它当作一个 JSON 字符串使用，这个字符串里包含着渲染进程提供的窗口配置项，这些配置项与 config 对象提供的基础配置项结合，最终形成了子窗口的配置项。 如果配置项中 modal 属性的值为 true 的话，说明渲染进程希望子窗口为一个模态窗口，这时要为子窗口提供父窗口配置项：parent，这个配置项的值就是当前窗口。 之所以把这段逻辑放置在 CommonWindowEvent 类的 regWinEvent 方法中，就是希望更方便地为应用内的所有窗口提供这项能力，如果不希望这么做，也可以把这段逻辑放置在一个独立的方法中。 在 src/renderer/components/BarLeft.vue 中添加如下代码： const openSettingWindow = () =\u003e { const config = { modal: true, width: 2002, webPreferences: { webviewTag: false } }; window.open(`/WindowSetting/AccountSetting`, \"_blank\", JSON.stringify(config)); }; window.open 方法的第三个参数官方定义为一个逗号分割的 key-value 列表，但这里把它变成了一个 JSON 字符串，这样做主要是为了方便地控制子窗口的配置对象。 使用 window.open 打开新窗口速度非常快，所以这里直接让新窗口显示出来了 config.show = true。如果你需要在新窗口初始化时完成复杂耗时的业务逻辑，那么你也应该手动控制新窗口的显示时机。 封装子窗口加载成功的事件 现在遇到了一个问题：不知道子窗口何时加载成功了，注意这里不能单纯地使用 window 对象的 onload 事件或者 document 对象的 DOMContentLoaded 事件来判断子窗口是否加载成功了。因为这个时候你的业务代码（比如从数据库异步读取数据的逻辑）可能尚未执行完成。 所以，要自己封装一个事件，在业务代码真正执行完成时，手动发射这个事件，告知主窗口：“现在子窗口已经加载成功啦，你可以给我发送消息了！” 在封装这个事件前，先来把 window.open 打开子窗口的逻辑封装到一个 Promise 对象中，如下代码所示： src/renderer/common/Dialog.ts ex","date":"2023-02-02","objectID":"/electron/:7:3","tags":["连载","第一技能"],"title":"Electron + Vue3 桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"Pinia 管理应用状态 相比 Vuex，Pinia 的优势主要是： 没有 mutations，相应的工作都在 actions 中完成，actions 直接支持异步函数。 完美支持 TypeScript，Vuex 在这方面做得不是很好。 对开发工具支持友好，，Pinia 对调试工具（vue-devtools）也支持友好。 不需要再使用名称空间来控制 store，也不需要再考虑 store 的嵌套问题。 性能优于 Vuex。 ","date":"2023-02-02","objectID":"/electron/:8:0","tags":["连载","第一技能"],"title":"Electron + Vue3 桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"安装 Pinia npm i pinia -D 修改渲染进程入口文件，加载 Pinia 插件： src/renderer/main.ts import {createApp} from 'vue'; import {router} from './router'; import { createPinia } from \"pinia\"; import App from './App.vue'; import './style.css'; import \"./assets/icon/iconfont.css\"; createApp(App).use(createPinia()).use(router).mount('#app'); ","date":"2023-02-02","objectID":"/electron/:8:1","tags":["连载","第一技能"],"title":"Electron + Vue3 桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"创建 Store 在 src/renderer/store 目录下新建 index.ts，创建第一个 Store 程序，代码如下： import { defineStore } from 'pinia'; import { Ref, ref } from 'vue'; import { ModelChat } from '../../model/ModelChat'; // mock data const prepareData = () =\u003e { let result = []; for (let i = 0; i \u003c 10; i++) { let model = new ModelChat(); model.fromName = '聊天对象' + i; model.sendTime = '昨天'; model.lastMsg = '这是此会话的最后一条消息' + i; model.avatar = 'https://pic3.zhimg.com/v2-306cd8f07a20cba46873209739c6395d_im.jpg?source=32738c0c'; result.push(model); } return result; }; export const useChatStore = defineStore('chat', () =\u003e { let data: Ref\u003cModelChat[]\u003e = ref(prepareData()); const selectItem = (item: ModelChat) =\u003e { if (item.isSelected) return; data.value.forEach((v) =\u003e (v.isSelected = false)); item.isSelected = true; }; return { data, selectItem }; }); 通过 export 暴露 useChatStore 方法，这个方法通过 Pinia 的 defineStore 方法创建，在 Vue 业务组件中执行这个函数实例才会得到真正的 Store。 使用 defineStore(name, callback) 的形式创建 Store，这种形式的 Store 叫作 Setup Stores。Pinia 还提供了另一种形式的 Store ：Option Stores，具体可以参阅 Pinia 的官方文档。 这个 Store 的状态数据存储在：data 属性中，这是一个被 Ref 对象包裹着的数组，数组里的内容是通过 prepareData 方法模拟的（模拟了十个聊天会话对象）。 这个 Store 还提供了一个 actions 方法：selectItem，这个方法用于选中某个具体的聊天会话。 ","date":"2023-02-02","objectID":"/electron/:8:2","tags":["连载","第一技能"],"title":"Electron + Vue3 桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"数据模型 Model 聊天会话的数据模型是在 src/model 目录下定义的，因为应用的主进程和渲染进程都可能会用到数据模型，所以把它放置在 renderer 和 main 的同级目录下。 新建 src/model/ModelChat.ts，如下所示： import { ModalBase } from './ModalBase'; export class ModelChat extends ModalBase { fromName?: string; sendTime?: string | number; isSelected = false; lastMsg?: string; avatar?: string; // 0 单聊，1 群聊，2 公众号，3 文件传输助手 chatType?: number; } 模型主要用于描述对象携带的信息，由于所有的模型都会拥有一些共同的字段，所以把这些字段放置在模型的基类 ModelBase 中。 新建 src/model/ModelBase.ts，如下所示： import crypto from 'crypto'; export class ModalBase { id: string; constructor() { this.id = crypto.randomUUID(); } } 暂时只提供了一个公共字段：id，凡继承于 ModelBase 的子类都将拥有这个字段，而且这个字段是随模型实例化的时候自动创建的。 只有 new ModelXXXX 时才会创建这个字段，let model = obj as ModelXXXX 时不会创建这个字段。 使用 Node.js crypto 模块的 randomUUID 方法来生成每个聊天会话的 ID。 ","date":"2023-02-02","objectID":"/electron/:8:3","tags":["连载","第一技能"],"title":"Electron + Vue3 桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"使用 Store 首先把模型中模拟的 10 个聊天会话显示在界面上，代码如下所示： src/renderer/window/WindowMain/chat/components/ChatBoard.vue \u003ctemplate\u003e \u003cdiv class=\"ChatList\"\u003e \u003cChatSearch /\u003e \u003cdiv class=\"ListBox\"\u003e \u003cChatItem :data=\"item\" v-for=\"item in store.data\" :key=\"item.id\" /\u003e \u003c/div\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript setup lang=\"ts\"\u003e import ChatItem from './ChatItem.vue'; import ChatSearch from './ChatSearch.vue'; import { onMounted } from 'vue'; import { useChatStore } from '../../../../store/useChatStore'; const store = useChatStore(); onMounted(() =\u003e { store.selectItem(store.data[6]); }); \u003c/script\u003e \u003cstyle scoped lang=\"scss\"\u003e .ChatList { width: 250px; display: flex; flex-direction: column; height: 100%; box-sizing: border-box; } .ListBox { background: rgb(230, 229, 229); background-image: linear-gradient(to bottom right, rgb(235, 234, 233), rgb(240, 240, 240)); flex: 1; overflow-y: auto; box-sizing: border-box; border-right: 1px solid rgb(214, 214, 214); } \u003c/style\u003e 通过 Vue 的 v-for 指令渲染了一个自定义组件列表（ChatItem）。 store 对象是通过 useChatStore 方法获取的，useChatStore 方法就是前面介绍的 useChatStore.ts 导出的方法。得到 store 对象之后，可以直接使用 store.data 获取 Store 对象里的数据。 在当前组件 ChatBoard 渲染完成后，调用了 store 对象的 selectItem 方法，选中了第 7 个会话。 具体每一个聊天会话对象是通过自定义组件的 data 属性传递到组件内部的。 ChatItem 自定义组件的代码如下所示： src/renderer/window/WindowMain/chat/components/ChatItem.vue \u003ctemplate\u003e \u003cdiv @click=\"itemClick(data)\" :class=\"['ChatItem', { 'ChatItemSelected': data.isSelected}]\"\u003e \u003cdiv class=\"avatar\"\u003e \u003cimg :src=\"data.avatar\" alt=\"\" /\u003e \u003c/div\u003e \u003cdiv class=\"ChatInfo\"\u003e \u003cdiv class=\"row\"\u003e \u003cdiv class=\"FromName\"\u003e{{ data.fromName }}\u003c/div\u003e \u003cdiv class=\"TimeName\"\u003e{{ data.sendTime }}\u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"row\"\u003e \u003cdiv class=\"LastMsg\"\u003e{{ data.lastMsg }}\u003c/div\u003e \u003cdiv class=\"subscribe\" /\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript lang=\"ts\" setup\u003e import { ModelChat } from '../../../../../model/ModelChat'; import { useChatStore } from '../../../../store/useChatStore'; defineProps\u003c{data: ModelChat}\u003e(); const store = useChatStore(); const itemClick = (item: ModelChat) =\u003e { store.selectItem(item); }; \u003c/script\u003e \u003cstyle scoped lang=\"scss\"\u003e .ChatItem { display: flex; height: 66px; box-sizing: border-box; cursor: pointer; \u0026:hover { background: rgb(221, 219, 218); } } .ChatItemSelected { background: rgb(196, 196, 196); \u0026:hover { background: rgb(196, 196, 196); } } .avatar { width: 66px; display: flex; align-items: center; justify-content: center; img { width: 46px; height: 46px; } } .ChatInfo { flex: 1; height: 66px; display: flex; flex-direction: column; justify-content: center; } .row { box-sizing: border-box; height: 28px; line-height: 28px; display: flex; } .FromName { flex: 1; } .TimeName { color: rgb(153, 153, 153); padding-right: 12px; font-size: 12px; } .LastMsg { color: rgb(153, 153, 153); flex: 1; font-size: 12px; } \u003c/style\u003e 使用 defineProps 方法接收父组件传来的数据。 聊天会话对象里的数据在这个自定义组件中被展开，渲染给用户。 当用户点击这个自定义组件的时候，程序执行了 Store 对象的 selectItem 方法，这个方法负责选中用户点击的组件，改变了用户点击组件的样式，同时还取消了原来选中的组件。 ","date":"2023-02-02","objectID":"/electron/:8:4","tags":["连载","第一技能"],"title":"Electron + Vue3 桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"订阅 Store 无论是用户点击 ChatItem 组件选中一个聊天会话，还是 ChatBoard 渲染完成后选中一个聊天会话，都应该通知其他组件，选中的聊天会话变更了。 在 MessageBoard 组件中演示这个功能，代码如下所示： src/renderer/window/WindowMain/chat/components/MessageBoard.vue \u003ctemplate\u003e \u003cdiv class=\"MessageBord\"\u003e \u003cBarTop /\u003e \u003cdiv class=\"MessageList\"\u003e{{ logInfo }}\u003c/div\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript lang=\"ts\" setup\u003e import { ref } from 'vue'; import BarTop from '../../../../components/BarTop.vue'; import { useChatStore } from '../../../../store/useChatStore'; let store = useChatStore(); let logInfo = ref(\"\"); let curId = \"\"; //订阅Store内数据的变化 store.$subscribe((mutations, state) =\u003e { let item = state.data.find((v) =\u003e v.isSelected); let id = item?.id as string; if (id != curId) { logInfo.value = `现在应该加载ID为${item?.id}的聊天记录`; curId = id; } }); \u003c/script\u003e \u003cstyle scoped lang=\"scss\"\u003e .MessageBord { height: 100%; display: flex; flex: 1; flex-direction: column; } .MessageList { flex: 1; overflow-y: auto; overflow-x: hidden; background: rgb(245, 245, 245); } \u003c/style\u003e 使用 store 对象的 $subscribe 方法订阅了数据变更事件，无论什么时候 store 内的数据发生了变化，都会执行 $subscribe 方法提供的回调函数。 在订阅回调中，验证选中的会话是否发生了变化（有可能是当前 store 其他数据对象的变化触发了订阅回调），如果是，那么就给出提示。 订阅回调函数有两个参数 ，第一个是 mutations 参数，这个参数的 events 属性携带着变更前的值和变更后的值，但这个属性只有在开发环境下存在，生产环境下不存在。订阅的第二个参数是 state，这个参数包含 store 中的数据。 以这种方式更新 store 里的数据，不利于复用数据更新的逻辑，改用可以复用数据更新逻辑的方案。 ","date":"2023-02-02","objectID":"/electron/:8:5","tags":["连载","第一技能"],"title":"Electron + Vue3 桌面应用开发实战","uri":"/electron/"},{"categories":["第一技能"],"content":"互访 Store 新建一个模型类，代码如下所示： src/model/ModelMessage.ts import { ModalBase } from './ModalBase'; export class ModelMessage extends ModalBase { createTime?: number; receiveTime?: number; messageContent?: string; chatId?: string; fromName?: string; avatar?: string; // 是否为传入消息 isInMsg?: boolean; } 创建 useMessageStore，用于管理消息的状态数据，代码如下： src/renderer/store/useMessageStore.ts import { ModelChat } from '../../model/ModelChat'; import { ModelMessage } from '../../model/ModelMessage'; import { defineStore } from 'pinia'; import { ref, Ref } from 'vue'; export const useMessageStore = defineStore('message', () =\u003e { let data: Ref\u003cModelMessage[]\u003e = ref([]); const msg1 = `醉里挑灯看剑，梦回吹角连营。八百里分麾下灸，五十弦翻塞外声。沙场秋点兵。马作的卢飞快，弓如霹雳弦惊。了却君王天下事，嬴得生前身后名。可怜白发生`; const msg2 = `怒发冲冠，凭栏处，潇潇雨歇。抬望眼，仰天长啸，壮怀激烈。 三十功名尘与土，八千里路云和月。莫等闲，白了少年头，空悲切！ 靖康耻，犹未雪；臣子恨，何时灭?驾长车，踏破贺兰山缺！ 壮志饥餐胡虏肉，笑谈渴饮匈奴血。待从头，收拾旧山河，朝天阙！`; const initData = (chat: ModelChat) =\u003e { let result = []; for (let i = 0; i \u003c 10; i++) { let model = new ModelMessage(); model.createTime = Date.now(); model.isInMsg = i % 2 === 0; model.messageContent = model.isInMsg ? msg1 : msg2; model.fromName = model.isInMsg ? chat.fromName : \"我\"; model.avatar = chat.avatar; model.chatId = chat.id; result.push(model); } data.value = result; }; return { data, initData }; }); 消息数据是模拟出来的，这里模拟了 10 条消息，预期用户切换会话的时候，执行 initData 方法，初始化当前会话的消息。 修改一下 MessageBoard 组件的的代码，如下所示： src/renderer/window/WindowMain/chat/components/MessageBoard.vue \u003ctemplate\u003e \u003cdiv class=\"MessageBord\"\u003e \u003cBarTop /\u003e \u003cdiv class=\"MessageList\"\u003e \u003cMessageItem :data=\"item\" v-for=\"item in messageStore.data\" :key=\"item.id\"\u003e\u003c/MessageItem\u003e \u003c/div\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript lang=\"ts\" setup\u003e import BarTop from '../../../../components/BarTop.vue'; import { ModelChat } from '../../../../../model/ModelChat'; import { useMessageStore } from '../../../../store/useMessageStore'; import { useChatStore } from '../../../../store/useChatStore'; import MessageItem from './MessageItem.vue'; const chatStore = useChatStore(); const messageStore = useMessageStore(); let curId = ''; chatStore.$subscribe((mutations, state) =\u003e { const item = state.data.find(v =\u003e v.isSelected) as ModelChat; if (item?.id !== curId) { messageStore.initData(item); curId = item?.id; } }) \u003c/script\u003e \u003cstyle scoped lang=\"scss\"\u003e .MessageBord { height: 100%; display: flex; flex: 1; flex-direction: column; } .MessageList { flex: 1; overflow-y: auto; overflow-x: hidden; background: rgb(245, 245, 245); } \u003c/style\u003e 当选中的聊天会话切换时，执行 messageStore 对象的 initData 方法，这样就初始化了 messageStore 内部的状态数据。 MessageItem 是新创建的一个 Vue 组件，这个组件用于显示一条消息的具体信息。代码如下所示： src/renderer/window/WindowMain/chat/components/MessageItem.vue \u003ctemplate\u003e \u003ctemplate v-if=\"data.isInMsg\"\u003e \u003cdiv class=\"MessageItem left\"\u003e \u003cdiv class=\"avatar\"\u003e \u003cimg :src=\"data.avatar\" alt=\"\" /\u003e \u003c/div\u003e \u003cdiv class=\"MessageBox\"\u003e \u003cdiv class=\"FromName\"\u003e{{ data.fromName }}\u003c/div\u003e \u003cdiv class=\"MsgContent\"\u003e{{ data.messageContent }}\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/template\u003e \u003ctemplate v-else\u003e \u003cdiv class=\"MessageItem right\"\u003e \u003cdiv class=\"MessageBox\"\u003e \u003cdiv class=\"MessageContent\"\u003e{{ data.messageContent }}\u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"avatar\"\u003e \u003cimg :src=\"data.avatar\" alt=\"\" /\u003e \u003c/div\u003e \u003c/div\u003e \u003c/template\u003e \u003c/template\u003e \u003cscript setup lang=\"ts\"\u003e import { ModelMessage } from '../../../../../model/ModelMessage'; defineProps\u003c{ data: ModelMessage }\u003e(); \u003c/script\u003e \u003cstyle lang=\"scss\" scoped\u003e .MessageItem { display: flex; padding-top: 8px; padding-bottom: 8px; position: relative; } .left { padding-right: 30%; \u0026::after { width: 0; height: 0; border-top: 6px solid transparent; border-bottom: 6px solid transparent; border-right: 6px solid #fff; position: absolute; left: 60px; top: 38px; content: \"\"; } } .right { padding-left: 30%; \u0026::after { width: 0; height: 0; border-top: 6px solid transparent; border-bottom: 6px solid transparent; border-left: 6px solid rgb(149, 236, 105); position: absolute; right: 60px; top: 18px; content: \"\"; } .MessageContent { background: rgb(149, 236, 105) !important; } } .avatar { width: 66px; text-align: center; img { width: 46","date":"2023-02-02","objectID":"/electron/:8:6","tags":["连载","第一技能"],"title":"Electron + Vue3 桌面应用开发实战","uri":"/electron/"},{"categories":["读书"],"content":"001 长期主义 ","date":"2023-02-02","objectID":"/books/:1:0","tags":["连载","读书"],"title":"50本读书计划-2023年","uri":"/books/"},{"categories":["读书"],"content":"002 解忧杂货店 ","date":"2023-02-02","objectID":"/books/:2:0","tags":["连载","读书"],"title":"50本读书计划-2023年","uri":"/books/"},{"categories":["读书"],"content":"003 生活蒙太奇 ","date":"2023-02-02","objectID":"/books/:3:0","tags":["连载","读书"],"title":"50本读书计划-2023年","uri":"/books/"},{"categories":["谈人生"],"content":"简述一下事情的起因，因为工作变动，没有太多时间找房子，在贝壳找房上紧急租到了套一公寓，和中介公司签订了半年的租房合同，签订合同前，凭借着自己那点可怜的人生经验觉得合同好像没什么问题，就痛快地签了。 (注：合同的甲方写的是房东的名字，涉及个人隐私部分打码)。 也怪自己租房前没仔细检查，搬进来之后发现电器有一些小问题，比如客厅灯不亮这些，想着也没有太大影响，反正只租了半年，到期后肯定不租了，就先凑合住吧，就这样相安无事地住了3个月。 今年1月份忽然被告知中介公司与房东合约到期（实际是公司经营不善决定退租(：房东说的，真假无从考证），并且双方在没有告知我的情况下已经完成了手续移交。 首先沟通的是宽带问题，因为之前要每个月给中介公司交200元杂费，其中包括物业费、宽带等之类的费用，现在中介公司不管了，宽带我肯定是要用的，遂找到房东，房东让我找中介公司，中介公司让我找房东（相互踢皮球）。以下是聊天记录： 和房东沟通： 和中介沟通： 房东让找中介，中介选择沉默，最后这件事情不了了之，没办法，自己装个宽带吧。。。害。 过节回来后，又有麻烦了，窗户的锁因为老旧坏掉了，大冬天太冷了，冻了3天之后，实在忍不了了，因为我对周围环境也不熟悉，想着联系下房东帮忙给处理下，然后就发生了不愉快的事情，房东勒令我立马搬出去，中介还是一如既往地踢皮球，还报了警，民警来了只是问了问，给了点建议，说他们管不了，然后就走了。 和房东沟通： 和中介沟通： 中间还给房东打了电话，房东说自己是70岁+的退休国家干部，已经实现了财务自由，言语中透露出浓浓地官僚资本主义，所以不在乎房子租不租的出去，只是怕麻烦，喊我如果想继续住下去，就每个月只按时给她房租，其余的事情全部自己来解决。 最后这件事情，肯定是自己掏钱把锁修好了。自己可能还是太年轻吧，言语中充满了愤愤不平和对当今这个社会的失望。冷静下来之后，研究了下租房合同、他们的交接协议、以及这段时间和他们的沟通记录： 首先：甲乙（甲：房东，乙：中介公司）双方于1月15日进行房子交割协议，中介公司将押金和15日之后的房租交给了房东，是不是就说明这个房子和中介公司没有关系了，以后房子的事情都由房东自己来处理（作为房东出租房屋应该有责任要处理房子硬件设施老化维护的问题）。 其次：中介公司未提前与我进行沟通，这种情况是不是处理太不恰当，并应该有义务对之后的纠纷进行协调处理。 附上一篇从网上找到的相关报道，虽然我目前的状况还没有这个人的这么严重… 我的朋友，你怎么看待这件事情呢？期待收获您的宝贵经验。 更新： 几位朋友给出了自己的建议。 “你可以找人问问合同的履行人现在是公司还是房东，but都很麻烦，走警察都是劝诫为主，走法院半年起步。” “这事只能吃哑巴亏，自己认倒霉。” “那你直接跟这个房东补签一个三个月的短租合同好了看她同不同意。” “你就说她让你搬出去也得把之前的押金退给你，然后你搬出去了再到她找到新房客中间少说也要一个多星期两个星期房子是空着的，她自己是有损失的，谁也不会跟钱过不去。” so，这房子到期就 👋🏻 吧 👵🏻，等待下一个倒霉 🥚 入坑。 ","date":"2023-01-30","objectID":"/blog/:0:0","tags":["谈人生"],"title":"由亲身经历的房屋出租纠纷引发的思考...","uri":"/blog/"},{"categories":["第二技能"],"content":"项目地址： learningC- ","date":"2023-01-22","objectID":"/c-/:0:0","tags":["连载","第二技能"],"title":"C++ 前端开发菜鸡必知必会","uri":"/c-/"},{"categories":["第二技能"],"content":"VSCode C++ 环境配置 ","date":"2023-01-22","objectID":"/c-/:1:0","tags":["连载","第二技能"],"title":"C++ 前端开发菜鸡必知必会","uri":"/c-/"},{"categories":["第二技能"],"content":"VSCode 下载 官网下载 Visual Studio Code ","date":"2023-01-22","objectID":"/c-/:1:1","tags":["连载","第二技能"],"title":"C++ 前端开发菜鸡必知必会","uri":"/c-/"},{"categories":["第二技能"],"content":"扩展包安装 C/C++ CodeLLDB ","date":"2023-01-22","objectID":"/c-/:1:2","tags":["连载","第二技能"],"title":"C++ 前端开发菜鸡必知必会","uri":"/c-/"},{"categories":["第二技能"],"content":"环境配置 新建 main.cpp 文件，输入以下代码： #include \u003ciostream\u003e int main() { std::cout \u003c\u003c \"hello world\" \u003c\u003c std::endl; char c = std::getchar(); return 0; } 点击运行调试，选择 C++ (GDB/LLDB) 选择 g++ 生成和调试活动文件 在 .vscode 中会生成两个文件，对这两个文件进行配置： launch.json { // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"lldb\", \"request\": \"launch\", \"name\": \"C++ debug\", \"program\": \"${fileDirname}/${fileBasenameNoExtension}\", \"args\": [], \"cwd\": \"${workspaceFolder}\", \"preLaunchTask\": \"C/C++: g++ 生成活动文件\" } ] } tasks.json { \"tasks\": [ { \"type\": \"cppbuild\", \"label\": \"C/C++: g++ 生成活动文件\", \"command\": \"/usr/bin/g++\", \"args\": [ \"-std=c++17\", \"-stdlib=libc++\", \"-fdiagnostics-color=always\", \"-g\", \"-Wall\", \"${file}\", \"-o\", \"${fileDirname}/${fileBasenameNoExtension}\" ], \"options\": { \"cwd\": \"${fileDirname}\" }, \"problemMatcher\": [ \"$gcc\" ], \"group\": { \"kind\": \"build\", \"isDefault\": true }, \"detail\": \"调试器生成的任务。\" } ], \"version\": \"2.0.0\" } 至此，C++ 环境配置完成。 运行项目，输出结果： ","date":"2023-01-22","objectID":"/c-/:1:3","tags":["连载","第二技能"],"title":"C++ 前端开发菜鸡必知必会","uri":"/c-/"},{"categories":["第二技能"],"content":"包含目录和依赖项 在 C++ 程序中包含两种文件：头文件 (.h) 和源码文件 (.cpp)，一个业务单元 (比如 a.h 和 a.cpp)，头文件负责定义类型、方法和变量，源码文件则负责实现类型、方法和为变量赋值。 源码文件为了实现头文件中定义的内容，需要通过如下方式引入头文件： #include \"a.h\" 想在 a 业务单元中引入 b 业务单元定义的内容，也需要通过 include 方式引入： #include \"bHeaderFilePath/b.h\" 可以在 a.h 中引入 b 的头文件，也可以在 a.cpp 中引入 b 的头文件。 如果是在 a.h 中引入了 b 的头文件，则 a.h 和 a.cpp 都可以使用 b 的头文件中定义的内容。 如果只在 a.cpp 中引入了 b 的头文件，则只能在 a.cpp 中使用 b 的头文件中定义的内容。 如果引入操作系统 SDK 提供的头文件或标准库提供的头文件，则不用写明头文件的相对路径，但需要用尖括号包裹。 #include \u003ciostream\u003e //这个头文件没有.h扩展名 #include \u003cwindows.h\u003e ","date":"2023-01-22","objectID":"/c-/:2:0","tags":["连载","第二技能"],"title":"C++ 前端开发菜鸡必知必会","uri":"/c-/"},{"categories":["乱涂乱画"],"content":"001 窗台上的🐱 下辈子做一只猫，翘着尾巴云游天下，跟狗打架。 ","date":"2023-01-19","objectID":"/draw/:1:0","tags":["连载","乱涂乱画"],"title":"100张油画棒画计划","uri":"/draw/"},{"categories":["乱涂乱画"],"content":"002 🐳与☁️ 热爱漫无边际，生活自有分寸。 ","date":"2023-01-19","objectID":"/draw/:2:0","tags":["连载","乱涂乱画"],"title":"100张油画棒画计划","uri":"/draw/"},{"categories":["乱涂乱画"],"content":"003 露营⛺️ 一起去露营吧，揽星河入怀，拥山野而眠。 ","date":"2023-01-19","objectID":"/draw/:3:0","tags":["连载","乱涂乱画"],"title":"100张油画棒画计划","uri":"/draw/"},{"categories":["乱涂乱画"],"content":"004 福🐰贺春 新年快乐。 ","date":"2023-01-19","objectID":"/draw/:4:0","tags":["连载","乱涂乱画"],"title":"100张油画棒画计划","uri":"/draw/"},{"categories":["碎碎念"],"content":"2022-12 ","date":"2022-12-11","objectID":"/2022/:1:0","tags":["碎碎念"],"title":"Q的乱语-2022年","uri":"/2022/"},{"categories":["碎碎念"],"content":"12-01 钱都起床了，你还不起。 ","date":"2022-12-11","objectID":"/2022/:1:1","tags":["碎碎念"],"title":"Q的乱语-2022年","uri":"/2022/"},{"categories":["碎碎念"],"content":"12-02 坚持每周中强度运动150分钟/高强度运动70分钟，可以获得一个漂亮的大海马体。 ","date":"2022-12-11","objectID":"/2022/:1:2","tags":["碎碎念"],"title":"Q的乱语-2022年","uri":"/2022/"},{"categories":["碎碎念"],"content":"12-03 人可以平庸，但不能踩着人往上，也不能通过贬低和否定他人，来实现自己的价值。 ","date":"2022-12-11","objectID":"/2022/:1:3","tags":["碎碎念"],"title":"Q的乱语-2022年","uri":"/2022/"},{"categories":["碎碎念"],"content":"12-04 被欲望蒙蔽双眼的人，往往分不清眼前的是食物还是诱饵。 ","date":"2022-12-11","objectID":"/2022/:1:4","tags":["碎碎念"],"title":"Q的乱语-2022年","uri":"/2022/"},{"categories":["碎碎念"],"content":"12-05 这支球队就像一个平凡努力的普通人的一生。他不是最强最出彩的，但你想赢他也不容易，因为他有强大的定力和拼劲，打不倒压不垮，还能绝处逢生。 ","date":"2022-12-11","objectID":"/2022/:1:5","tags":["碎碎念"],"title":"Q的乱语-2022年","uri":"/2022/"},{"categories":["碎碎念"],"content":"12-06 不到最后一刻，都不算真正结束。 ","date":"2022-12-11","objectID":"/2022/:1:6","tags":["碎碎念"],"title":"Q的乱语-2022年","uri":"/2022/"},{"categories":["碎碎念"],"content":"12-07 你知道养劳工为什么不能让他们不愁吃穿吗？因为他们会以为自己才是主人。 ","date":"2022-12-11","objectID":"/2022/:1:7","tags":["碎碎念"],"title":"Q的乱语-2022年","uri":"/2022/"},{"categories":["碎碎念"],"content":"12-08 公司有人🐑了。。。 ","date":"2022-12-11","objectID":"/2022/:1:8","tags":["碎碎念"],"title":"Q的乱语-2022年","uri":"/2022/"},{"categories":["碎碎念"],"content":"12-09 神🐱压中了🇭🇷 ","date":"2022-12-11","objectID":"/2022/:1:9","tags":["碎碎念"],"title":"Q的乱语-2022年","uri":"/2022/"},{"categories":["碎碎念"],"content":"12-10 公司后端写的烂接口，一个都不能用，就混吧 ","date":"2022-12-11","objectID":"/2022/:1:10","tags":["碎碎念"],"title":"Q的乱语-2022年","uri":"/2022/"},{"categories":["碎碎念"],"content":"12-11 《纸房子·第二季》 “纸房子是人民的！” 小红猪里裂开的都是💰啊。。 ","date":"2022-12-11","objectID":"/2022/:1:11","tags":["碎碎念"],"title":"Q的乱语-2022年","uri":"/2022/"},{"categories":["碎碎念"],"content":"12-12 🥶🥶🥶 ","date":"2022-12-11","objectID":"/2022/:1:12","tags":["碎碎念"],"title":"Q的乱语-2022年","uri":"/2022/"},{"categories":["碎碎念"],"content":"12-13 嗓子冒烟了。 ","date":"2022-12-11","objectID":"/2022/:1:13","tags":["碎碎念"],"title":"Q的乱语-2022年","uri":"/2022/"},{"categories":["碎碎念"],"content":"12-14 🐑了。 ","date":"2022-12-11","objectID":"/2022/:1:14","tags":["碎碎念"],"title":"Q的乱语-2022年","uri":"/2022/"},{"categories":["碎碎念"],"content":"12-15 发烧中。 ","date":"2022-12-11","objectID":"/2022/:1:15","tags":["碎碎念"],"title":"Q的乱语-2022年","uri":"/2022/"},{"categories":["碎碎念"],"content":"12-16 发烧中。 ","date":"2022-12-11","objectID":"/2022/:1:16","tags":["碎碎念"],"title":"Q的乱语-2022年","uri":"/2022/"},{"categories":["碎碎念"],"content":"12-17 发烧中。 ","date":"2022-12-11","objectID":"/2022/:1:17","tags":["碎碎念"],"title":"Q的乱语-2022年","uri":"/2022/"},{"categories":["碎碎念"],"content":"12-18 和饼干一起晒☀️，地上铺上新毯子，🐱在地上趴着就不会🥶了。 ","date":"2022-12-11","objectID":"/2022/:1:18","tags":["碎碎念"],"title":"Q的乱语-2022年","uri":"/2022/"},{"categories":["碎碎念"],"content":"12-19 🔥。 ","date":"2022-12-11","objectID":"/2022/:1:19","tags":["碎碎念"],"title":"Q的乱语-2022年","uri":"/2022/"},{"categories":["碎碎念"],"content":"12-20 ","date":"2022-12-11","objectID":"/2022/:1:20","tags":["碎碎念"],"title":"Q的乱语-2022年","uri":"/2022/"},{"categories":["碎碎念"],"content":"12-21 分享最近很火的一段僵尸舞，来自《星期三》 ","date":"2022-12-11","objectID":"/2022/:1:21","tags":["碎碎念"],"title":"Q的乱语-2022年","uri":"/2022/"},{"categories":["碎碎念"],"content":"12-22 感谢瑞幸咖啡和同事的草莓糖，味觉和嗅觉回来了😄 ","date":"2022-12-11","objectID":"/2022/:1:22","tags":["碎碎念"],"title":"Q的乱语-2022年","uri":"/2022/"},{"categories":["碎碎念"],"content":"12-23 熬夜看完了《星期三》，喜欢这种暗黑👧🏻。 ","date":"2022-12-11","objectID":"/2022/:1:23","tags":["碎碎念"],"title":"Q的乱语-2022年","uri":"/2022/"},{"categories":["碎碎念"],"content":"12-24 🍎 ","date":"2022-12-11","objectID":"/2022/:1:24","tags":["碎碎念"],"title":"Q的乱语-2022年","uri":"/2022/"},{"categories":["碎碎念"],"content":"12-25 Merry Christmas🎄 ","date":"2022-12-11","objectID":"/2022/:1:25","tags":["碎碎念"],"title":"Q的乱语-2022年","uri":"/2022/"},{"categories":["碎碎念"],"content":"12-26 这本书很有意思。 ","date":"2022-12-11","objectID":"/2022/:1:26","tags":["碎碎念"],"title":"Q的乱语-2022年","uri":"/2022/"},{"categories":["碎碎念"],"content":"12-27 IoTSharp官网新鲜出炉。 ","date":"2022-12-11","objectID":"/2022/:1:27","tags":["碎碎念"],"title":"Q的乱语-2022年","uri":"/2022/"},{"categories":["碎碎念"],"content":"12-28 少年去游荡，中年想掘藏，老年做和尚。 ","date":"2022-12-11","objectID":"/2022/:1:28","tags":["碎碎念"],"title":"Q的乱语-2022年","uri":"/2022/"},{"categories":["碎碎念"],"content":"12-29 烤无双，很好吃呦😄 ","date":"2022-12-11","objectID":"/2022/:1:29","tags":["碎碎念"],"title":"Q的乱语-2022年","uri":"/2022/"},{"categories":["碎碎念"],"content":"12-30 和家里人保持联系，他们是这个世界上最爱你的人。 ","date":"2022-12-11","objectID":"/2022/:1:30","tags":["碎碎念"],"title":"Q的乱语-2022年","uri":"/2022/"},{"categories":["碎碎念"],"content":"12-31 2022 年的最后一天，这一年，浑浑噩噩，基本什么都没有干成。希望明年可以多做些有意义的事情。 2023 年的目标： 减重到 47 公斤左右 提升第一技能，react、vue3、typescript 等 开始第二技能，STEAM32、C、C++ 等 学一门乐器，例如尤克里里 保证参与开源项目，github争取每天都有贡献 每天学英语 微信读书读完 50 本书籍 买一套属于自己的房子 考 MBA 护肤、淡妆、健康、搞钱 多回家看看、多爱惜自己 ","date":"2022-12-11","objectID":"/2022/:1:31","tags":["碎碎念"],"title":"Q的乱语-2022年","uri":"/2022/"},{"categories":null,"content":"关于 LoveIt","date":"2019-08-02","objectID":"/about/","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"  LoveIt 是一个由  Dillon 开发的简洁、优雅且高效的 Hugo 博客主题。 它的原型基于 LeaveIt 主题 和 KeepIt 主题。 Hugo 主题 LoveIt ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"特性 ","date":"2019-08-02","objectID":"/about/:1:0","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"性能和 SEO  性能优化：在 Google PageSpeed Insights 中， 99/100 的移动设备得分和 100/100 的桌面设备得分  使用基于 JSON-LD 格式 的 SEO SCHEMA 文件进行 SEO 优化  支持 Google Analytics  支持 Fathom Analytics  支持 Plausible Analytics  支持 Yandex Metrica  支持搜索引擎的网站验证 (Google, Bind, Yandex and Baidu)  支持所有第三方库的 CDN  基于 lazysizes 自动转换图片为懒加载 ","date":"2019-08-02","objectID":"/about/:1:1","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"外观和布局  桌面端/移动端 响应式布局  浅色/深色 主题模式  全局一致的设计语言  支持分页  易用和自动展开的文章目录  支持多语言和国际化  美观的 CSS 动画 社交和评论系统  支持 Gravatar 头像  支持本地头像  支持多达 73 种社交链接  支持多达 24 种网站分享  支持 Disqus 评论系统  支持 Gitalk 评论系统  支持 Valine 评论系统  支持 Facebook comments 评论系统  支持 Telegram comments 评论系统  支持 Commento 评论系统  支持 utterances 评论系统  支持 giscus 评论系统 ","date":"2019-08-02","objectID":"/about/:1:2","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"扩展功能  支持基于 Lunr.js 或 algolia 的搜索  支持 Twemoji  支持代码高亮  一键复制代码到剪贴板  支持基于 lightGallery 的图片画廊  支持 Font Awesome 图标的扩展 Markdown 语法  支持上标注释的扩展 Markdown 语法  支持分数的扩展 Markdown 语法  支持基于 $\\KaTeX$ 的数学公式  支持基于 mermaid 的图表 shortcode  支持基于 ECharts 的交互式数据可视化 shortcode  支持基于 Mapbox GL JS 的 Mapbox shortcode  支持基于 APlayer 和 MetingJS 的音乐播放器 shortcode  支持 Bilibili 视频 shortcode  支持多种注释的 shortcode  支持自定义样式的 shortcode  支持自定义脚本的 shortcode  支持基于 TypeIt 的打字动画 shortcode  支持基于 cookieconsent 的 Cookie 许可横幅  支持人物标签的 shortcode … ","date":"2019-08-02","objectID":"/about/:1:3","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"许可协议 LoveIt 根据 MIT 许可协议授权。 更多信息请查看 LICENSE 文件。 ","date":"2019-08-02","objectID":"/about/:2:0","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"特别感谢 LoveIt 主题中用到了以下项目，感谢它们的作者： normalize.css Font Awesome Simple Icons Animate.css autocomplete Lunr.js algoliasearch lazysizes object-fit-images Twemoji emoji-data lightGallery clipboard.js Sharer.js TypeIt $\\KaTeX$ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine cookieconsent ","date":"2019-08-02","objectID":"/about/:3:0","tags":null,"title":"关于 LoveIt","uri":"/about/"}]