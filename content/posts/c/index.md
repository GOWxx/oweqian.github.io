---
title: "👩‍💻 从 0 学习 C 语言"
date: 2023-03-20T14:00:00+08:00
weight: 4
tags: ["第二技能"]
categories: ["第二技能"]
---

朋友花了 1000 多块送的 STEAM32 电路板，钱不能白花，我要先把 C 语言学会，加油吧！         

<!--more-->

## 两数相加

### 例题 1 

#### 题目内容  

输入两个正整数 a 和 b，输出 a + b 的值。其中 a,b <= 10000。   

#### 通关思路

基础输入输出。   

* #include 是包含头文件的语法。stdio.h 是输入输出相关的头文件，所有的 scanf 和 printf 都必须包含这个头文件。   
* main 函数是程序执行的入口，程序会检测到这个入口函数，然后开始向下执行。   
* 声明两个变量 a 和 b。   
* 通过控制台输入两个数字，并且赋值给 a 和 b。   
* 将 a + b 的结果输出到终端上。   
* return 0 是 main 函数的返回值语句，返回以后程序就结束了。   

#### 代码实现

```
#include <stdio.h>

int main() {
    int a, b;
    scanf("%d %d", &a, &b);
    printf("%d\n", a + b);
    return 0;
}
```

### 例题 2

#### 题目内容

先输入一个 t(t <= 100)，然后输入 t 组数据。对于每组数据，输入两个正整数 a 和 b，输出 a + b 的值。其中 a,b <= 10000。   

#### 通关思路

基础输入输出，循环。     

* while (expr) { body } 是一个循环语句的结构，其中 expr 表示表达式，而 body 则代表循环的内容。这里 expr 就是 t-- 了，当 t = 0 时，这个表达式的值为 0，整个循环结束。   

#### 代码实现

```
int main() {
    int a, b, t;
    scanf("%d", &t);
    while(t--) {
        scanf("%d %d", &a, &b);
        printf("%d\n", a + b);
    }
    return 0;
}
```

### 例题 3

#### 题目内容

循环输入，每输入两个正整数 a 和 b，就输出 a + b 的值。其中 a,b <= 10000。当没有任何输入时，结束程序。   

#### 通关思路

基础输入输出，循环。

* 当 scanf 返回 EOF 时，就代表没有任何输入了，正常情况下返回输入成功的数的个数。       
* EOF 是一个宏，可以认为它的值就是整数 -1。   

#### 代码实现

```
int main() {
    int a, b;
    while(scanf("%d %d", &a, &b) != EOF) {
        printf("%d\n", a + b);
    }
    return 0;
}
```

### 例题 4

#### 题目内容

循环输入，每输入两个正整数 a 和 b，就输出 a + b 的值。其中 a,b <= 10000。当输入的 a 和 b 都等于零时，结束程序。   

#### 通关思路

基础输入输出，循环。

* 只需要在循环体内，加上满足退出循环条件的判断即可，"a==0 && b==0，然后套上 if 语句和 break; 语句。   

#### 代码实现

```
int main() {
    int a, b;
    while(scanf("%d %d", &a, &b) != EOF) {
        if (a == 0 && b == 0)
            break;
        printf("%d\n", a + b);
    }
    return 0;
}
```

### 例题 5

#### 题目内容

实现一个函数 add，传入参数为 a 和 b，返回两者之和。    

#### 通关思路

函数定义。   

#### 代码实现

```
int add(int a, int b) {
    return a + b;
}
```

## 等差数列求和

### 题目内容

循环输入，每输入一个正整数 n(n <= 65535)，输出 1 + 2 + 3 + ... + n 的值，并且多输出一个空行。当没有任何输入时，结束程序。    

### 解题思路

* 由于 n <= 65535，完全可以通过循环的方式从 n 倒叙遍历到 1，然后将遍历到的数字进行累加输出。时间复杂度是 O(n)。   
* 等差数列求和公式：1 + 2 + 3 + ... + n = n * (n + 1) / 2。只要知道 n 的值，就可以在 O(1) 的时间内求得最终答案。    

### 代码实现

#### 错误解法

```
int main() {
    int n;
    while(scanf("%d", &n) != EOF) {
        int sum = n * (n + 1) / 2;
        printf("%d\n\n", sum);
    }
    return 0;
}
```

这行代码直接套用等差数列求和公式，但是这里有一个小问题。    

* 当 n 取最大值 65535 时，n * (n + 1) = 65535 * 65536 = (2 ** 16 - 1) * 2 ** 16 = 2 ** 32 - 2 ** 16，而 int 能够表示的最大值为 2 ** 31 - 1，所以产生了溢出，变成了负数。      

#### 循环枚举

```
int main() {
    int n, sum;
    while(scanf("%d", &n) != EOF) {
        sum = 0;
        while (n--) {
          sum += n;
          --n;
        }
        printf("%d\n\n", sum);
    }
    return 0;
}
```

* 初始化结果 sum 为 0。    
* while 语句循环自减 n，直到 n 为 0 为止。   
* 将当前 n 的值累加到 sum。    
* --n 等价于 n = n - 1。    

#### 奇偶性判断

```
int main() {
    int n, sum;
    while (scanf("%d", &n) != EOF) {
        if (n % 2 == 0) {
            sum = n / 2 * (n + 1);
            printf("%d\n\n", sum);
        } else {
            sum = (n + 1) / 2 * n;
            printf("%d\n\n", sum);
        }
    }
    return 0;
}
```

* n 和 n + 1 的奇偶性不同，两者相乘必然能被 2 整除。   
* 根据奇偶性来决定是用 n 去除 2，还是用 n + 1 去除 2，避免溢出。   
* % 代表取模的意思。   
* n 为偶数时，n 能被 2 整除，先计算 n / 2，在乘上 n + 1。    
* n 为奇数时，n + 1 能被 2 整除，先计算 (n + 1) / 2，在乘上 n。  

#### 无符号整形    

```
int main() {
    unsigned int n;
    while (scanf("%u", &n) != EOF) {
        unsigned int sum = n * (n + 1) / 2;
        printf("%u\n\n", sum);
    }
    return 0;
}
```

* 无符号整形的范围为 [0, 2 ** 32 - 1]，不用担心溢出问题。    

#### 64 位整形

```
int main() {
    long long n;
    while (scanf("%lld", &n) != EOF) {
        long long sum = n * (n + 1) / 2;
        printf("%lld\n\n", sum);
    }
    return 0;
}
```

* 64 位整形的范围为 [-2 ** 63, 2 ** 63 - 1]，不用担心溢出问题。   
